// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: report_instances.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const ActivateReportInstance = `-- name: ActivateReportInstance :exec
UPDATE report_instances SET is_active = TRUE, updated_at = NOW() WHERE id = $1
`

func (q *Queries) ActivateReportInstance(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, ActivateReportInstance, id)
	return err
}

const CreateReportInstance = `-- name: CreateReportInstance :one
INSERT INTO report_instances (
    report_template_id, name, description, parameters, schedule, is_active, created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, report_template_id, name, description, parameters, schedule, last_run, next_run, is_active, created_by, created_at, updated_at
`

type CreateReportInstanceParams struct {
	ReportTemplateID uuid.UUID             `json:"report_template_id"`
	Name             string                `json:"name"`
	Description      sql.NullString        `json:"description"`
	Parameters       pqtype.NullRawMessage `json:"parameters"`
	Schedule         sql.NullString        `json:"schedule"`
	IsActive         sql.NullBool          `json:"is_active"`
	CreatedBy        uuid.NullUUID         `json:"created_by"`
}

func (q *Queries) CreateReportInstance(ctx context.Context, arg CreateReportInstanceParams) (ReportInstance, error) {
	row := q.db.QueryRowContext(ctx, CreateReportInstance,
		arg.ReportTemplateID,
		arg.Name,
		arg.Description,
		arg.Parameters,
		arg.Schedule,
		arg.IsActive,
		arg.CreatedBy,
	)
	var i ReportInstance
	err := row.Scan(
		&i.ID,
		&i.ReportTemplateID,
		&i.Name,
		&i.Description,
		&i.Parameters,
		&i.Schedule,
		&i.LastRun,
		&i.NextRun,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const DeactivateReportInstance = `-- name: DeactivateReportInstance :exec
UPDATE report_instances SET is_active = FALSE, updated_at = NOW() WHERE id = $1
`

func (q *Queries) DeactivateReportInstance(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeactivateReportInstance, id)
	return err
}

const DeleteReportInstance = `-- name: DeleteReportInstance :exec
DELETE FROM report_instances WHERE id = $1
`

func (q *Queries) DeleteReportInstance(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteReportInstance, id)
	return err
}

const GetActiveReportInstances = `-- name: GetActiveReportInstances :many
SELECT id, report_template_id, name, description, parameters, schedule, last_run, next_run, is_active, created_by, created_at, updated_at FROM report_instances 
WHERE is_active = TRUE 
ORDER BY name
`

func (q *Queries) GetActiveReportInstances(ctx context.Context) ([]ReportInstance, error) {
	rows, err := q.db.QueryContext(ctx, GetActiveReportInstances)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReportInstance{}
	for rows.Next() {
		var i ReportInstance
		if err := rows.Scan(
			&i.ID,
			&i.ReportTemplateID,
			&i.Name,
			&i.Description,
			&i.Parameters,
			&i.Schedule,
			&i.LastRun,
			&i.NextRun,
			&i.IsActive,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetReportInstance = `-- name: GetReportInstance :one
SELECT id, report_template_id, name, description, parameters, schedule, last_run, next_run, is_active, created_by, created_at, updated_at FROM report_instances WHERE id = $1
`

func (q *Queries) GetReportInstance(ctx context.Context, id uuid.UUID) (ReportInstance, error) {
	row := q.db.QueryRowContext(ctx, GetReportInstance, id)
	var i ReportInstance
	err := row.Scan(
		&i.ID,
		&i.ReportTemplateID,
		&i.Name,
		&i.Description,
		&i.Parameters,
		&i.Schedule,
		&i.LastRun,
		&i.NextRun,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetReportInstanceByName = `-- name: GetReportInstanceByName :one
SELECT id, report_template_id, name, description, parameters, schedule, last_run, next_run, is_active, created_by, created_at, updated_at FROM report_instances WHERE name = $1
`

func (q *Queries) GetReportInstanceByName(ctx context.Context, name string) (ReportInstance, error) {
	row := q.db.QueryRowContext(ctx, GetReportInstanceByName, name)
	var i ReportInstance
	err := row.Scan(
		&i.ID,
		&i.ReportTemplateID,
		&i.Name,
		&i.Description,
		&i.Parameters,
		&i.Schedule,
		&i.LastRun,
		&i.NextRun,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetReportInstanceStats = `-- name: GetReportInstanceStats :many
SELECT 
    rt.report_type,
    COUNT(ri.id) as instance_count,
    COUNT(CASE WHEN ri.schedule IS NOT NULL THEN 1 END) as scheduled_count
FROM report_instances ri
JOIN report_templates rt ON ri.report_template_id = rt.id
WHERE ri.is_active = $1
GROUP BY rt.report_type
ORDER BY rt.report_type
`

type GetReportInstanceStatsRow struct {
	ReportType     string `json:"report_type"`
	InstanceCount  int64  `json:"instance_count"`
	ScheduledCount int64  `json:"scheduled_count"`
}

func (q *Queries) GetReportInstanceStats(ctx context.Context, isActive sql.NullBool) ([]GetReportInstanceStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetReportInstanceStats, isActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetReportInstanceStatsRow{}
	for rows.Next() {
		var i GetReportInstanceStatsRow
		if err := rows.Scan(&i.ReportType, &i.InstanceCount, &i.ScheduledCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetReportInstanceSummary = `-- name: GetReportInstanceSummary :many
SELECT 
    ri.name,
    ri.description,
    ri.schedule,
    ri.last_run,
    ri.next_run,
    rt.name as template_name,
    rt.report_type,
    c.first_name || ' ' || c.last_name as created_by_name
FROM report_instances ri
JOIN report_templates rt ON ri.report_template_id = rt.id
LEFT JOIN contacts c ON ri.created_by = c.id
WHERE ri.is_active = $1
ORDER BY ri.created_at DESC
`

type GetReportInstanceSummaryRow struct {
	Name          string         `json:"name"`
	Description   sql.NullString `json:"description"`
	Schedule      sql.NullString `json:"schedule"`
	LastRun       sql.NullTime   `json:"last_run"`
	NextRun       sql.NullTime   `json:"next_run"`
	TemplateName  string         `json:"template_name"`
	ReportType    string         `json:"report_type"`
	CreatedByName interface{}    `json:"created_by_name"`
}

func (q *Queries) GetReportInstanceSummary(ctx context.Context, isActive sql.NullBool) ([]GetReportInstanceSummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, GetReportInstanceSummary, isActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetReportInstanceSummaryRow{}
	for rows.Next() {
		var i GetReportInstanceSummaryRow
		if err := rows.Scan(
			&i.Name,
			&i.Description,
			&i.Schedule,
			&i.LastRun,
			&i.NextRun,
			&i.TemplateName,
			&i.ReportType,
			&i.CreatedByName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetReportInstancesByCreator = `-- name: GetReportInstancesByCreator :many
SELECT id, report_template_id, name, description, parameters, schedule, last_run, next_run, is_active, created_by, created_at, updated_at FROM report_instances 
WHERE created_by = $1 AND is_active = $2 
ORDER BY name
`

type GetReportInstancesByCreatorParams struct {
	CreatedBy uuid.NullUUID `json:"created_by"`
	IsActive  sql.NullBool  `json:"is_active"`
}

func (q *Queries) GetReportInstancesByCreator(ctx context.Context, arg GetReportInstancesByCreatorParams) ([]ReportInstance, error) {
	rows, err := q.db.QueryContext(ctx, GetReportInstancesByCreator, arg.CreatedBy, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReportInstance{}
	for rows.Next() {
		var i ReportInstance
		if err := rows.Scan(
			&i.ID,
			&i.ReportTemplateID,
			&i.Name,
			&i.Description,
			&i.Parameters,
			&i.Schedule,
			&i.LastRun,
			&i.NextRun,
			&i.IsActive,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetReportInstancesByTemplate = `-- name: GetReportInstancesByTemplate :many
SELECT id, report_template_id, name, description, parameters, schedule, last_run, next_run, is_active, created_by, created_at, updated_at FROM report_instances 
WHERE report_template_id = $1 AND is_active = $2 
ORDER BY name
`

type GetReportInstancesByTemplateParams struct {
	ReportTemplateID uuid.UUID    `json:"report_template_id"`
	IsActive         sql.NullBool `json:"is_active"`
}

func (q *Queries) GetReportInstancesByTemplate(ctx context.Context, arg GetReportInstancesByTemplateParams) ([]ReportInstance, error) {
	rows, err := q.db.QueryContext(ctx, GetReportInstancesByTemplate, arg.ReportTemplateID, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReportInstance{}
	for rows.Next() {
		var i ReportInstance
		if err := rows.Scan(
			&i.ID,
			&i.ReportTemplateID,
			&i.Name,
			&i.Description,
			&i.Parameters,
			&i.Schedule,
			&i.LastRun,
			&i.NextRun,
			&i.IsActive,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetScheduledReportInstances = `-- name: GetScheduledReportInstances :many
SELECT id, report_template_id, name, description, parameters, schedule, last_run, next_run, is_active, created_by, created_at, updated_at FROM report_instances 
WHERE schedule IS NOT NULL AND is_active = $1 
ORDER BY next_run
`

func (q *Queries) GetScheduledReportInstances(ctx context.Context, isActive sql.NullBool) ([]ReportInstance, error) {
	rows, err := q.db.QueryContext(ctx, GetScheduledReportInstances, isActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReportInstance{}
	for rows.Next() {
		var i ReportInstance
		if err := rows.Scan(
			&i.ID,
			&i.ReportTemplateID,
			&i.Name,
			&i.Description,
			&i.Parameters,
			&i.Schedule,
			&i.LastRun,
			&i.NextRun,
			&i.IsActive,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListReportInstances = `-- name: ListReportInstances :many
SELECT id, report_template_id, name, description, parameters, schedule, last_run, next_run, is_active, created_by, created_at, updated_at FROM report_instances 
ORDER BY name
`

func (q *Queries) ListReportInstances(ctx context.Context) ([]ReportInstance, error) {
	rows, err := q.db.QueryContext(ctx, ListReportInstances)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReportInstance{}
	for rows.Next() {
		var i ReportInstance
		if err := rows.Scan(
			&i.ID,
			&i.ReportTemplateID,
			&i.Name,
			&i.Description,
			&i.Parameters,
			&i.Schedule,
			&i.LastRun,
			&i.NextRun,
			&i.IsActive,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListReportInstancesByDateRange = `-- name: ListReportInstancesByDateRange :many
SELECT id, report_template_id, name, description, parameters, schedule, last_run, next_run, is_active, created_by, created_at, updated_at FROM report_instances 
WHERE created_at >= $1 AND created_at <= $2 
ORDER BY created_at DESC
`

type ListReportInstancesByDateRangeParams struct {
	CreatedAt   sql.NullTime `json:"created_at"`
	CreatedAt_2 sql.NullTime `json:"created_at_2"`
}

func (q *Queries) ListReportInstancesByDateRange(ctx context.Context, arg ListReportInstancesByDateRangeParams) ([]ReportInstance, error) {
	rows, err := q.db.QueryContext(ctx, ListReportInstancesByDateRange, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReportInstance{}
	for rows.Next() {
		var i ReportInstance
		if err := rows.Scan(
			&i.ID,
			&i.ReportTemplateID,
			&i.Name,
			&i.Description,
			&i.Parameters,
			&i.Schedule,
			&i.LastRun,
			&i.NextRun,
			&i.IsActive,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchReportInstances = `-- name: SearchReportInstances :many
SELECT id, report_template_id, name, description, parameters, schedule, last_run, next_run, is_active, created_by, created_at, updated_at FROM report_instances 
WHERE (name ILIKE $1 OR description ILIKE $1) AND is_active = $2 
ORDER BY name
`

type SearchReportInstancesParams struct {
	Name     string       `json:"name"`
	IsActive sql.NullBool `json:"is_active"`
}

func (q *Queries) SearchReportInstances(ctx context.Context, arg SearchReportInstancesParams) ([]ReportInstance, error) {
	rows, err := q.db.QueryContext(ctx, SearchReportInstances, arg.Name, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReportInstance{}
	for rows.Next() {
		var i ReportInstance
		if err := rows.Scan(
			&i.ID,
			&i.ReportTemplateID,
			&i.Name,
			&i.Description,
			&i.Parameters,
			&i.Schedule,
			&i.LastRun,
			&i.NextRun,
			&i.IsActive,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateReportInstance = `-- name: UpdateReportInstance :one
UPDATE report_instances SET
    report_template_id = $2, name = $3, description = $4, parameters = $5,
    schedule = $6, is_active = $7, updated_at = NOW()
WHERE id = $1 RETURNING id, report_template_id, name, description, parameters, schedule, last_run, next_run, is_active, created_by, created_at, updated_at
`

type UpdateReportInstanceParams struct {
	ID               uuid.UUID             `json:"id"`
	ReportTemplateID uuid.UUID             `json:"report_template_id"`
	Name             string                `json:"name"`
	Description      sql.NullString        `json:"description"`
	Parameters       pqtype.NullRawMessage `json:"parameters"`
	Schedule         sql.NullString        `json:"schedule"`
	IsActive         sql.NullBool          `json:"is_active"`
}

func (q *Queries) UpdateReportInstance(ctx context.Context, arg UpdateReportInstanceParams) (ReportInstance, error) {
	row := q.db.QueryRowContext(ctx, UpdateReportInstance,
		arg.ID,
		arg.ReportTemplateID,
		arg.Name,
		arg.Description,
		arg.Parameters,
		arg.Schedule,
		arg.IsActive,
	)
	var i ReportInstance
	err := row.Scan(
		&i.ID,
		&i.ReportTemplateID,
		&i.Name,
		&i.Description,
		&i.Parameters,
		&i.Schedule,
		&i.LastRun,
		&i.NextRun,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateReportInstanceLastRun = `-- name: UpdateReportInstanceLastRun :exec
UPDATE report_instances SET last_run = $2, updated_at = NOW() WHERE id = $1
`

type UpdateReportInstanceLastRunParams struct {
	ID      uuid.UUID    `json:"id"`
	LastRun sql.NullTime `json:"last_run"`
}

func (q *Queries) UpdateReportInstanceLastRun(ctx context.Context, arg UpdateReportInstanceLastRunParams) error {
	_, err := q.db.ExecContext(ctx, UpdateReportInstanceLastRun, arg.ID, arg.LastRun)
	return err
}

const UpdateReportInstanceNextRun = `-- name: UpdateReportInstanceNextRun :exec
UPDATE report_instances SET next_run = $2, updated_at = NOW() WHERE id = $1
`

type UpdateReportInstanceNextRunParams struct {
	ID      uuid.UUID    `json:"id"`
	NextRun sql.NullTime `json:"next_run"`
}

func (q *Queries) UpdateReportInstanceNextRun(ctx context.Context, arg UpdateReportInstanceNextRunParams) error {
	_, err := q.db.ExecContext(ctx, UpdateReportInstanceNextRun, arg.ID, arg.NextRun)
	return err
}

const UpdateReportInstanceSchedule = `-- name: UpdateReportInstanceSchedule :exec
UPDATE report_instances SET schedule = $2, updated_at = NOW() WHERE id = $1
`

type UpdateReportInstanceScheduleParams struct {
	ID       uuid.UUID      `json:"id"`
	Schedule sql.NullString `json:"schedule"`
}

func (q *Queries) UpdateReportInstanceSchedule(ctx context.Context, arg UpdateReportInstanceScheduleParams) error {
	_, err := q.db.ExecContext(ctx, UpdateReportInstanceSchedule, arg.ID, arg.Schedule)
	return err
}
