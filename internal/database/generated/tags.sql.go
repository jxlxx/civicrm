// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tags.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const ActivateTag = `-- name: ActivateTag :exec
UPDATE tags SET is_active = TRUE, updated_at = NOW() WHERE id = $1
`

func (q *Queries) ActivateTag(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, ActivateTag, id)
	return err
}

const CreateTag = `-- name: CreateTag :one
INSERT INTO tags (
    tag_set_id, name, description, color, icon, is_active, is_reserved, weight
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, tag_set_id, name, description, color, icon, is_active, is_reserved, weight, created_at, updated_at
`

type CreateTagParams struct {
	TagSetID    uuid.NullUUID  `json:"tag_set_id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	Color       sql.NullString `json:"color"`
	Icon        sql.NullString `json:"icon"`
	IsActive    sql.NullBool   `json:"is_active"`
	IsReserved  sql.NullBool   `json:"is_reserved"`
	Weight      sql.NullInt32  `json:"weight"`
}

func (q *Queries) CreateTag(ctx context.Context, arg CreateTagParams) (Tag, error) {
	row := q.db.QueryRowContext(ctx, CreateTag,
		arg.TagSetID,
		arg.Name,
		arg.Description,
		arg.Color,
		arg.Icon,
		arg.IsActive,
		arg.IsReserved,
		arg.Weight,
	)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.TagSetID,
		&i.Name,
		&i.Description,
		&i.Color,
		&i.Icon,
		&i.IsActive,
		&i.IsReserved,
		&i.Weight,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const DeactivateTag = `-- name: DeactivateTag :exec
UPDATE tags SET is_active = FALSE, updated_at = NOW() WHERE id = $1
`

func (q *Queries) DeactivateTag(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeactivateTag, id)
	return err
}

const DeleteTag = `-- name: DeleteTag :exec
DELETE FROM tags WHERE id = $1
`

func (q *Queries) DeleteTag(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteTag, id)
	return err
}

const GetTag = `-- name: GetTag :one
SELECT id, tag_set_id, name, description, color, icon, is_active, is_reserved, weight, created_at, updated_at FROM tags WHERE id = $1
`

func (q *Queries) GetTag(ctx context.Context, id uuid.UUID) (Tag, error) {
	row := q.db.QueryRowContext(ctx, GetTag, id)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.TagSetID,
		&i.Name,
		&i.Description,
		&i.Color,
		&i.Icon,
		&i.IsActive,
		&i.IsReserved,
		&i.Weight,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetTagByName = `-- name: GetTagByName :one
SELECT id, tag_set_id, name, description, color, icon, is_active, is_reserved, weight, created_at, updated_at FROM tags WHERE name = $1
`

func (q *Queries) GetTagByName(ctx context.Context, name string) (Tag, error) {
	row := q.db.QueryRowContext(ctx, GetTagByName, name)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.TagSetID,
		&i.Name,
		&i.Description,
		&i.Color,
		&i.Icon,
		&i.IsActive,
		&i.IsReserved,
		&i.Weight,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetTagStats = `-- name: GetTagStats :many
SELECT 
    t.name as tag_name,
    ts.name as tag_set_name,
    ts.entity_table,
    COUNT(et.id) as usage_count
FROM tags t
JOIN tag_sets ts ON t.tag_set_id = ts.id
LEFT JOIN entity_tags et ON t.id = et.tag_id
WHERE t.is_active = $1
GROUP BY t.name, ts.name, ts.entity_table, t.weight, ts.weight
ORDER BY ts.weight, ts.name, t.weight, t.name
`

type GetTagStatsRow struct {
	TagName     string `json:"tag_name"`
	TagSetName  string `json:"tag_set_name"`
	EntityTable string `json:"entity_table"`
	UsageCount  int64  `json:"usage_count"`
}

func (q *Queries) GetTagStats(ctx context.Context, isActive sql.NullBool) ([]GetTagStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetTagStats, isActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTagStatsRow{}
	for rows.Next() {
		var i GetTagStatsRow
		if err := rows.Scan(
			&i.TagName,
			&i.TagSetName,
			&i.EntityTable,
			&i.UsageCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetTagsByEntityTable = `-- name: GetTagsByEntityTable :many
SELECT t.id, t.tag_set_id, t.name, t.description, t.color, t.icon, t.is_active, t.is_reserved, t.weight, t.created_at, t.updated_at FROM tags t
JOIN tag_sets ts ON t.tag_set_id = ts.id
WHERE ts.entity_table = $1 AND t.is_active = $2 
ORDER BY t.weight, t.name
`

type GetTagsByEntityTableParams struct {
	EntityTable string       `json:"entity_table"`
	IsActive    sql.NullBool `json:"is_active"`
}

func (q *Queries) GetTagsByEntityTable(ctx context.Context, arg GetTagsByEntityTableParams) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, GetTagsByEntityTable, arg.EntityTable, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.TagSetID,
			&i.Name,
			&i.Description,
			&i.Color,
			&i.Icon,
			&i.IsActive,
			&i.IsReserved,
			&i.Weight,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetTagsByTagSet = `-- name: GetTagsByTagSet :many
SELECT id, tag_set_id, name, description, color, icon, is_active, is_reserved, weight, created_at, updated_at FROM tags 
WHERE tag_set_id = $1 AND is_active = $2 
ORDER BY weight, name
`

type GetTagsByTagSetParams struct {
	TagSetID uuid.NullUUID `json:"tag_set_id"`
	IsActive sql.NullBool  `json:"is_active"`
}

func (q *Queries) GetTagsByTagSet(ctx context.Context, arg GetTagsByTagSetParams) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, GetTagsByTagSet, arg.TagSetID, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.TagSetID,
			&i.Name,
			&i.Description,
			&i.Color,
			&i.Icon,
			&i.IsActive,
			&i.IsReserved,
			&i.Weight,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListActiveTags = `-- name: ListActiveTags :many
SELECT id, tag_set_id, name, description, color, icon, is_active, is_reserved, weight, created_at, updated_at FROM tags 
WHERE is_active = TRUE 
ORDER BY weight, name
`

func (q *Queries) ListActiveTags(ctx context.Context) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, ListActiveTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.TagSetID,
			&i.Name,
			&i.Description,
			&i.Color,
			&i.Icon,
			&i.IsActive,
			&i.IsReserved,
			&i.Weight,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListReservedTags = `-- name: ListReservedTags :many
SELECT id, tag_set_id, name, description, color, icon, is_active, is_reserved, weight, created_at, updated_at FROM tags 
WHERE is_reserved = TRUE AND is_active = $1 
ORDER BY weight, name
`

func (q *Queries) ListReservedTags(ctx context.Context, isActive sql.NullBool) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, ListReservedTags, isActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.TagSetID,
			&i.Name,
			&i.Description,
			&i.Color,
			&i.Icon,
			&i.IsActive,
			&i.IsReserved,
			&i.Weight,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListTags = `-- name: ListTags :many
SELECT id, tag_set_id, name, description, color, icon, is_active, is_reserved, weight, created_at, updated_at FROM tags 
WHERE is_active = $1 
ORDER BY weight, name
`

func (q *Queries) ListTags(ctx context.Context, isActive sql.NullBool) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, ListTags, isActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.TagSetID,
			&i.Name,
			&i.Description,
			&i.Color,
			&i.Icon,
			&i.IsActive,
			&i.IsReserved,
			&i.Weight,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListTagsByColor = `-- name: ListTagsByColor :many
SELECT id, tag_set_id, name, description, color, icon, is_active, is_reserved, weight, created_at, updated_at FROM tags 
WHERE color = $1 AND is_active = $2 
ORDER BY weight, name
`

type ListTagsByColorParams struct {
	Color    sql.NullString `json:"color"`
	IsActive sql.NullBool   `json:"is_active"`
}

func (q *Queries) ListTagsByColor(ctx context.Context, arg ListTagsByColorParams) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, ListTagsByColor, arg.Color, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.TagSetID,
			&i.Name,
			&i.Description,
			&i.Color,
			&i.Icon,
			&i.IsActive,
			&i.IsReserved,
			&i.Weight,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchTags = `-- name: SearchTags :many
SELECT id, tag_set_id, name, description, color, icon, is_active, is_reserved, weight, created_at, updated_at FROM tags 
WHERE (name ILIKE $1 OR description ILIKE $1) 
AND is_active = $2 
ORDER BY weight, name
`

type SearchTagsParams struct {
	Name     string       `json:"name"`
	IsActive sql.NullBool `json:"is_active"`
}

func (q *Queries) SearchTags(ctx context.Context, arg SearchTagsParams) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, SearchTags, arg.Name, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.TagSetID,
			&i.Name,
			&i.Description,
			&i.Color,
			&i.Icon,
			&i.IsActive,
			&i.IsReserved,
			&i.Weight,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateTag = `-- name: UpdateTag :one
UPDATE tags SET
    tag_set_id = $2, name = $3, description = $4, color = $5,
    icon = $6, is_active = $7, is_reserved = $8, weight = $9, updated_at = NOW()
WHERE id = $1 RETURNING id, tag_set_id, name, description, color, icon, is_active, is_reserved, weight, created_at, updated_at
`

type UpdateTagParams struct {
	ID          uuid.UUID      `json:"id"`
	TagSetID    uuid.NullUUID  `json:"tag_set_id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	Color       sql.NullString `json:"color"`
	Icon        sql.NullString `json:"icon"`
	IsActive    sql.NullBool   `json:"is_active"`
	IsReserved  sql.NullBool   `json:"is_reserved"`
	Weight      sql.NullInt32  `json:"weight"`
}

func (q *Queries) UpdateTag(ctx context.Context, arg UpdateTagParams) (Tag, error) {
	row := q.db.QueryRowContext(ctx, UpdateTag,
		arg.ID,
		arg.TagSetID,
		arg.Name,
		arg.Description,
		arg.Color,
		arg.Icon,
		arg.IsActive,
		arg.IsReserved,
		arg.Weight,
	)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.TagSetID,
		&i.Name,
		&i.Description,
		&i.Color,
		&i.Icon,
		&i.IsActive,
		&i.IsReserved,
		&i.Weight,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateTagColor = `-- name: UpdateTagColor :exec
UPDATE tags SET color = $2, updated_at = NOW() WHERE id = $1
`

type UpdateTagColorParams struct {
	ID    uuid.UUID      `json:"id"`
	Color sql.NullString `json:"color"`
}

func (q *Queries) UpdateTagColor(ctx context.Context, arg UpdateTagColorParams) error {
	_, err := q.db.ExecContext(ctx, UpdateTagColor, arg.ID, arg.Color)
	return err
}

const UpdateTagWeight = `-- name: UpdateTagWeight :exec
UPDATE tags SET weight = $2, updated_at = NOW() WHERE id = $1
`

type UpdateTagWeightParams struct {
	ID     uuid.UUID     `json:"id"`
	Weight sql.NullInt32 `json:"weight"`
}

func (q *Queries) UpdateTagWeight(ctx context.Context, arg UpdateTagWeightParams) error {
	_, err := q.db.ExecContext(ctx, UpdateTagWeight, arg.ID, arg.Weight)
	return err
}
