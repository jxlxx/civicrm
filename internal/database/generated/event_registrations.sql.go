// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: event_registrations.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const CountRegistrations = `-- name: CountRegistrations :one
SELECT COUNT(*) FROM event_registrations
`

func (q *Queries) CountRegistrations(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountRegistrations)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountRegistrationsByContact = `-- name: CountRegistrationsByContact :one
SELECT COUNT(*) FROM event_registrations WHERE contact_id = $1
`

func (q *Queries) CountRegistrationsByContact(ctx context.Context, contactID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountRegistrationsByContact, contactID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountRegistrationsByEvent = `-- name: CountRegistrationsByEvent :one
SELECT COUNT(*) FROM event_registrations WHERE event_id = $1
`

func (q *Queries) CountRegistrationsByEvent(ctx context.Context, eventID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountRegistrationsByEvent, eventID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountRegistrationsByStatus = `-- name: CountRegistrationsByStatus :one
SELECT COUNT(*) FROM event_registrations WHERE status = $1
`

func (q *Queries) CountRegistrationsByStatus(ctx context.Context, status sql.NullString) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountRegistrationsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateEventRegistration = `-- name: CreateEventRegistration :one
INSERT INTO event_registrations (
    event_id, contact_id, status
) VALUES (
    $1, $2, $3
) RETURNING id, event_id, contact_id, registration_date, status, created_at, updated_at
`

type CreateEventRegistrationParams struct {
	EventID   uuid.UUID      `json:"event_id"`
	ContactID uuid.UUID      `json:"contact_id"`
	Status    sql.NullString `json:"status"`
}

func (q *Queries) CreateEventRegistration(ctx context.Context, arg CreateEventRegistrationParams) (EventRegistration, error) {
	row := q.db.QueryRowContext(ctx, CreateEventRegistration, arg.EventID, arg.ContactID, arg.Status)
	var i EventRegistration
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.ContactID,
		&i.RegistrationDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const DeleteEventRegistration = `-- name: DeleteEventRegistration :exec
DELETE FROM event_registrations WHERE id = $1
`

func (q *Queries) DeleteEventRegistration(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteEventRegistration, id)
	return err
}

const GetEventRegistration = `-- name: GetEventRegistration :one
SELECT id, event_id, contact_id, registration_date, status, created_at, updated_at FROM event_registrations WHERE id = $1
`

func (q *Queries) GetEventRegistration(ctx context.Context, id uuid.UUID) (EventRegistration, error) {
	row := q.db.QueryRowContext(ctx, GetEventRegistration, id)
	var i EventRegistration
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.ContactID,
		&i.RegistrationDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetEventRegistrationByEventAndContact = `-- name: GetEventRegistrationByEventAndContact :one
SELECT id, event_id, contact_id, registration_date, status, created_at, updated_at FROM event_registrations 
WHERE event_id = $1 AND contact_id = $2
`

type GetEventRegistrationByEventAndContactParams struct {
	EventID   uuid.UUID `json:"event_id"`
	ContactID uuid.UUID `json:"contact_id"`
}

func (q *Queries) GetEventRegistrationByEventAndContact(ctx context.Context, arg GetEventRegistrationByEventAndContactParams) (EventRegistration, error) {
	row := q.db.QueryRowContext(ctx, GetEventRegistrationByEventAndContact, arg.EventID, arg.ContactID)
	var i EventRegistration
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.ContactID,
		&i.RegistrationDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetPastRegistrations = `-- name: GetPastRegistrations :many
SELECT 
    er.id, er.event_id, er.contact_id, er.registration_date, er.status, er.created_at, er.updated_at,
    e.title as event_title,
    e.start_date as event_start_date,
    e.location as event_location,
    c.contact_type,
    c.first_name,
    c.last_name,
    c.organization_name,
    c.email
FROM event_registrations er
JOIN events e ON er.event_id = e.id
JOIN contacts c ON er.contact_id = c.id
WHERE e.end_date < NOW()
ORDER BY e.start_date DESC
`

type GetPastRegistrationsRow struct {
	ID               uuid.UUID      `json:"id"`
	EventID          uuid.UUID      `json:"event_id"`
	ContactID        uuid.UUID      `json:"contact_id"`
	RegistrationDate sql.NullTime   `json:"registration_date"`
	Status           sql.NullString `json:"status"`
	CreatedAt        sql.NullTime   `json:"created_at"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
	EventTitle       string         `json:"event_title"`
	EventStartDate   time.Time      `json:"event_start_date"`
	EventLocation    sql.NullString `json:"event_location"`
	ContactType      string         `json:"contact_type"`
	FirstName        sql.NullString `json:"first_name"`
	LastName         sql.NullString `json:"last_name"`
	OrganizationName sql.NullString `json:"organization_name"`
	Email            sql.NullString `json:"email"`
}

func (q *Queries) GetPastRegistrations(ctx context.Context) ([]GetPastRegistrationsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetPastRegistrations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPastRegistrationsRow{}
	for rows.Next() {
		var i GetPastRegistrationsRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.ContactID,
			&i.RegistrationDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EventTitle,
			&i.EventStartDate,
			&i.EventLocation,
			&i.ContactType,
			&i.FirstName,
			&i.LastName,
			&i.OrganizationName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetRegistrationsByContact = `-- name: GetRegistrationsByContact :many
SELECT 
    er.id, er.event_id, er.contact_id, er.registration_date, er.status, er.created_at, er.updated_at,
    e.title as event_title,
    e.start_date as event_start_date,
    e.location as event_location
FROM event_registrations er
JOIN events e ON er.event_id = e.id
WHERE er.contact_id = $1
ORDER BY e.start_date DESC
`

type GetRegistrationsByContactRow struct {
	ID               uuid.UUID      `json:"id"`
	EventID          uuid.UUID      `json:"event_id"`
	ContactID        uuid.UUID      `json:"contact_id"`
	RegistrationDate sql.NullTime   `json:"registration_date"`
	Status           sql.NullString `json:"status"`
	CreatedAt        sql.NullTime   `json:"created_at"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
	EventTitle       string         `json:"event_title"`
	EventStartDate   time.Time      `json:"event_start_date"`
	EventLocation    sql.NullString `json:"event_location"`
}

func (q *Queries) GetRegistrationsByContact(ctx context.Context, contactID uuid.UUID) ([]GetRegistrationsByContactRow, error) {
	rows, err := q.db.QueryContext(ctx, GetRegistrationsByContact, contactID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRegistrationsByContactRow{}
	for rows.Next() {
		var i GetRegistrationsByContactRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.ContactID,
			&i.RegistrationDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EventTitle,
			&i.EventStartDate,
			&i.EventLocation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetRegistrationsByEvent = `-- name: GetRegistrationsByEvent :many
SELECT 
    er.id, er.event_id, er.contact_id, er.registration_date, er.status, er.created_at, er.updated_at,
    e.title as event_title,
    e.start_date as event_start_date,
    e.location as event_location,
    c.contact_type,
    c.first_name,
    c.last_name,
    c.organization_name,
    c.email
FROM event_registrations er
JOIN events e ON er.event_id = e.id
JOIN contacts c ON er.contact_id = c.id
WHERE er.event_id = $1
ORDER BY er.registration_date ASC
`

type GetRegistrationsByEventRow struct {
	ID               uuid.UUID      `json:"id"`
	EventID          uuid.UUID      `json:"event_id"`
	ContactID        uuid.UUID      `json:"contact_id"`
	RegistrationDate sql.NullTime   `json:"registration_date"`
	Status           sql.NullString `json:"status"`
	CreatedAt        sql.NullTime   `json:"created_at"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
	EventTitle       string         `json:"event_title"`
	EventStartDate   time.Time      `json:"event_start_date"`
	EventLocation    sql.NullString `json:"event_location"`
	ContactType      string         `json:"contact_type"`
	FirstName        sql.NullString `json:"first_name"`
	LastName         sql.NullString `json:"last_name"`
	OrganizationName sql.NullString `json:"organization_name"`
	Email            sql.NullString `json:"email"`
}

func (q *Queries) GetRegistrationsByEvent(ctx context.Context, eventID uuid.UUID) ([]GetRegistrationsByEventRow, error) {
	rows, err := q.db.QueryContext(ctx, GetRegistrationsByEvent, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRegistrationsByEventRow{}
	for rows.Next() {
		var i GetRegistrationsByEventRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.ContactID,
			&i.RegistrationDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EventTitle,
			&i.EventStartDate,
			&i.EventLocation,
			&i.ContactType,
			&i.FirstName,
			&i.LastName,
			&i.OrganizationName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUpcomingRegistrations = `-- name: GetUpcomingRegistrations :many
SELECT 
    er.id, er.event_id, er.contact_id, er.registration_date, er.status, er.created_at, er.updated_at,
    e.title as event_title,
    e.start_date as event_start_date,
    e.location as event_location,
    c.contact_type,
    c.first_name,
    c.last_name,
    c.organization_name,
    c.email
FROM event_registrations er
JOIN events e ON er.event_id = e.id
JOIN contacts c ON er.contact_id = c.id
WHERE e.start_date > NOW()
ORDER BY e.start_date ASC
`

type GetUpcomingRegistrationsRow struct {
	ID               uuid.UUID      `json:"id"`
	EventID          uuid.UUID      `json:"event_id"`
	ContactID        uuid.UUID      `json:"contact_id"`
	RegistrationDate sql.NullTime   `json:"registration_date"`
	Status           sql.NullString `json:"status"`
	CreatedAt        sql.NullTime   `json:"created_at"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
	EventTitle       string         `json:"event_title"`
	EventStartDate   time.Time      `json:"event_start_date"`
	EventLocation    sql.NullString `json:"event_location"`
	ContactType      string         `json:"contact_type"`
	FirstName        sql.NullString `json:"first_name"`
	LastName         sql.NullString `json:"last_name"`
	OrganizationName sql.NullString `json:"organization_name"`
	Email            sql.NullString `json:"email"`
}

func (q *Queries) GetUpcomingRegistrations(ctx context.Context) ([]GetUpcomingRegistrationsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetUpcomingRegistrations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUpcomingRegistrationsRow{}
	for rows.Next() {
		var i GetUpcomingRegistrationsRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.ContactID,
			&i.RegistrationDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EventTitle,
			&i.EventStartDate,
			&i.EventLocation,
			&i.ContactType,
			&i.FirstName,
			&i.LastName,
			&i.OrganizationName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListAllRegistrations = `-- name: ListAllRegistrations :many
SELECT 
    er.id, er.event_id, er.contact_id, er.registration_date, er.status, er.created_at, er.updated_at,
    e.title as event_title,
    e.start_date as event_start_date,
    e.location as event_location,
    c.contact_type,
    c.first_name,
    c.last_name,
    c.organization_name,
    c.email
FROM event_registrations er
JOIN events e ON er.event_id = e.id
JOIN contacts c ON er.contact_id = c.id
ORDER BY er.registration_date DESC 
LIMIT $1 OFFSET $2
`

type ListAllRegistrationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListAllRegistrationsRow struct {
	ID               uuid.UUID      `json:"id"`
	EventID          uuid.UUID      `json:"event_id"`
	ContactID        uuid.UUID      `json:"contact_id"`
	RegistrationDate sql.NullTime   `json:"registration_date"`
	Status           sql.NullString `json:"status"`
	CreatedAt        sql.NullTime   `json:"created_at"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
	EventTitle       string         `json:"event_title"`
	EventStartDate   time.Time      `json:"event_start_date"`
	EventLocation    sql.NullString `json:"event_location"`
	ContactType      string         `json:"contact_type"`
	FirstName        sql.NullString `json:"first_name"`
	LastName         sql.NullString `json:"last_name"`
	OrganizationName sql.NullString `json:"organization_name"`
	Email            sql.NullString `json:"email"`
}

func (q *Queries) ListAllRegistrations(ctx context.Context, arg ListAllRegistrationsParams) ([]ListAllRegistrationsRow, error) {
	rows, err := q.db.QueryContext(ctx, ListAllRegistrations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllRegistrationsRow{}
	for rows.Next() {
		var i ListAllRegistrationsRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.ContactID,
			&i.RegistrationDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EventTitle,
			&i.EventStartDate,
			&i.EventLocation,
			&i.ContactType,
			&i.FirstName,
			&i.LastName,
			&i.OrganizationName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListRegistrationsByStatus = `-- name: ListRegistrationsByStatus :many
SELECT 
    er.id, er.event_id, er.contact_id, er.registration_date, er.status, er.created_at, er.updated_at,
    e.title as event_title,
    e.start_date as event_start_date,
    e.location as event_location,
    c.contact_type,
    c.first_name,
    c.last_name,
    c.organization_name,
    c.email
FROM event_registrations er
JOIN events e ON er.event_id = e.id
JOIN contacts c ON er.contact_id = c.id
WHERE er.status = $1
ORDER BY er.registration_date DESC 
LIMIT $2 OFFSET $3
`

type ListRegistrationsByStatusParams struct {
	Status sql.NullString `json:"status"`
	Limit  int32          `json:"limit"`
	Offset int32          `json:"offset"`
}

type ListRegistrationsByStatusRow struct {
	ID               uuid.UUID      `json:"id"`
	EventID          uuid.UUID      `json:"event_id"`
	ContactID        uuid.UUID      `json:"contact_id"`
	RegistrationDate sql.NullTime   `json:"registration_date"`
	Status           sql.NullString `json:"status"`
	CreatedAt        sql.NullTime   `json:"created_at"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
	EventTitle       string         `json:"event_title"`
	EventStartDate   time.Time      `json:"event_start_date"`
	EventLocation    sql.NullString `json:"event_location"`
	ContactType      string         `json:"contact_type"`
	FirstName        sql.NullString `json:"first_name"`
	LastName         sql.NullString `json:"last_name"`
	OrganizationName sql.NullString `json:"organization_name"`
	Email            sql.NullString `json:"email"`
}

func (q *Queries) ListRegistrationsByStatus(ctx context.Context, arg ListRegistrationsByStatusParams) ([]ListRegistrationsByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, ListRegistrationsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRegistrationsByStatusRow{}
	for rows.Next() {
		var i ListRegistrationsByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.ContactID,
			&i.RegistrationDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EventTitle,
			&i.EventStartDate,
			&i.EventLocation,
			&i.ContactType,
			&i.FirstName,
			&i.LastName,
			&i.OrganizationName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateEventRegistration = `-- name: UpdateEventRegistration :one
UPDATE event_registrations 
SET 
    status = $2,
    updated_at = NOW()
WHERE id = $1 
RETURNING id, event_id, contact_id, registration_date, status, created_at, updated_at
`

type UpdateEventRegistrationParams struct {
	ID     uuid.UUID      `json:"id"`
	Status sql.NullString `json:"status"`
}

func (q *Queries) UpdateEventRegistration(ctx context.Context, arg UpdateEventRegistrationParams) (EventRegistration, error) {
	row := q.db.QueryRowContext(ctx, UpdateEventRegistration, arg.ID, arg.Status)
	var i EventRegistration
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.ContactID,
		&i.RegistrationDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
