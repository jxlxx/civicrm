// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: line_items.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const CountLineItems = `-- name: CountLineItems :one
SELECT COUNT(*) FROM line_items
`

func (q *Queries) CountLineItems(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountLineItems)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountLineItemsByEntity = `-- name: CountLineItemsByEntity :one
SELECT COUNT(*) FROM line_items 
WHERE entity_table = $1 AND entity_id = $2
`

type CountLineItemsByEntityParams struct {
	EntityTable string    `json:"entity_table"`
	EntityID    uuid.UUID `json:"entity_id"`
}

func (q *Queries) CountLineItemsByEntity(ctx context.Context, arg CountLineItemsByEntityParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountLineItemsByEntity, arg.EntityTable, arg.EntityID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountLineItemsByFinancialType = `-- name: CountLineItemsByFinancialType :one
SELECT COUNT(*) FROM line_items WHERE financial_type_id = $1
`

func (q *Queries) CountLineItemsByFinancialType(ctx context.Context, financialTypeID uuid.NullUUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountLineItemsByFinancialType, financialTypeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateLineItem = `-- name: CreateLineItem :one
INSERT INTO line_items (
    entity_table, entity_id, price_field_id, price_field_value_id,
    label, qty, unit_price, line_total, financial_type_id,
    non_deductible_amount, tax_amount
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, entity_table, entity_id, price_field_id, price_field_value_id, label, qty, unit_price, line_total, financial_type_id, non_deductible_amount, tax_amount, created_at, updated_at
`

type CreateLineItemParams struct {
	EntityTable         string         `json:"entity_table"`
	EntityID            uuid.UUID      `json:"entity_id"`
	PriceFieldID        uuid.NullUUID  `json:"price_field_id"`
	PriceFieldValueID   uuid.NullUUID  `json:"price_field_value_id"`
	Label               string         `json:"label"`
	Qty                 int32          `json:"qty"`
	UnitPrice           string         `json:"unit_price"`
	LineTotal           string         `json:"line_total"`
	FinancialTypeID     uuid.NullUUID  `json:"financial_type_id"`
	NonDeductibleAmount sql.NullString `json:"non_deductible_amount"`
	TaxAmount           sql.NullString `json:"tax_amount"`
}

func (q *Queries) CreateLineItem(ctx context.Context, arg CreateLineItemParams) (LineItem, error) {
	row := q.db.QueryRowContext(ctx, CreateLineItem,
		arg.EntityTable,
		arg.EntityID,
		arg.PriceFieldID,
		arg.PriceFieldValueID,
		arg.Label,
		arg.Qty,
		arg.UnitPrice,
		arg.LineTotal,
		arg.FinancialTypeID,
		arg.NonDeductibleAmount,
		arg.TaxAmount,
	)
	var i LineItem
	err := row.Scan(
		&i.ID,
		&i.EntityTable,
		&i.EntityID,
		&i.PriceFieldID,
		&i.PriceFieldValueID,
		&i.Label,
		&i.Qty,
		&i.UnitPrice,
		&i.LineTotal,
		&i.FinancialTypeID,
		&i.NonDeductibleAmount,
		&i.TaxAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const DeleteLineItem = `-- name: DeleteLineItem :exec
DELETE FROM line_items WHERE id = $1
`

func (q *Queries) DeleteLineItem(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteLineItem, id)
	return err
}

const DeleteLineItemsByEntity = `-- name: DeleteLineItemsByEntity :exec
DELETE FROM line_items WHERE entity_table = $1 AND entity_id = $2
`

type DeleteLineItemsByEntityParams struct {
	EntityTable string    `json:"entity_table"`
	EntityID    uuid.UUID `json:"entity_id"`
}

func (q *Queries) DeleteLineItemsByEntity(ctx context.Context, arg DeleteLineItemsByEntityParams) error {
	_, err := q.db.ExecContext(ctx, DeleteLineItemsByEntity, arg.EntityTable, arg.EntityID)
	return err
}

const GetLineItem = `-- name: GetLineItem :one
SELECT id, entity_table, entity_id, price_field_id, price_field_value_id, label, qty, unit_price, line_total, financial_type_id, non_deductible_amount, tax_amount, created_at, updated_at FROM line_items WHERE id = $1
`

func (q *Queries) GetLineItem(ctx context.Context, id uuid.UUID) (LineItem, error) {
	row := q.db.QueryRowContext(ctx, GetLineItem, id)
	var i LineItem
	err := row.Scan(
		&i.ID,
		&i.EntityTable,
		&i.EntityID,
		&i.PriceFieldID,
		&i.PriceFieldValueID,
		&i.Label,
		&i.Qty,
		&i.UnitPrice,
		&i.LineTotal,
		&i.FinancialTypeID,
		&i.NonDeductibleAmount,
		&i.TaxAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetLineItemsByEntity = `-- name: GetLineItemsByEntity :many
SELECT id, entity_table, entity_id, price_field_id, price_field_value_id, label, qty, unit_price, line_total, financial_type_id, non_deductible_amount, tax_amount, created_at, updated_at FROM line_items 
WHERE entity_table = $1 AND entity_id = $2
ORDER BY id
`

type GetLineItemsByEntityParams struct {
	EntityTable string    `json:"entity_table"`
	EntityID    uuid.UUID `json:"entity_id"`
}

func (q *Queries) GetLineItemsByEntity(ctx context.Context, arg GetLineItemsByEntityParams) ([]LineItem, error) {
	rows, err := q.db.QueryContext(ctx, GetLineItemsByEntity, arg.EntityTable, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LineItem{}
	for rows.Next() {
		var i LineItem
		if err := rows.Scan(
			&i.ID,
			&i.EntityTable,
			&i.EntityID,
			&i.PriceFieldID,
			&i.PriceFieldValueID,
			&i.Label,
			&i.Qty,
			&i.UnitPrice,
			&i.LineTotal,
			&i.FinancialTypeID,
			&i.NonDeductibleAmount,
			&i.TaxAmount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetLineItemsByFinancialType = `-- name: GetLineItemsByFinancialType :many
SELECT id, entity_table, entity_id, price_field_id, price_field_value_id, label, qty, unit_price, line_total, financial_type_id, non_deductible_amount, tax_amount, created_at, updated_at FROM line_items 
WHERE financial_type_id = $1
ORDER BY id
`

func (q *Queries) GetLineItemsByFinancialType(ctx context.Context, financialTypeID uuid.NullUUID) ([]LineItem, error) {
	rows, err := q.db.QueryContext(ctx, GetLineItemsByFinancialType, financialTypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LineItem{}
	for rows.Next() {
		var i LineItem
		if err := rows.Scan(
			&i.ID,
			&i.EntityTable,
			&i.EntityID,
			&i.PriceFieldID,
			&i.PriceFieldValueID,
			&i.Label,
			&i.Qty,
			&i.UnitPrice,
			&i.LineTotal,
			&i.FinancialTypeID,
			&i.NonDeductibleAmount,
			&i.TaxAmount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetLineItemsByPriceField = `-- name: GetLineItemsByPriceField :many
SELECT id, entity_table, entity_id, price_field_id, price_field_value_id, label, qty, unit_price, line_total, financial_type_id, non_deductible_amount, tax_amount, created_at, updated_at FROM line_items 
WHERE price_field_id = $1
ORDER BY id
`

func (q *Queries) GetLineItemsByPriceField(ctx context.Context, priceFieldID uuid.NullUUID) ([]LineItem, error) {
	rows, err := q.db.QueryContext(ctx, GetLineItemsByPriceField, priceFieldID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LineItem{}
	for rows.Next() {
		var i LineItem
		if err := rows.Scan(
			&i.ID,
			&i.EntityTable,
			&i.EntityID,
			&i.PriceFieldID,
			&i.PriceFieldValueID,
			&i.Label,
			&i.Qty,
			&i.UnitPrice,
			&i.LineTotal,
			&i.FinancialTypeID,
			&i.NonDeductibleAmount,
			&i.TaxAmount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetTotalLineItemsByEntity = `-- name: GetTotalLineItemsByEntity :one
SELECT COALESCE(SUM(line_total), 0) as total FROM line_items 
WHERE entity_table = $1 AND entity_id = $2
`

type GetTotalLineItemsByEntityParams struct {
	EntityTable string    `json:"entity_table"`
	EntityID    uuid.UUID `json:"entity_id"`
}

func (q *Queries) GetTotalLineItemsByEntity(ctx context.Context, arg GetTotalLineItemsByEntityParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, GetTotalLineItemsByEntity, arg.EntityTable, arg.EntityID)
	var total interface{}
	err := row.Scan(&total)
	return total, err
}

const ListAllLineItems = `-- name: ListAllLineItems :many
SELECT id, entity_table, entity_id, price_field_id, price_field_value_id, label, qty, unit_price, line_total, financial_type_id, non_deductible_amount, tax_amount, created_at, updated_at FROM line_items 
ORDER BY entity_table, entity_id, id
`

func (q *Queries) ListAllLineItems(ctx context.Context) ([]LineItem, error) {
	rows, err := q.db.QueryContext(ctx, ListAllLineItems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LineItem{}
	for rows.Next() {
		var i LineItem
		if err := rows.Scan(
			&i.ID,
			&i.EntityTable,
			&i.EntityID,
			&i.PriceFieldID,
			&i.PriceFieldValueID,
			&i.Label,
			&i.Qty,
			&i.UnitPrice,
			&i.LineTotal,
			&i.FinancialTypeID,
			&i.NonDeductibleAmount,
			&i.TaxAmount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchLineItems = `-- name: SearchLineItems :many
SELECT id, entity_table, entity_id, price_field_id, price_field_value_id, label, qty, unit_price, line_total, financial_type_id, non_deductible_amount, tax_amount, created_at, updated_at FROM line_items 
WHERE label ILIKE $1
ORDER BY entity_table, entity_id, id
`

func (q *Queries) SearchLineItems(ctx context.Context, label string) ([]LineItem, error) {
	rows, err := q.db.QueryContext(ctx, SearchLineItems, label)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LineItem{}
	for rows.Next() {
		var i LineItem
		if err := rows.Scan(
			&i.ID,
			&i.EntityTable,
			&i.EntityID,
			&i.PriceFieldID,
			&i.PriceFieldValueID,
			&i.Label,
			&i.Qty,
			&i.UnitPrice,
			&i.LineTotal,
			&i.FinancialTypeID,
			&i.NonDeductibleAmount,
			&i.TaxAmount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateLineItem = `-- name: UpdateLineItem :one
UPDATE line_items SET
    entity_table = $2, entity_id = $3, price_field_id = $4, 
    price_field_value_id = $5, label = $6, qty = $7, unit_price = $8,
    line_total = $9, financial_type_id = $10, non_deductible_amount = $11,
    tax_amount = $12, updated_at = NOW()
WHERE id = $1 RETURNING id, entity_table, entity_id, price_field_id, price_field_value_id, label, qty, unit_price, line_total, financial_type_id, non_deductible_amount, tax_amount, created_at, updated_at
`

type UpdateLineItemParams struct {
	ID                  uuid.UUID      `json:"id"`
	EntityTable         string         `json:"entity_table"`
	EntityID            uuid.UUID      `json:"entity_id"`
	PriceFieldID        uuid.NullUUID  `json:"price_field_id"`
	PriceFieldValueID   uuid.NullUUID  `json:"price_field_value_id"`
	Label               string         `json:"label"`
	Qty                 int32          `json:"qty"`
	UnitPrice           string         `json:"unit_price"`
	LineTotal           string         `json:"line_total"`
	FinancialTypeID     uuid.NullUUID  `json:"financial_type_id"`
	NonDeductibleAmount sql.NullString `json:"non_deductible_amount"`
	TaxAmount           sql.NullString `json:"tax_amount"`
}

func (q *Queries) UpdateLineItem(ctx context.Context, arg UpdateLineItemParams) (LineItem, error) {
	row := q.db.QueryRowContext(ctx, UpdateLineItem,
		arg.ID,
		arg.EntityTable,
		arg.EntityID,
		arg.PriceFieldID,
		arg.PriceFieldValueID,
		arg.Label,
		arg.Qty,
		arg.UnitPrice,
		arg.LineTotal,
		arg.FinancialTypeID,
		arg.NonDeductibleAmount,
		arg.TaxAmount,
	)
	var i LineItem
	err := row.Scan(
		&i.ID,
		&i.EntityTable,
		&i.EntityID,
		&i.PriceFieldID,
		&i.PriceFieldValueID,
		&i.Label,
		&i.Qty,
		&i.UnitPrice,
		&i.LineTotal,
		&i.FinancialTypeID,
		&i.NonDeductibleAmount,
		&i.TaxAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
