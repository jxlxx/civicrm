// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: memberships.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const CreateMembership = `-- name: CreateMembership :one
INSERT INTO memberships (
    contact_id, membership_type_id, status_id, join_date, start_date, end_date,
    source, is_override, status_override_end_date, is_pay_later, contribution_id,
    campaign_id, is_test, num_terms, max_related_contacts
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15
) RETURNING id, contact_id, membership_type_id, status_id, join_date, start_date, end_date, source, is_override, status_override_end_date, is_pay_later, contribution_id, campaign_id, is_test, num_terms, max_related_contacts, created_at, updated_at
`

type CreateMembershipParams struct {
	ContactID             uuid.UUID      `json:"contact_id"`
	MembershipTypeID      uuid.UUID      `json:"membership_type_id"`
	StatusID              uuid.UUID      `json:"status_id"`
	JoinDate              time.Time      `json:"join_date"`
	StartDate             time.Time      `json:"start_date"`
	EndDate               sql.NullTime   `json:"end_date"`
	Source                sql.NullString `json:"source"`
	IsOverride            sql.NullBool   `json:"is_override"`
	StatusOverrideEndDate sql.NullTime   `json:"status_override_end_date"`
	IsPayLater            sql.NullBool   `json:"is_pay_later"`
	ContributionID        uuid.NullUUID  `json:"contribution_id"`
	CampaignID            uuid.NullUUID  `json:"campaign_id"`
	IsTest                sql.NullBool   `json:"is_test"`
	NumTerms              sql.NullInt32  `json:"num_terms"`
	MaxRelatedContacts    sql.NullInt32  `json:"max_related_contacts"`
}

func (q *Queries) CreateMembership(ctx context.Context, arg CreateMembershipParams) (Membership, error) {
	row := q.db.QueryRowContext(ctx, CreateMembership,
		arg.ContactID,
		arg.MembershipTypeID,
		arg.StatusID,
		arg.JoinDate,
		arg.StartDate,
		arg.EndDate,
		arg.Source,
		arg.IsOverride,
		arg.StatusOverrideEndDate,
		arg.IsPayLater,
		arg.ContributionID,
		arg.CampaignID,
		arg.IsTest,
		arg.NumTerms,
		arg.MaxRelatedContacts,
	)
	var i Membership
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.MembershipTypeID,
		&i.StatusID,
		&i.JoinDate,
		&i.StartDate,
		&i.EndDate,
		&i.Source,
		&i.IsOverride,
		&i.StatusOverrideEndDate,
		&i.IsPayLater,
		&i.ContributionID,
		&i.CampaignID,
		&i.IsTest,
		&i.NumTerms,
		&i.MaxRelatedContacts,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const DeleteMembership = `-- name: DeleteMembership :exec
DELETE FROM memberships WHERE id = $1
`

func (q *Queries) DeleteMembership(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteMembership, id)
	return err
}

const ExtendMembership = `-- name: ExtendMembership :exec
UPDATE memberships SET end_date = $2, updated_at = NOW() WHERE id = $1
`

type ExtendMembershipParams struct {
	ID      uuid.UUID    `json:"id"`
	EndDate sql.NullTime `json:"end_date"`
}

func (q *Queries) ExtendMembership(ctx context.Context, arg ExtendMembershipParams) error {
	_, err := q.db.ExecContext(ctx, ExtendMembership, arg.ID, arg.EndDate)
	return err
}

const GetActiveMembershipByContact = `-- name: GetActiveMembershipByContact :one
SELECT id, contact_id, membership_type_id, status_id, join_date, start_date, end_date, source, is_override, status_override_end_date, is_pay_later, contribution_id, campaign_id, is_test, num_terms, max_related_contacts, created_at, updated_at FROM memberships 
WHERE contact_id = $1 AND status_id IN (
    SELECT id FROM membership_status WHERE is_current_member = TRUE
) ORDER BY start_date DESC LIMIT 1
`

func (q *Queries) GetActiveMembershipByContact(ctx context.Context, contactID uuid.UUID) (Membership, error) {
	row := q.db.QueryRowContext(ctx, GetActiveMembershipByContact, contactID)
	var i Membership
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.MembershipTypeID,
		&i.StatusID,
		&i.JoinDate,
		&i.StartDate,
		&i.EndDate,
		&i.Source,
		&i.IsOverride,
		&i.StatusOverrideEndDate,
		&i.IsPayLater,
		&i.ContributionID,
		&i.CampaignID,
		&i.IsTest,
		&i.NumTerms,
		&i.MaxRelatedContacts,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetMembership = `-- name: GetMembership :one
SELECT id, contact_id, membership_type_id, status_id, join_date, start_date, end_date, source, is_override, status_override_end_date, is_pay_later, contribution_id, campaign_id, is_test, num_terms, max_related_contacts, created_at, updated_at FROM memberships WHERE id = $1
`

func (q *Queries) GetMembership(ctx context.Context, id uuid.UUID) (Membership, error) {
	row := q.db.QueryRowContext(ctx, GetMembership, id)
	var i Membership
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.MembershipTypeID,
		&i.StatusID,
		&i.JoinDate,
		&i.StartDate,
		&i.EndDate,
		&i.Source,
		&i.IsOverride,
		&i.StatusOverrideEndDate,
		&i.IsPayLater,
		&i.ContributionID,
		&i.CampaignID,
		&i.IsTest,
		&i.NumTerms,
		&i.MaxRelatedContacts,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetMembershipByContact = `-- name: GetMembershipByContact :many
SELECT id, contact_id, membership_type_id, status_id, join_date, start_date, end_date, source, is_override, status_override_end_date, is_pay_later, contribution_id, campaign_id, is_test, num_terms, max_related_contacts, created_at, updated_at FROM memberships WHERE contact_id = $1 ORDER BY start_date DESC
`

func (q *Queries) GetMembershipByContact(ctx context.Context, contactID uuid.UUID) ([]Membership, error) {
	rows, err := q.db.QueryContext(ctx, GetMembershipByContact, contactID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Membership{}
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.MembershipTypeID,
			&i.StatusID,
			&i.JoinDate,
			&i.StartDate,
			&i.EndDate,
			&i.Source,
			&i.IsOverride,
			&i.StatusOverrideEndDate,
			&i.IsPayLater,
			&i.ContributionID,
			&i.CampaignID,
			&i.IsTest,
			&i.NumTerms,
			&i.MaxRelatedContacts,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetMembershipCount = `-- name: GetMembershipCount :one
SELECT COUNT(*) FROM memberships WHERE contact_id = $1 AND is_test = $2
`

type GetMembershipCountParams struct {
	ContactID uuid.UUID    `json:"contact_id"`
	IsTest    sql.NullBool `json:"is_test"`
}

func (q *Queries) GetMembershipCount(ctx context.Context, arg GetMembershipCountParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, GetMembershipCount, arg.ContactID, arg.IsTest)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const GetMembershipStats = `-- name: GetMembershipStats :many
SELECT 
    mt.name as membership_type,
    ms.name as status,
    COUNT(*) as count
FROM memberships m
JOIN membership_types mt ON m.membership_type_id = mt.id
JOIN membership_status ms ON m.status_id = ms.id
WHERE m.is_test = $1
GROUP BY mt.name, ms.name
ORDER BY mt.name, ms.name
`

type GetMembershipStatsRow struct {
	MembershipType string `json:"membership_type"`
	Status         string `json:"status"`
	Count          int64  `json:"count"`
}

func (q *Queries) GetMembershipStats(ctx context.Context, isTest sql.NullBool) ([]GetMembershipStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetMembershipStats, isTest)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembershipStatsRow{}
	for rows.Next() {
		var i GetMembershipStatsRow
		if err := rows.Scan(&i.MembershipType, &i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListExpiringMemberships = `-- name: ListExpiringMemberships :many
SELECT id, contact_id, membership_type_id, status_id, join_date, start_date, end_date, source, is_override, status_override_end_date, is_pay_later, contribution_id, campaign_id, is_test, num_terms, max_related_contacts, created_at, updated_at FROM memberships 
WHERE end_date >= $1 AND end_date <= $2 AND is_test = $3 
ORDER BY end_date ASC
`

type ListExpiringMembershipsParams struct {
	EndDate   sql.NullTime `json:"end_date"`
	EndDate_2 sql.NullTime `json:"end_date_2"`
	IsTest    sql.NullBool `json:"is_test"`
}

func (q *Queries) ListExpiringMemberships(ctx context.Context, arg ListExpiringMembershipsParams) ([]Membership, error) {
	rows, err := q.db.QueryContext(ctx, ListExpiringMemberships, arg.EndDate, arg.EndDate_2, arg.IsTest)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Membership{}
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.MembershipTypeID,
			&i.StatusID,
			&i.JoinDate,
			&i.StartDate,
			&i.EndDate,
			&i.Source,
			&i.IsOverride,
			&i.StatusOverrideEndDate,
			&i.IsPayLater,
			&i.ContributionID,
			&i.CampaignID,
			&i.IsTest,
			&i.NumTerms,
			&i.MaxRelatedContacts,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListMemberships = `-- name: ListMemberships :many
SELECT id, contact_id, membership_type_id, status_id, join_date, start_date, end_date, source, is_override, status_override_end_date, is_pay_later, contribution_id, campaign_id, is_test, num_terms, max_related_contacts, created_at, updated_at FROM memberships 
WHERE is_test = $1 
ORDER BY start_date DESC
`

func (q *Queries) ListMemberships(ctx context.Context, isTest sql.NullBool) ([]Membership, error) {
	rows, err := q.db.QueryContext(ctx, ListMemberships, isTest)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Membership{}
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.MembershipTypeID,
			&i.StatusID,
			&i.JoinDate,
			&i.StartDate,
			&i.EndDate,
			&i.Source,
			&i.IsOverride,
			&i.StatusOverrideEndDate,
			&i.IsPayLater,
			&i.ContributionID,
			&i.CampaignID,
			&i.IsTest,
			&i.NumTerms,
			&i.MaxRelatedContacts,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListMembershipsByCampaign = `-- name: ListMembershipsByCampaign :many
SELECT id, contact_id, membership_type_id, status_id, join_date, start_date, end_date, source, is_override, status_override_end_date, is_pay_later, contribution_id, campaign_id, is_test, num_terms, max_related_contacts, created_at, updated_at FROM memberships 
WHERE campaign_id = $1 AND is_test = $2 
ORDER BY start_date DESC
`

type ListMembershipsByCampaignParams struct {
	CampaignID uuid.NullUUID `json:"campaign_id"`
	IsTest     sql.NullBool  `json:"is_test"`
}

func (q *Queries) ListMembershipsByCampaign(ctx context.Context, arg ListMembershipsByCampaignParams) ([]Membership, error) {
	rows, err := q.db.QueryContext(ctx, ListMembershipsByCampaign, arg.CampaignID, arg.IsTest)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Membership{}
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.MembershipTypeID,
			&i.StatusID,
			&i.JoinDate,
			&i.StartDate,
			&i.EndDate,
			&i.Source,
			&i.IsOverride,
			&i.StatusOverrideEndDate,
			&i.IsPayLater,
			&i.ContributionID,
			&i.CampaignID,
			&i.IsTest,
			&i.NumTerms,
			&i.MaxRelatedContacts,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListMembershipsByDateRange = `-- name: ListMembershipsByDateRange :many
SELECT id, contact_id, membership_type_id, status_id, join_date, start_date, end_date, source, is_override, status_override_end_date, is_pay_later, contribution_id, campaign_id, is_test, num_terms, max_related_contacts, created_at, updated_at FROM memberships 
WHERE start_date >= $1 AND start_date <= $2 AND is_test = $3 
ORDER BY start_date DESC
`

type ListMembershipsByDateRangeParams struct {
	StartDate   time.Time    `json:"start_date"`
	StartDate_2 time.Time    `json:"start_date_2"`
	IsTest      sql.NullBool `json:"is_test"`
}

func (q *Queries) ListMembershipsByDateRange(ctx context.Context, arg ListMembershipsByDateRangeParams) ([]Membership, error) {
	rows, err := q.db.QueryContext(ctx, ListMembershipsByDateRange, arg.StartDate, arg.StartDate_2, arg.IsTest)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Membership{}
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.MembershipTypeID,
			&i.StatusID,
			&i.JoinDate,
			&i.StartDate,
			&i.EndDate,
			&i.Source,
			&i.IsOverride,
			&i.StatusOverrideEndDate,
			&i.IsPayLater,
			&i.ContributionID,
			&i.CampaignID,
			&i.IsTest,
			&i.NumTerms,
			&i.MaxRelatedContacts,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListMembershipsByStatus = `-- name: ListMembershipsByStatus :many
SELECT id, contact_id, membership_type_id, status_id, join_date, start_date, end_date, source, is_override, status_override_end_date, is_pay_later, contribution_id, campaign_id, is_test, num_terms, max_related_contacts, created_at, updated_at FROM memberships 
WHERE status_id = $1 AND is_test = $2 
ORDER BY start_date DESC
`

type ListMembershipsByStatusParams struct {
	StatusID uuid.UUID    `json:"status_id"`
	IsTest   sql.NullBool `json:"is_test"`
}

func (q *Queries) ListMembershipsByStatus(ctx context.Context, arg ListMembershipsByStatusParams) ([]Membership, error) {
	rows, err := q.db.QueryContext(ctx, ListMembershipsByStatus, arg.StatusID, arg.IsTest)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Membership{}
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.MembershipTypeID,
			&i.StatusID,
			&i.JoinDate,
			&i.StartDate,
			&i.EndDate,
			&i.Source,
			&i.IsOverride,
			&i.StatusOverrideEndDate,
			&i.IsPayLater,
			&i.ContributionID,
			&i.CampaignID,
			&i.IsTest,
			&i.NumTerms,
			&i.MaxRelatedContacts,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListMembershipsByType = `-- name: ListMembershipsByType :many
SELECT id, contact_id, membership_type_id, status_id, join_date, start_date, end_date, source, is_override, status_override_end_date, is_pay_later, contribution_id, campaign_id, is_test, num_terms, max_related_contacts, created_at, updated_at FROM memberships 
WHERE membership_type_id = $1 AND is_test = $2 
ORDER BY start_date DESC
`

type ListMembershipsByTypeParams struct {
	MembershipTypeID uuid.UUID    `json:"membership_type_id"`
	IsTest           sql.NullBool `json:"is_test"`
}

func (q *Queries) ListMembershipsByType(ctx context.Context, arg ListMembershipsByTypeParams) ([]Membership, error) {
	rows, err := q.db.QueryContext(ctx, ListMembershipsByType, arg.MembershipTypeID, arg.IsTest)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Membership{}
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.MembershipTypeID,
			&i.StatusID,
			&i.JoinDate,
			&i.StartDate,
			&i.EndDate,
			&i.Source,
			&i.IsOverride,
			&i.StatusOverrideEndDate,
			&i.IsPayLater,
			&i.ContributionID,
			&i.CampaignID,
			&i.IsTest,
			&i.NumTerms,
			&i.MaxRelatedContacts,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchMemberships = `-- name: SearchMemberships :many
SELECT m.id, m.contact_id, m.membership_type_id, m.status_id, m.join_date, m.start_date, m.end_date, m.source, m.is_override, m.status_override_end_date, m.is_pay_later, m.contribution_id, m.campaign_id, m.is_test, m.num_terms, m.max_related_contacts, m.created_at, m.updated_at FROM memberships m
JOIN contacts c ON m.contact_id = c.id
WHERE (c.first_name ILIKE $1 OR c.last_name ILIKE $1 OR c.organization_name ILIKE $1)
AND m.is_test = $2 
ORDER BY m.start_date DESC
`

type SearchMembershipsParams struct {
	FirstName sql.NullString `json:"first_name"`
	IsTest    sql.NullBool   `json:"is_test"`
}

func (q *Queries) SearchMemberships(ctx context.Context, arg SearchMembershipsParams) ([]Membership, error) {
	rows, err := q.db.QueryContext(ctx, SearchMemberships, arg.FirstName, arg.IsTest)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Membership{}
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.MembershipTypeID,
			&i.StatusID,
			&i.JoinDate,
			&i.StartDate,
			&i.EndDate,
			&i.Source,
			&i.IsOverride,
			&i.StatusOverrideEndDate,
			&i.IsPayLater,
			&i.ContributionID,
			&i.CampaignID,
			&i.IsTest,
			&i.NumTerms,
			&i.MaxRelatedContacts,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateMembership = `-- name: UpdateMembership :one
UPDATE memberships SET
    contact_id = $2, membership_type_id = $3, status_id = $4, join_date = $5,
    start_date = $6, end_date = $7, source = $8, is_override = $9,
    status_override_end_date = $10, is_pay_later = $11, contribution_id = $12,
    campaign_id = $13, is_test = $14, num_terms = $15, max_related_contacts = $16,
    updated_at = NOW()
WHERE id = $1 RETURNING id, contact_id, membership_type_id, status_id, join_date, start_date, end_date, source, is_override, status_override_end_date, is_pay_later, contribution_id, campaign_id, is_test, num_terms, max_related_contacts, created_at, updated_at
`

type UpdateMembershipParams struct {
	ID                    uuid.UUID      `json:"id"`
	ContactID             uuid.UUID      `json:"contact_id"`
	MembershipTypeID      uuid.UUID      `json:"membership_type_id"`
	StatusID              uuid.UUID      `json:"status_id"`
	JoinDate              time.Time      `json:"join_date"`
	StartDate             time.Time      `json:"start_date"`
	EndDate               sql.NullTime   `json:"end_date"`
	Source                sql.NullString `json:"source"`
	IsOverride            sql.NullBool   `json:"is_override"`
	StatusOverrideEndDate sql.NullTime   `json:"status_override_end_date"`
	IsPayLater            sql.NullBool   `json:"is_pay_later"`
	ContributionID        uuid.NullUUID  `json:"contribution_id"`
	CampaignID            uuid.NullUUID  `json:"campaign_id"`
	IsTest                sql.NullBool   `json:"is_test"`
	NumTerms              sql.NullInt32  `json:"num_terms"`
	MaxRelatedContacts    sql.NullInt32  `json:"max_related_contacts"`
}

func (q *Queries) UpdateMembership(ctx context.Context, arg UpdateMembershipParams) (Membership, error) {
	row := q.db.QueryRowContext(ctx, UpdateMembership,
		arg.ID,
		arg.ContactID,
		arg.MembershipTypeID,
		arg.StatusID,
		arg.JoinDate,
		arg.StartDate,
		arg.EndDate,
		arg.Source,
		arg.IsOverride,
		arg.StatusOverrideEndDate,
		arg.IsPayLater,
		arg.ContributionID,
		arg.CampaignID,
		arg.IsTest,
		arg.NumTerms,
		arg.MaxRelatedContacts,
	)
	var i Membership
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.MembershipTypeID,
		&i.StatusID,
		&i.JoinDate,
		&i.StartDate,
		&i.EndDate,
		&i.Source,
		&i.IsOverride,
		&i.StatusOverrideEndDate,
		&i.IsPayLater,
		&i.ContributionID,
		&i.CampaignID,
		&i.IsTest,
		&i.NumTerms,
		&i.MaxRelatedContacts,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateMembershipStatusById = `-- name: UpdateMembershipStatusById :exec
UPDATE memberships SET status_id = $2, updated_at = NOW() WHERE id = $1
`

type UpdateMembershipStatusByIdParams struct {
	ID       uuid.UUID `json:"id"`
	StatusID uuid.UUID `json:"status_id"`
}

func (q *Queries) UpdateMembershipStatusById(ctx context.Context, arg UpdateMembershipStatusByIdParams) error {
	_, err := q.db.ExecContext(ctx, UpdateMembershipStatusById, arg.ID, arg.StatusID)
	return err
}
