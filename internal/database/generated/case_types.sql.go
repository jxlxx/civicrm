// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: case_types.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const ActivateCaseType = `-- name: ActivateCaseType :exec
UPDATE case_types SET is_active = TRUE, updated_at = NOW() WHERE id = $1
`

func (q *Queries) ActivateCaseType(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, ActivateCaseType, id)
	return err
}

const CreateCaseType = `-- name: CreateCaseType :one
INSERT INTO case_types (
    name, title, description, is_active, is_reserved, weight, definition
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, name, title, description, is_active, is_reserved, weight, definition, created_at, updated_at
`

type CreateCaseTypeParams struct {
	Name        string         `json:"name"`
	Title       string         `json:"title"`
	Description sql.NullString `json:"description"`
	IsActive    sql.NullBool   `json:"is_active"`
	IsReserved  sql.NullBool   `json:"is_reserved"`
	Weight      sql.NullInt32  `json:"weight"`
	Definition  sql.NullString `json:"definition"`
}

func (q *Queries) CreateCaseType(ctx context.Context, arg CreateCaseTypeParams) (CaseType, error) {
	row := q.db.QueryRowContext(ctx, CreateCaseType,
		arg.Name,
		arg.Title,
		arg.Description,
		arg.IsActive,
		arg.IsReserved,
		arg.Weight,
		arg.Definition,
	)
	var i CaseType
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Title,
		&i.Description,
		&i.IsActive,
		&i.IsReserved,
		&i.Weight,
		&i.Definition,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const DeactivateCaseType = `-- name: DeactivateCaseType :exec
UPDATE case_types SET is_active = FALSE, updated_at = NOW() WHERE id = $1
`

func (q *Queries) DeactivateCaseType(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeactivateCaseType, id)
	return err
}

const DeleteCaseType = `-- name: DeleteCaseType :exec
DELETE FROM case_types WHERE id = $1
`

func (q *Queries) DeleteCaseType(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteCaseType, id)
	return err
}

const GetCaseType = `-- name: GetCaseType :one
SELECT id, name, title, description, is_active, is_reserved, weight, definition, created_at, updated_at FROM case_types WHERE id = $1
`

func (q *Queries) GetCaseType(ctx context.Context, id uuid.UUID) (CaseType, error) {
	row := q.db.QueryRowContext(ctx, GetCaseType, id)
	var i CaseType
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Title,
		&i.Description,
		&i.IsActive,
		&i.IsReserved,
		&i.Weight,
		&i.Definition,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetCaseTypeByName = `-- name: GetCaseTypeByName :one
SELECT id, name, title, description, is_active, is_reserved, weight, definition, created_at, updated_at FROM case_types WHERE name = $1
`

func (q *Queries) GetCaseTypeByName(ctx context.Context, name string) (CaseType, error) {
	row := q.db.QueryRowContext(ctx, GetCaseTypeByName, name)
	var i CaseType
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Title,
		&i.Description,
		&i.IsActive,
		&i.IsReserved,
		&i.Weight,
		&i.Definition,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetCaseTypeStats = `-- name: GetCaseTypeStats :many
SELECT 
    ct.name as case_type,
    COUNT(c.id) as case_count
FROM case_types ct
LEFT JOIN cases c ON ct.id = c.case_type_id AND c.is_deleted = FALSE
WHERE ct.is_active = $1
GROUP BY ct.name, ct.weight
ORDER BY ct.weight, ct.name
`

type GetCaseTypeStatsRow struct {
	CaseType  string `json:"case_type"`
	CaseCount int64  `json:"case_count"`
}

func (q *Queries) GetCaseTypeStats(ctx context.Context, isActive sql.NullBool) ([]GetCaseTypeStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetCaseTypeStats, isActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCaseTypeStatsRow{}
	for rows.Next() {
		var i GetCaseTypeStatsRow
		if err := rows.Scan(&i.CaseType, &i.CaseCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListActiveCaseTypes = `-- name: ListActiveCaseTypes :many
SELECT id, name, title, description, is_active, is_reserved, weight, definition, created_at, updated_at FROM case_types 
WHERE is_active = TRUE 
ORDER BY weight, name
`

func (q *Queries) ListActiveCaseTypes(ctx context.Context) ([]CaseType, error) {
	rows, err := q.db.QueryContext(ctx, ListActiveCaseTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CaseType{}
	for rows.Next() {
		var i CaseType
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Title,
			&i.Description,
			&i.IsActive,
			&i.IsReserved,
			&i.Weight,
			&i.Definition,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListCaseTypes = `-- name: ListCaseTypes :many
SELECT id, name, title, description, is_active, is_reserved, weight, definition, created_at, updated_at FROM case_types 
WHERE is_active = $1 
ORDER BY weight, name
`

func (q *Queries) ListCaseTypes(ctx context.Context, isActive sql.NullBool) ([]CaseType, error) {
	rows, err := q.db.QueryContext(ctx, ListCaseTypes, isActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CaseType{}
	for rows.Next() {
		var i CaseType
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Title,
			&i.Description,
			&i.IsActive,
			&i.IsReserved,
			&i.Weight,
			&i.Definition,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListReservedCaseTypes = `-- name: ListReservedCaseTypes :many
SELECT id, name, title, description, is_active, is_reserved, weight, definition, created_at, updated_at FROM case_types 
WHERE is_reserved = TRUE AND is_active = $1 
ORDER BY weight, name
`

func (q *Queries) ListReservedCaseTypes(ctx context.Context, isActive sql.NullBool) ([]CaseType, error) {
	rows, err := q.db.QueryContext(ctx, ListReservedCaseTypes, isActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CaseType{}
	for rows.Next() {
		var i CaseType
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Title,
			&i.Description,
			&i.IsActive,
			&i.IsReserved,
			&i.Weight,
			&i.Definition,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchCaseTypes = `-- name: SearchCaseTypes :many
SELECT id, name, title, description, is_active, is_reserved, weight, definition, created_at, updated_at FROM case_types 
WHERE (name ILIKE $1 OR title ILIKE $1 OR description ILIKE $1) 
AND is_active = $2 
ORDER BY weight, name
`

type SearchCaseTypesParams struct {
	Name     string       `json:"name"`
	IsActive sql.NullBool `json:"is_active"`
}

func (q *Queries) SearchCaseTypes(ctx context.Context, arg SearchCaseTypesParams) ([]CaseType, error) {
	rows, err := q.db.QueryContext(ctx, SearchCaseTypes, arg.Name, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CaseType{}
	for rows.Next() {
		var i CaseType
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Title,
			&i.Description,
			&i.IsActive,
			&i.IsReserved,
			&i.Weight,
			&i.Definition,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateCaseType = `-- name: UpdateCaseType :one
UPDATE case_types SET
    name = $2, title = $3, description = $4, is_active = $5,
    is_reserved = $6, weight = $7, definition = $8, updated_at = NOW()
WHERE id = $1 RETURNING id, name, title, description, is_active, is_reserved, weight, definition, created_at, updated_at
`

type UpdateCaseTypeParams struct {
	ID          uuid.UUID      `json:"id"`
	Name        string         `json:"name"`
	Title       string         `json:"title"`
	Description sql.NullString `json:"description"`
	IsActive    sql.NullBool   `json:"is_active"`
	IsReserved  sql.NullBool   `json:"is_reserved"`
	Weight      sql.NullInt32  `json:"weight"`
	Definition  sql.NullString `json:"definition"`
}

func (q *Queries) UpdateCaseType(ctx context.Context, arg UpdateCaseTypeParams) (CaseType, error) {
	row := q.db.QueryRowContext(ctx, UpdateCaseType,
		arg.ID,
		arg.Name,
		arg.Title,
		arg.Description,
		arg.IsActive,
		arg.IsReserved,
		arg.Weight,
		arg.Definition,
	)
	var i CaseType
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Title,
		&i.Description,
		&i.IsActive,
		&i.IsReserved,
		&i.Weight,
		&i.Definition,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateCaseTypeWeight = `-- name: UpdateCaseTypeWeight :exec
UPDATE case_types SET weight = $2, updated_at = NOW() WHERE id = $1
`

type UpdateCaseTypeWeightParams struct {
	ID     uuid.UUID     `json:"id"`
	Weight sql.NullInt32 `json:"weight"`
}

func (q *Queries) UpdateCaseTypeWeight(ctx context.Context, arg UpdateCaseTypeWeightParams) error {
	_, err := q.db.ExecContext(ctx, UpdateCaseTypeWeight, arg.ID, arg.Weight)
	return err
}
