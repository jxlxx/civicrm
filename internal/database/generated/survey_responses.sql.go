// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: survey_responses.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const CreateSurveyResponse = `-- name: CreateSurveyResponse :one
INSERT INTO survey_responses (
    survey_id, contact_id, response_date, status, ip_address, user_agent, is_test
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, survey_id, contact_id, response_date, status, ip_address, user_agent, is_test, created_at, updated_at
`

type CreateSurveyResponseParams struct {
	SurveyID     uuid.UUID      `json:"survey_id"`
	ContactID    uuid.UUID      `json:"contact_id"`
	ResponseDate sql.NullTime   `json:"response_date"`
	Status       sql.NullString `json:"status"`
	IpAddress    pqtype.Inet    `json:"ip_address"`
	UserAgent    sql.NullString `json:"user_agent"`
	IsTest       sql.NullBool   `json:"is_test"`
}

func (q *Queries) CreateSurveyResponse(ctx context.Context, arg CreateSurveyResponseParams) (SurveyResponse, error) {
	row := q.db.QueryRowContext(ctx, CreateSurveyResponse,
		arg.SurveyID,
		arg.ContactID,
		arg.ResponseDate,
		arg.Status,
		arg.IpAddress,
		arg.UserAgent,
		arg.IsTest,
	)
	var i SurveyResponse
	err := row.Scan(
		&i.ID,
		&i.SurveyID,
		&i.ContactID,
		&i.ResponseDate,
		&i.Status,
		&i.IpAddress,
		&i.UserAgent,
		&i.IsTest,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const DeleteSurveyResponse = `-- name: DeleteSurveyResponse :exec
DELETE FROM survey_responses WHERE id = $1
`

func (q *Queries) DeleteSurveyResponse(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteSurveyResponse, id)
	return err
}

const GetCompletedSurveyResponses = `-- name: GetCompletedSurveyResponses :many
SELECT id, survey_id, contact_id, response_date, status, ip_address, user_agent, is_test, created_at, updated_at FROM survey_responses 
WHERE survey_id = $1 AND status = 'Completed' 
ORDER BY response_date DESC
`

func (q *Queries) GetCompletedSurveyResponses(ctx context.Context, surveyID uuid.UUID) ([]SurveyResponse, error) {
	rows, err := q.db.QueryContext(ctx, GetCompletedSurveyResponses, surveyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SurveyResponse{}
	for rows.Next() {
		var i SurveyResponse
		if err := rows.Scan(
			&i.ID,
			&i.SurveyID,
			&i.ContactID,
			&i.ResponseDate,
			&i.Status,
			&i.IpAddress,
			&i.UserAgent,
			&i.IsTest,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSurveyResponse = `-- name: GetSurveyResponse :one
SELECT id, survey_id, contact_id, response_date, status, ip_address, user_agent, is_test, created_at, updated_at FROM survey_responses WHERE id = $1
`

func (q *Queries) GetSurveyResponse(ctx context.Context, id uuid.UUID) (SurveyResponse, error) {
	row := q.db.QueryRowContext(ctx, GetSurveyResponse, id)
	var i SurveyResponse
	err := row.Scan(
		&i.ID,
		&i.SurveyID,
		&i.ContactID,
		&i.ResponseDate,
		&i.Status,
		&i.IpAddress,
		&i.UserAgent,
		&i.IsTest,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetSurveyResponseBySurveyAndContact = `-- name: GetSurveyResponseBySurveyAndContact :one
SELECT id, survey_id, contact_id, response_date, status, ip_address, user_agent, is_test, created_at, updated_at FROM survey_responses 
WHERE survey_id = $1 AND contact_id = $2 
ORDER BY response_date DESC LIMIT 1
`

type GetSurveyResponseBySurveyAndContactParams struct {
	SurveyID  uuid.UUID `json:"survey_id"`
	ContactID uuid.UUID `json:"contact_id"`
}

func (q *Queries) GetSurveyResponseBySurveyAndContact(ctx context.Context, arg GetSurveyResponseBySurveyAndContactParams) (SurveyResponse, error) {
	row := q.db.QueryRowContext(ctx, GetSurveyResponseBySurveyAndContact, arg.SurveyID, arg.ContactID)
	var i SurveyResponse
	err := row.Scan(
		&i.ID,
		&i.SurveyID,
		&i.ContactID,
		&i.ResponseDate,
		&i.Status,
		&i.IpAddress,
		&i.UserAgent,
		&i.IsTest,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetSurveyResponseCount = `-- name: GetSurveyResponseCount :one
SELECT COUNT(*) FROM survey_responses WHERE survey_id = $1
`

func (q *Queries) GetSurveyResponseCount(ctx context.Context, surveyID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, GetSurveyResponseCount, surveyID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const GetSurveyResponseStats = `-- name: GetSurveyResponseStats :many
SELECT 
    sr.status,
    COUNT(sr.id) as response_count
FROM survey_responses sr
WHERE sr.survey_id = $1
GROUP BY sr.status
ORDER BY sr.status
`

type GetSurveyResponseStatsRow struct {
	Status        sql.NullString `json:"status"`
	ResponseCount int64          `json:"response_count"`
}

func (q *Queries) GetSurveyResponseStats(ctx context.Context, surveyID uuid.UUID) ([]GetSurveyResponseStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetSurveyResponseStats, surveyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSurveyResponseStatsRow{}
	for rows.Next() {
		var i GetSurveyResponseStatsRow
		if err := rows.Scan(&i.Status, &i.ResponseCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSurveyResponseTrends = `-- name: GetSurveyResponseTrends :many
SELECT 
    DATE_TRUNC('day', sr.response_date) as response_date,
    COUNT(sr.id) as response_count,
    COUNT(CASE WHEN sr.status = 'Completed' THEN 1 END) as completed_count
FROM survey_responses sr
WHERE sr.survey_id = $1 AND sr.response_date >= $2
GROUP BY DATE_TRUNC('day', sr.response_date)
ORDER BY response_date DESC
`

type GetSurveyResponseTrendsParams struct {
	SurveyID     uuid.UUID    `json:"survey_id"`
	ResponseDate sql.NullTime `json:"response_date"`
}

type GetSurveyResponseTrendsRow struct {
	ResponseDate   int64 `json:"response_date"`
	ResponseCount  int64 `json:"response_count"`
	CompletedCount int64 `json:"completed_count"`
}

func (q *Queries) GetSurveyResponseTrends(ctx context.Context, arg GetSurveyResponseTrendsParams) ([]GetSurveyResponseTrendsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetSurveyResponseTrends, arg.SurveyID, arg.ResponseDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSurveyResponseTrendsRow{}
	for rows.Next() {
		var i GetSurveyResponseTrendsRow
		if err := rows.Scan(&i.ResponseDate, &i.ResponseCount, &i.CompletedCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSurveyResponsesByContact = `-- name: GetSurveyResponsesByContact :many
SELECT id, survey_id, contact_id, response_date, status, ip_address, user_agent, is_test, created_at, updated_at FROM survey_responses 
WHERE contact_id = $1 
ORDER BY response_date DESC
`

func (q *Queries) GetSurveyResponsesByContact(ctx context.Context, contactID uuid.UUID) ([]SurveyResponse, error) {
	rows, err := q.db.QueryContext(ctx, GetSurveyResponsesByContact, contactID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SurveyResponse{}
	for rows.Next() {
		var i SurveyResponse
		if err := rows.Scan(
			&i.ID,
			&i.SurveyID,
			&i.ContactID,
			&i.ResponseDate,
			&i.Status,
			&i.IpAddress,
			&i.UserAgent,
			&i.IsTest,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSurveyResponsesByStatus = `-- name: GetSurveyResponsesByStatus :many
SELECT id, survey_id, contact_id, response_date, status, ip_address, user_agent, is_test, created_at, updated_at FROM survey_responses 
WHERE survey_id = $1 AND status = $2 
ORDER BY response_date DESC
`

type GetSurveyResponsesByStatusParams struct {
	SurveyID uuid.UUID      `json:"survey_id"`
	Status   sql.NullString `json:"status"`
}

func (q *Queries) GetSurveyResponsesByStatus(ctx context.Context, arg GetSurveyResponsesByStatusParams) ([]SurveyResponse, error) {
	rows, err := q.db.QueryContext(ctx, GetSurveyResponsesByStatus, arg.SurveyID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SurveyResponse{}
	for rows.Next() {
		var i SurveyResponse
		if err := rows.Scan(
			&i.ID,
			&i.SurveyID,
			&i.ContactID,
			&i.ResponseDate,
			&i.Status,
			&i.IpAddress,
			&i.UserAgent,
			&i.IsTest,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSurveyResponsesBySurvey = `-- name: GetSurveyResponsesBySurvey :many
SELECT id, survey_id, contact_id, response_date, status, ip_address, user_agent, is_test, created_at, updated_at FROM survey_responses 
WHERE survey_id = $1 
ORDER BY response_date DESC
`

func (q *Queries) GetSurveyResponsesBySurvey(ctx context.Context, surveyID uuid.UUID) ([]SurveyResponse, error) {
	rows, err := q.db.QueryContext(ctx, GetSurveyResponsesBySurvey, surveyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SurveyResponse{}
	for rows.Next() {
		var i SurveyResponse
		if err := rows.Scan(
			&i.ID,
			&i.SurveyID,
			&i.ContactID,
			&i.ResponseDate,
			&i.Status,
			&i.IpAddress,
			&i.UserAgent,
			&i.IsTest,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListSurveyResponses = `-- name: ListSurveyResponses :many
SELECT id, survey_id, contact_id, response_date, status, ip_address, user_agent, is_test, created_at, updated_at FROM survey_responses 
ORDER BY response_date DESC
`

func (q *Queries) ListSurveyResponses(ctx context.Context) ([]SurveyResponse, error) {
	rows, err := q.db.QueryContext(ctx, ListSurveyResponses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SurveyResponse{}
	for rows.Next() {
		var i SurveyResponse
		if err := rows.Scan(
			&i.ID,
			&i.SurveyID,
			&i.ContactID,
			&i.ResponseDate,
			&i.Status,
			&i.IpAddress,
			&i.UserAgent,
			&i.IsTest,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListSurveyResponsesByDateRange = `-- name: ListSurveyResponsesByDateRange :many
SELECT id, survey_id, contact_id, response_date, status, ip_address, user_agent, is_test, created_at, updated_at FROM survey_responses 
WHERE response_date >= $1 AND response_date <= $2 
ORDER BY response_date DESC
`

type ListSurveyResponsesByDateRangeParams struct {
	ResponseDate   sql.NullTime `json:"response_date"`
	ResponseDate_2 sql.NullTime `json:"response_date_2"`
}

func (q *Queries) ListSurveyResponsesByDateRange(ctx context.Context, arg ListSurveyResponsesByDateRangeParams) ([]SurveyResponse, error) {
	rows, err := q.db.QueryContext(ctx, ListSurveyResponsesByDateRange, arg.ResponseDate, arg.ResponseDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SurveyResponse{}
	for rows.Next() {
		var i SurveyResponse
		if err := rows.Scan(
			&i.ID,
			&i.SurveyID,
			&i.ContactID,
			&i.ResponseDate,
			&i.Status,
			&i.IpAddress,
			&i.UserAgent,
			&i.IsTest,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListTestSurveyResponses = `-- name: ListTestSurveyResponses :many
SELECT id, survey_id, contact_id, response_date, status, ip_address, user_agent, is_test, created_at, updated_at FROM survey_responses 
WHERE is_test = $1 
ORDER BY response_date DESC
`

func (q *Queries) ListTestSurveyResponses(ctx context.Context, isTest sql.NullBool) ([]SurveyResponse, error) {
	rows, err := q.db.QueryContext(ctx, ListTestSurveyResponses, isTest)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SurveyResponse{}
	for rows.Next() {
		var i SurveyResponse
		if err := rows.Scan(
			&i.ID,
			&i.SurveyID,
			&i.ContactID,
			&i.ResponseDate,
			&i.Status,
			&i.IpAddress,
			&i.UserAgent,
			&i.IsTest,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const MarkSurveyResponseAbandoned = `-- name: MarkSurveyResponseAbandoned :exec
UPDATE survey_responses SET status = 'Abandoned', updated_at = NOW() WHERE id = $1
`

func (q *Queries) MarkSurveyResponseAbandoned(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, MarkSurveyResponseAbandoned, id)
	return err
}

const MarkSurveyResponseCompleted = `-- name: MarkSurveyResponseCompleted :exec
UPDATE survey_responses SET status = 'Completed', updated_at = NOW() WHERE id = $1
`

func (q *Queries) MarkSurveyResponseCompleted(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, MarkSurveyResponseCompleted, id)
	return err
}

const MarkSurveyResponsePartial = `-- name: MarkSurveyResponsePartial :exec
UPDATE survey_responses SET status = 'Partial', updated_at = NOW() WHERE id = $1
`

func (q *Queries) MarkSurveyResponsePartial(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, MarkSurveyResponsePartial, id)
	return err
}

const SearchSurveyResponses = `-- name: SearchSurveyResponses :many
SELECT sr.id, sr.survey_id, sr.contact_id, sr.response_date, sr.status, sr.ip_address, sr.user_agent, sr.is_test, sr.created_at, sr.updated_at FROM survey_responses sr
JOIN contacts c ON sr.contact_id = c.id
WHERE (c.first_name ILIKE $1 OR c.last_name ILIKE $1 OR c.organization_name ILIKE $1)
ORDER BY sr.response_date DESC
`

func (q *Queries) SearchSurveyResponses(ctx context.Context, firstName sql.NullString) ([]SurveyResponse, error) {
	rows, err := q.db.QueryContext(ctx, SearchSurveyResponses, firstName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SurveyResponse{}
	for rows.Next() {
		var i SurveyResponse
		if err := rows.Scan(
			&i.ID,
			&i.SurveyID,
			&i.ContactID,
			&i.ResponseDate,
			&i.Status,
			&i.IpAddress,
			&i.UserAgent,
			&i.IsTest,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateSurveyResponse = `-- name: UpdateSurveyResponse :one
UPDATE survey_responses SET
    survey_id = $2, contact_id = $3, response_date = $4, status = $5,
    ip_address = $6, user_agent = $7, is_test = $8, updated_at = NOW()
WHERE id = $1 RETURNING id, survey_id, contact_id, response_date, status, ip_address, user_agent, is_test, created_at, updated_at
`

type UpdateSurveyResponseParams struct {
	ID           uuid.UUID      `json:"id"`
	SurveyID     uuid.UUID      `json:"survey_id"`
	ContactID    uuid.UUID      `json:"contact_id"`
	ResponseDate sql.NullTime   `json:"response_date"`
	Status       sql.NullString `json:"status"`
	IpAddress    pqtype.Inet    `json:"ip_address"`
	UserAgent    sql.NullString `json:"user_agent"`
	IsTest       sql.NullBool   `json:"is_test"`
}

func (q *Queries) UpdateSurveyResponse(ctx context.Context, arg UpdateSurveyResponseParams) (SurveyResponse, error) {
	row := q.db.QueryRowContext(ctx, UpdateSurveyResponse,
		arg.ID,
		arg.SurveyID,
		arg.ContactID,
		arg.ResponseDate,
		arg.Status,
		arg.IpAddress,
		arg.UserAgent,
		arg.IsTest,
	)
	var i SurveyResponse
	err := row.Scan(
		&i.ID,
		&i.SurveyID,
		&i.ContactID,
		&i.ResponseDate,
		&i.Status,
		&i.IpAddress,
		&i.UserAgent,
		&i.IsTest,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateSurveyResponseStatus = `-- name: UpdateSurveyResponseStatus :exec
UPDATE survey_responses SET status = $2, updated_at = NOW() WHERE id = $1
`

type UpdateSurveyResponseStatusParams struct {
	ID     uuid.UUID      `json:"id"`
	Status sql.NullString `json:"status"`
}

func (q *Queries) UpdateSurveyResponseStatus(ctx context.Context, arg UpdateSurveyResponseStatusParams) error {
	_, err := q.db.ExecContext(ctx, UpdateSurveyResponseStatus, arg.ID, arg.Status)
	return err
}
