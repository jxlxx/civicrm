// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: jobs.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const CleanupOldJobLogs = `-- name: CleanupOldJobLogs :exec
DELETE FROM job_logs 
WHERE job_id = $1 
AND started_at < NOW() - INTERVAL '30 days'
`

func (q *Queries) CleanupOldJobLogs(ctx context.Context, jobID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, CleanupOldJobLogs, jobID)
	return err
}

const CountActiveJobsByDomain = `-- name: CountActiveJobsByDomain :one
SELECT COUNT(*) FROM jobs WHERE domain_id = $1 AND is_active = TRUE
`

func (q *Queries) CountActiveJobsByDomain(ctx context.Context, domainID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountActiveJobsByDomain, domainID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountJobsByDomain = `-- name: CountJobsByDomain :one
SELECT COUNT(*) FROM jobs WHERE domain_id = $1
`

func (q *Queries) CountJobsByDomain(ctx context.Context, domainID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountJobsByDomain, domainID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountScheduledJobsByDomain = `-- name: CountScheduledJobsByDomain :one
SELECT COUNT(*) FROM jobs WHERE domain_id = $1 AND schedule IS NOT NULL AND is_active = TRUE
`

func (q *Queries) CountScheduledJobsByDomain(ctx context.Context, domainID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountScheduledJobsByDomain, domainID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateJob = `-- name: CreateJob :one
INSERT INTO jobs (
    domain_id, name, description, job_type, parameters, schedule, is_active
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, domain_id, name, description, job_type, parameters, schedule, is_active, last_run, next_run, created_at, updated_at
`

type CreateJobParams struct {
	DomainID    uuid.UUID      `json:"domain_id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	JobType     string         `json:"job_type"`
	Parameters  sql.NullString `json:"parameters"`
	Schedule    sql.NullString `json:"schedule"`
	IsActive    sql.NullBool   `json:"is_active"`
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (Job, error) {
	row := q.db.QueryRowContext(ctx, CreateJob,
		arg.DomainID,
		arg.Name,
		arg.Description,
		arg.JobType,
		arg.Parameters,
		arg.Schedule,
		arg.IsActive,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.DomainID,
		&i.Name,
		&i.Description,
		&i.JobType,
		&i.Parameters,
		&i.Schedule,
		&i.IsActive,
		&i.LastRun,
		&i.NextRun,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const DeleteJob = `-- name: DeleteJob :exec
DELETE FROM jobs WHERE id = $1 AND domain_id = $2
`

type DeleteJobParams struct {
	ID       uuid.UUID `json:"id"`
	DomainID uuid.UUID `json:"domain_id"`
}

func (q *Queries) DeleteJob(ctx context.Context, arg DeleteJobParams) error {
	_, err := q.db.ExecContext(ctx, DeleteJob, arg.ID, arg.DomainID)
	return err
}

const DeleteJobsByDomain = `-- name: DeleteJobsByDomain :exec
DELETE FROM jobs WHERE domain_id = $1
`

func (q *Queries) DeleteJobsByDomain(ctx context.Context, domainID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteJobsByDomain, domainID)
	return err
}

const GetJob = `-- name: GetJob :one
SELECT id, domain_id, name, description, job_type, parameters, schedule, is_active, last_run, next_run, created_at, updated_at FROM jobs WHERE id = $1
`

func (q *Queries) GetJob(ctx context.Context, id uuid.UUID) (Job, error) {
	row := q.db.QueryRowContext(ctx, GetJob, id)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.DomainID,
		&i.Name,
		&i.Description,
		&i.JobType,
		&i.Parameters,
		&i.Schedule,
		&i.IsActive,
		&i.LastRun,
		&i.NextRun,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetJobByName = `-- name: GetJobByName :one
SELECT id, domain_id, name, description, job_type, parameters, schedule, is_active, last_run, next_run, created_at, updated_at FROM jobs WHERE domain_id = $1 AND name = $2
`

type GetJobByNameParams struct {
	DomainID uuid.UUID `json:"domain_id"`
	Name     string    `json:"name"`
}

func (q *Queries) GetJobByName(ctx context.Context, arg GetJobByNameParams) (Job, error) {
	row := q.db.QueryRowContext(ctx, GetJobByName, arg.DomainID, arg.Name)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.DomainID,
		&i.Name,
		&i.Description,
		&i.JobType,
		&i.Parameters,
		&i.Schedule,
		&i.IsActive,
		&i.LastRun,
		&i.NextRun,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetJobExecutionStats = `-- name: GetJobExecutionStats :one
SELECT 
    COUNT(*) as total_executions,
    COUNT(CASE WHEN status = 'completed' THEN 1 END) as successful_executions,
    COUNT(CASE WHEN status = 'failed' THEN 1 END) as failed_executions,
    AVG(execution_time_ms) as avg_execution_time,
    MAX(execution_time_ms) as max_execution_time,
    MIN(execution_time_ms) as min_execution_time
FROM job_logs 
WHERE job_id = $1
`

type GetJobExecutionStatsRow struct {
	TotalExecutions      int64       `json:"total_executions"`
	SuccessfulExecutions int64       `json:"successful_executions"`
	FailedExecutions     int64       `json:"failed_executions"`
	AvgExecutionTime     float64     `json:"avg_execution_time"`
	MaxExecutionTime     interface{} `json:"max_execution_time"`
	MinExecutionTime     interface{} `json:"min_execution_time"`
}

func (q *Queries) GetJobExecutionStats(ctx context.Context, jobID uuid.UUID) (GetJobExecutionStatsRow, error) {
	row := q.db.QueryRowContext(ctx, GetJobExecutionStats, jobID)
	var i GetJobExecutionStatsRow
	err := row.Scan(
		&i.TotalExecutions,
		&i.SuccessfulExecutions,
		&i.FailedExecutions,
		&i.AvgExecutionTime,
		&i.MaxExecutionTime,
		&i.MinExecutionTime,
	)
	return i, err
}

const GetJobPerformanceMetrics = `-- name: GetJobPerformanceMetrics :many
SELECT 
    DATE(started_at) as execution_date,
    COUNT(*) as execution_count,
    AVG(execution_time_ms) as avg_execution_time,
    COUNT(CASE WHEN status = 'failed' THEN 1 END) as failure_count
FROM job_logs 
WHERE job_id = $1 
AND started_at >= NOW() - INTERVAL '30 days'
GROUP BY DATE(started_at)
ORDER BY execution_date DESC
`

type GetJobPerformanceMetricsRow struct {
	ExecutionDate    time.Time `json:"execution_date"`
	ExecutionCount   int64     `json:"execution_count"`
	AvgExecutionTime float64   `json:"avg_execution_time"`
	FailureCount     int64     `json:"failure_count"`
}

func (q *Queries) GetJobPerformanceMetrics(ctx context.Context, jobID uuid.UUID) ([]GetJobPerformanceMetricsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetJobPerformanceMetrics, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetJobPerformanceMetricsRow{}
	for rows.Next() {
		var i GetJobPerformanceMetricsRow
		if err := rows.Scan(
			&i.ExecutionDate,
			&i.ExecutionCount,
			&i.AvgExecutionTime,
			&i.FailureCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetJobWithLogs = `-- name: GetJobWithLogs :many
SELECT j.id, j.domain_id, j.name, j.description, j.job_type, j.parameters, j.schedule, j.is_active, j.last_run, j.next_run, j.created_at, j.updated_at, jl.id, jl.job_id, jl.status, jl.message, jl.started_at, jl.completed_at, jl.execution_time_ms, jl.created_at FROM jobs j
LEFT JOIN job_logs jl ON j.id = jl.job_id
WHERE j.id = $1
ORDER BY jl.started_at DESC
`

type GetJobWithLogsRow struct {
	ID              uuid.UUID      `json:"id"`
	DomainID        uuid.UUID      `json:"domain_id"`
	Name            string         `json:"name"`
	Description     sql.NullString `json:"description"`
	JobType         string         `json:"job_type"`
	Parameters      sql.NullString `json:"parameters"`
	Schedule        sql.NullString `json:"schedule"`
	IsActive        sql.NullBool   `json:"is_active"`
	LastRun         sql.NullTime   `json:"last_run"`
	NextRun         sql.NullTime   `json:"next_run"`
	CreatedAt       sql.NullTime   `json:"created_at"`
	UpdatedAt       sql.NullTime   `json:"updated_at"`
	ID_2            uuid.NullUUID  `json:"id_2"`
	JobID           uuid.NullUUID  `json:"job_id"`
	Status          sql.NullString `json:"status"`
	Message         sql.NullString `json:"message"`
	StartedAt       sql.NullTime   `json:"started_at"`
	CompletedAt     sql.NullTime   `json:"completed_at"`
	ExecutionTimeMs sql.NullInt32  `json:"execution_time_ms"`
	CreatedAt_2     sql.NullTime   `json:"created_at_2"`
}

func (q *Queries) GetJobWithLogs(ctx context.Context, id uuid.UUID) ([]GetJobWithLogsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetJobWithLogs, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetJobWithLogsRow{}
	for rows.Next() {
		var i GetJobWithLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.DomainID,
			&i.Name,
			&i.Description,
			&i.JobType,
			&i.Parameters,
			&i.Schedule,
			&i.IsActive,
			&i.LastRun,
			&i.NextRun,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.JobID,
			&i.Status,
			&i.Message,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ExecutionTimeMs,
			&i.CreatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetJobsDueForExecution = `-- name: GetJobsDueForExecution :many
SELECT id, domain_id, name, description, job_type, parameters, schedule, is_active, last_run, next_run, created_at, updated_at FROM jobs 
WHERE domain_id = $1 
AND is_active = TRUE 
AND schedule IS NOT NULL 
AND (next_run IS NULL OR next_run <= NOW())
ORDER BY next_run ASC, name ASC
`

func (q *Queries) GetJobsDueForExecution(ctx context.Context, domainID uuid.UUID) ([]Job, error) {
	rows, err := q.db.QueryContext(ctx, GetJobsDueForExecution, domainID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Job{}
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.DomainID,
			&i.Name,
			&i.Description,
			&i.JobType,
			&i.Parameters,
			&i.Schedule,
			&i.IsActive,
			&i.LastRun,
			&i.NextRun,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListActiveJobsByDomain = `-- name: ListActiveJobsByDomain :many
SELECT id, domain_id, name, description, job_type, parameters, schedule, is_active, last_run, next_run, created_at, updated_at FROM jobs 
WHERE domain_id = $1 AND is_active = TRUE 
ORDER BY name ASC
`

func (q *Queries) ListActiveJobsByDomain(ctx context.Context, domainID uuid.UUID) ([]Job, error) {
	rows, err := q.db.QueryContext(ctx, ListActiveJobsByDomain, domainID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Job{}
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.DomainID,
			&i.Name,
			&i.Description,
			&i.JobType,
			&i.Parameters,
			&i.Schedule,
			&i.IsActive,
			&i.LastRun,
			&i.NextRun,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListAllJobs = `-- name: ListAllJobs :many
SELECT j.id, j.domain_id, j.name, j.description, j.job_type, j.parameters, j.schedule, j.is_active, j.last_run, j.next_run, j.created_at, j.updated_at, d.name as domain_name FROM jobs j
INNER JOIN domains d ON j.domain_id = d.id
ORDER BY d.name ASC, j.name ASC
`

type ListAllJobsRow struct {
	ID          uuid.UUID      `json:"id"`
	DomainID    uuid.UUID      `json:"domain_id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	JobType     string         `json:"job_type"`
	Parameters  sql.NullString `json:"parameters"`
	Schedule    sql.NullString `json:"schedule"`
	IsActive    sql.NullBool   `json:"is_active"`
	LastRun     sql.NullTime   `json:"last_run"`
	NextRun     sql.NullTime   `json:"next_run"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	UpdatedAt   sql.NullTime   `json:"updated_at"`
	DomainName  string         `json:"domain_name"`
}

func (q *Queries) ListAllJobs(ctx context.Context) ([]ListAllJobsRow, error) {
	rows, err := q.db.QueryContext(ctx, ListAllJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllJobsRow{}
	for rows.Next() {
		var i ListAllJobsRow
		if err := rows.Scan(
			&i.ID,
			&i.DomainID,
			&i.Name,
			&i.Description,
			&i.JobType,
			&i.Parameters,
			&i.Schedule,
			&i.IsActive,
			&i.LastRun,
			&i.NextRun,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DomainName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListJobsByDomain = `-- name: ListJobsByDomain :many
SELECT id, domain_id, name, description, job_type, parameters, schedule, is_active, last_run, next_run, created_at, updated_at FROM jobs 
WHERE domain_id = $1 
ORDER BY name ASC
`

func (q *Queries) ListJobsByDomain(ctx context.Context, domainID uuid.UUID) ([]Job, error) {
	rows, err := q.db.QueryContext(ctx, ListJobsByDomain, domainID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Job{}
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.DomainID,
			&i.Name,
			&i.Description,
			&i.JobType,
			&i.Parameters,
			&i.Schedule,
			&i.IsActive,
			&i.LastRun,
			&i.NextRun,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListJobsByType = `-- name: ListJobsByType :many
SELECT id, domain_id, name, description, job_type, parameters, schedule, is_active, last_run, next_run, created_at, updated_at FROM jobs 
WHERE domain_id = $1 AND job_type = $2 
ORDER BY name ASC
`

type ListJobsByTypeParams struct {
	DomainID uuid.UUID `json:"domain_id"`
	JobType  string    `json:"job_type"`
}

func (q *Queries) ListJobsByType(ctx context.Context, arg ListJobsByTypeParams) ([]Job, error) {
	rows, err := q.db.QueryContext(ctx, ListJobsByType, arg.DomainID, arg.JobType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Job{}
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.DomainID,
			&i.Name,
			&i.Description,
			&i.JobType,
			&i.Parameters,
			&i.Schedule,
			&i.IsActive,
			&i.LastRun,
			&i.NextRun,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListScheduledJobs = `-- name: ListScheduledJobs :many
SELECT id, domain_id, name, description, job_type, parameters, schedule, is_active, last_run, next_run, created_at, updated_at FROM jobs 
WHERE domain_id = $1 AND schedule IS NOT NULL AND is_active = TRUE 
ORDER BY next_run ASC
`

func (q *Queries) ListScheduledJobs(ctx context.Context, domainID uuid.UUID) ([]Job, error) {
	rows, err := q.db.QueryContext(ctx, ListScheduledJobs, domainID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Job{}
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.DomainID,
			&i.Name,
			&i.Description,
			&i.JobType,
			&i.Parameters,
			&i.Schedule,
			&i.IsActive,
			&i.LastRun,
			&i.NextRun,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchJobs = `-- name: SearchJobs :many
SELECT j.id, j.domain_id, j.name, j.description, j.job_type, j.parameters, j.schedule, j.is_active, j.last_run, j.next_run, j.created_at, j.updated_at, d.name as domain_name FROM jobs j
INNER JOIN domains d ON j.domain_id = d.id
WHERE j.name ILIKE $1 OR j.description ILIKE $1 OR j.job_type ILIKE $1
ORDER BY d.name ASC, j.name ASC
LIMIT $2 OFFSET $3
`

type SearchJobsParams struct {
	Name   string `json:"name"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type SearchJobsRow struct {
	ID          uuid.UUID      `json:"id"`
	DomainID    uuid.UUID      `json:"domain_id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	JobType     string         `json:"job_type"`
	Parameters  sql.NullString `json:"parameters"`
	Schedule    sql.NullString `json:"schedule"`
	IsActive    sql.NullBool   `json:"is_active"`
	LastRun     sql.NullTime   `json:"last_run"`
	NextRun     sql.NullTime   `json:"next_run"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	UpdatedAt   sql.NullTime   `json:"updated_at"`
	DomainName  string         `json:"domain_name"`
}

func (q *Queries) SearchJobs(ctx context.Context, arg SearchJobsParams) ([]SearchJobsRow, error) {
	rows, err := q.db.QueryContext(ctx, SearchJobs, arg.Name, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchJobsRow{}
	for rows.Next() {
		var i SearchJobsRow
		if err := rows.Scan(
			&i.ID,
			&i.DomainID,
			&i.Name,
			&i.Description,
			&i.JobType,
			&i.Parameters,
			&i.Schedule,
			&i.IsActive,
			&i.LastRun,
			&i.NextRun,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DomainName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateJob = `-- name: UpdateJob :one
UPDATE jobs 
SET 
    name = $3,
    description = $4,
    job_type = $5,
    parameters = $6,
    schedule = $7,
    is_active = $8,
    updated_at = NOW()
WHERE id = $1 AND domain_id = $2 
RETURNING id, domain_id, name, description, job_type, parameters, schedule, is_active, last_run, next_run, created_at, updated_at
`

type UpdateJobParams struct {
	ID          uuid.UUID      `json:"id"`
	DomainID    uuid.UUID      `json:"domain_id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	JobType     string         `json:"job_type"`
	Parameters  sql.NullString `json:"parameters"`
	Schedule    sql.NullString `json:"schedule"`
	IsActive    sql.NullBool   `json:"is_active"`
}

func (q *Queries) UpdateJob(ctx context.Context, arg UpdateJobParams) (Job, error) {
	row := q.db.QueryRowContext(ctx, UpdateJob,
		arg.ID,
		arg.DomainID,
		arg.Name,
		arg.Description,
		arg.JobType,
		arg.Parameters,
		arg.Schedule,
		arg.IsActive,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.DomainID,
		&i.Name,
		&i.Description,
		&i.JobType,
		&i.Parameters,
		&i.Schedule,
		&i.IsActive,
		&i.LastRun,
		&i.NextRun,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateJobLastRun = `-- name: UpdateJobLastRun :one
UPDATE jobs 
SET 
    last_run = $3,
    next_run = $4,
    updated_at = NOW()
WHERE id = $1 AND domain_id = $2 
RETURNING id, domain_id, name, description, job_type, parameters, schedule, is_active, last_run, next_run, created_at, updated_at
`

type UpdateJobLastRunParams struct {
	ID       uuid.UUID    `json:"id"`
	DomainID uuid.UUID    `json:"domain_id"`
	LastRun  sql.NullTime `json:"last_run"`
	NextRun  sql.NullTime `json:"next_run"`
}

func (q *Queries) UpdateJobLastRun(ctx context.Context, arg UpdateJobLastRunParams) (Job, error) {
	row := q.db.QueryRowContext(ctx, UpdateJobLastRun,
		arg.ID,
		arg.DomainID,
		arg.LastRun,
		arg.NextRun,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.DomainID,
		&i.Name,
		&i.Description,
		&i.JobType,
		&i.Parameters,
		&i.Schedule,
		&i.IsActive,
		&i.LastRun,
		&i.NextRun,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateJobSchedule = `-- name: UpdateJobSchedule :one
UPDATE jobs 
SET 
    schedule = $3,
    updated_at = NOW()
WHERE id = $1 AND domain_id = $2 
RETURNING id, domain_id, name, description, job_type, parameters, schedule, is_active, last_run, next_run, created_at, updated_at
`

type UpdateJobScheduleParams struct {
	ID       uuid.UUID      `json:"id"`
	DomainID uuid.UUID      `json:"domain_id"`
	Schedule sql.NullString `json:"schedule"`
}

func (q *Queries) UpdateJobSchedule(ctx context.Context, arg UpdateJobScheduleParams) (Job, error) {
	row := q.db.QueryRowContext(ctx, UpdateJobSchedule, arg.ID, arg.DomainID, arg.Schedule)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.DomainID,
		&i.Name,
		&i.Description,
		&i.JobType,
		&i.Parameters,
		&i.Schedule,
		&i.IsActive,
		&i.LastRun,
		&i.NextRun,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateJobStatus = `-- name: UpdateJobStatus :one
UPDATE jobs 
SET 
    is_active = $3,
    updated_at = NOW()
WHERE id = $1 AND domain_id = $2 
RETURNING id, domain_id, name, description, job_type, parameters, schedule, is_active, last_run, next_run, created_at, updated_at
`

type UpdateJobStatusParams struct {
	ID       uuid.UUID    `json:"id"`
	DomainID uuid.UUID    `json:"domain_id"`
	IsActive sql.NullBool `json:"is_active"`
}

func (q *Queries) UpdateJobStatus(ctx context.Context, arg UpdateJobStatusParams) (Job, error) {
	row := q.db.QueryRowContext(ctx, UpdateJobStatus, arg.ID, arg.DomainID, arg.IsActive)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.DomainID,
		&i.Name,
		&i.Description,
		&i.JobType,
		&i.Parameters,
		&i.Schedule,
		&i.IsActive,
		&i.LastRun,
		&i.NextRun,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
