// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queues.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const CountActiveQueuesByDomain = `-- name: CountActiveQueuesByDomain :one
SELECT COUNT(*) FROM queues WHERE domain_id = $1 AND is_active = TRUE
`

func (q *Queries) CountActiveQueuesByDomain(ctx context.Context, domainID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountActiveQueuesByDomain, domainID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountQueuesByDomain = `-- name: CountQueuesByDomain :one
SELECT COUNT(*) FROM queues WHERE domain_id = $1
`

func (q *Queries) CountQueuesByDomain(ctx context.Context, domainID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountQueuesByDomain, domainID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateQueue = `-- name: CreateQueue :one
INSERT INTO queues (
    domain_id, name, description, is_active, max_retries, retry_delay_seconds
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, domain_id, name, description, is_active, max_retries, retry_delay_seconds, created_at, updated_at
`

type CreateQueueParams struct {
	DomainID          uuid.UUID      `json:"domain_id"`
	Name              string         `json:"name"`
	Description       sql.NullString `json:"description"`
	IsActive          sql.NullBool   `json:"is_active"`
	MaxRetries        sql.NullInt32  `json:"max_retries"`
	RetryDelaySeconds sql.NullInt32  `json:"retry_delay_seconds"`
}

func (q *Queries) CreateQueue(ctx context.Context, arg CreateQueueParams) (Queue, error) {
	row := q.db.QueryRowContext(ctx, CreateQueue,
		arg.DomainID,
		arg.Name,
		arg.Description,
		arg.IsActive,
		arg.MaxRetries,
		arg.RetryDelaySeconds,
	)
	var i Queue
	err := row.Scan(
		&i.ID,
		&i.DomainID,
		&i.Name,
		&i.Description,
		&i.IsActive,
		&i.MaxRetries,
		&i.RetryDelaySeconds,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const DeleteQueue = `-- name: DeleteQueue :exec
DELETE FROM queues WHERE id = $1 AND domain_id = $2
`

type DeleteQueueParams struct {
	ID       uuid.UUID `json:"id"`
	DomainID uuid.UUID `json:"domain_id"`
}

func (q *Queries) DeleteQueue(ctx context.Context, arg DeleteQueueParams) error {
	_, err := q.db.ExecContext(ctx, DeleteQueue, arg.ID, arg.DomainID)
	return err
}

const DeleteQueuesByDomain = `-- name: DeleteQueuesByDomain :exec
DELETE FROM queues WHERE domain_id = $1
`

func (q *Queries) DeleteQueuesByDomain(ctx context.Context, domainID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteQueuesByDomain, domainID)
	return err
}

const GetQueue = `-- name: GetQueue :one
SELECT id, domain_id, name, description, is_active, max_retries, retry_delay_seconds, created_at, updated_at FROM queues WHERE id = $1
`

func (q *Queries) GetQueue(ctx context.Context, id uuid.UUID) (Queue, error) {
	row := q.db.QueryRowContext(ctx, GetQueue, id)
	var i Queue
	err := row.Scan(
		&i.ID,
		&i.DomainID,
		&i.Name,
		&i.Description,
		&i.IsActive,
		&i.MaxRetries,
		&i.RetryDelaySeconds,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetQueueByName = `-- name: GetQueueByName :one
SELECT id, domain_id, name, description, is_active, max_retries, retry_delay_seconds, created_at, updated_at FROM queues WHERE domain_id = $1 AND name = $2
`

type GetQueueByNameParams struct {
	DomainID uuid.UUID `json:"domain_id"`
	Name     string    `json:"name"`
}

func (q *Queries) GetQueueByName(ctx context.Context, arg GetQueueByNameParams) (Queue, error) {
	row := q.db.QueryRowContext(ctx, GetQueueByName, arg.DomainID, arg.Name)
	var i Queue
	err := row.Scan(
		&i.ID,
		&i.DomainID,
		&i.Name,
		&i.Description,
		&i.IsActive,
		&i.MaxRetries,
		&i.RetryDelaySeconds,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetQueueHealthStatus = `-- name: GetQueueHealthStatus :one
SELECT 
    q.name,
    q.is_active,
    COUNT(qi.id) as total_items,
    COUNT(CASE WHEN qi.status = 'failed' AND qi.attempts >= q.max_retries THEN 1 END) as permanently_failed,
    COUNT(CASE WHEN qi.status = 'pending' AND qi.scheduled_at < NOW() - INTERVAL '1 hour' THEN 1 END) as stale_items,
    q.max_retries,
    q.retry_delay_seconds
FROM queues q
LEFT JOIN queue_items qi ON q.id = qi.queue_id
WHERE q.id = $1
GROUP BY q.id, q.name, q.is_active, q.max_retries, q.retry_delay_seconds
`

type GetQueueHealthStatusRow struct {
	Name              string        `json:"name"`
	IsActive          sql.NullBool  `json:"is_active"`
	TotalItems        int64         `json:"total_items"`
	PermanentlyFailed int64         `json:"permanently_failed"`
	StaleItems        int64         `json:"stale_items"`
	MaxRetries        sql.NullInt32 `json:"max_retries"`
	RetryDelaySeconds sql.NullInt32 `json:"retry_delay_seconds"`
}

func (q *Queries) GetQueueHealthStatus(ctx context.Context, id uuid.UUID) (GetQueueHealthStatusRow, error) {
	row := q.db.QueryRowContext(ctx, GetQueueHealthStatus, id)
	var i GetQueueHealthStatusRow
	err := row.Scan(
		&i.Name,
		&i.IsActive,
		&i.TotalItems,
		&i.PermanentlyFailed,
		&i.StaleItems,
		&i.MaxRetries,
		&i.RetryDelaySeconds,
	)
	return i, err
}

const GetQueuePerformanceMetrics = `-- name: GetQueuePerformanceMetrics :many
SELECT 
    DATE(scheduled_at) as queue_date,
    COUNT(*) as item_count,
    COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_count,
    COUNT(CASE WHEN status = 'failed' THEN 1 END) as failed_count,
    AVG(EXTRACT(EPOCH FROM (completed_at - scheduled_at))) as avg_processing_time_seconds
FROM queue_items 
WHERE queue_id = $1 
AND scheduled_at >= NOW() - INTERVAL '30 days'
GROUP BY DATE(scheduled_at)
ORDER BY queue_date DESC
`

type GetQueuePerformanceMetricsRow struct {
	QueueDate                time.Time `json:"queue_date"`
	ItemCount                int64     `json:"item_count"`
	CompletedCount           int64     `json:"completed_count"`
	FailedCount              int64     `json:"failed_count"`
	AvgProcessingTimeSeconds float64   `json:"avg_processing_time_seconds"`
}

func (q *Queries) GetQueuePerformanceMetrics(ctx context.Context, queueID uuid.UUID) ([]GetQueuePerformanceMetricsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetQueuePerformanceMetrics, queueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetQueuePerformanceMetricsRow{}
	for rows.Next() {
		var i GetQueuePerformanceMetricsRow
		if err := rows.Scan(
			&i.QueueDate,
			&i.ItemCount,
			&i.CompletedCount,
			&i.FailedCount,
			&i.AvgProcessingTimeSeconds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetQueueStats = `-- name: GetQueueStats :one
SELECT 
    COUNT(*) as total_items,
    COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_items,
    COUNT(CASE WHEN status = 'processing' THEN 1 END) as processing_items,
    COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_items,
    COUNT(CASE WHEN status = 'failed' THEN 1 END) as failed_items,
    AVG(priority) as avg_priority
FROM queue_items 
WHERE queue_id = $1
`

type GetQueueStatsRow struct {
	TotalItems      int64   `json:"total_items"`
	PendingItems    int64   `json:"pending_items"`
	ProcessingItems int64   `json:"processing_items"`
	CompletedItems  int64   `json:"completed_items"`
	FailedItems     int64   `json:"failed_items"`
	AvgPriority     float64 `json:"avg_priority"`
}

func (q *Queries) GetQueueStats(ctx context.Context, queueID uuid.UUID) (GetQueueStatsRow, error) {
	row := q.db.QueryRowContext(ctx, GetQueueStats, queueID)
	var i GetQueueStatsRow
	err := row.Scan(
		&i.TotalItems,
		&i.PendingItems,
		&i.ProcessingItems,
		&i.CompletedItems,
		&i.FailedItems,
		&i.AvgPriority,
	)
	return i, err
}

const GetQueueWithItems = `-- name: GetQueueWithItems :many
SELECT q.id, q.domain_id, q.name, q.description, q.is_active, q.max_retries, q.retry_delay_seconds, q.created_at, q.updated_at, qi.id, qi.queue_id, qi.data, qi.priority, qi.status, qi.attempts, qi.scheduled_at, qi.started_at, qi.completed_at, qi.error_message, qi.created_at, qi.updated_at FROM queues q
LEFT JOIN queue_items qi ON q.id = qi.queue_id
WHERE q.id = $1
ORDER BY qi.priority DESC, qi.scheduled_at ASC
`

type GetQueueWithItemsRow struct {
	ID                uuid.UUID      `json:"id"`
	DomainID          uuid.UUID      `json:"domain_id"`
	Name              string         `json:"name"`
	Description       sql.NullString `json:"description"`
	IsActive          sql.NullBool   `json:"is_active"`
	MaxRetries        sql.NullInt32  `json:"max_retries"`
	RetryDelaySeconds sql.NullInt32  `json:"retry_delay_seconds"`
	CreatedAt         sql.NullTime   `json:"created_at"`
	UpdatedAt         sql.NullTime   `json:"updated_at"`
	ID_2              uuid.NullUUID  `json:"id_2"`
	QueueID           uuid.NullUUID  `json:"queue_id"`
	Data              sql.NullString `json:"data"`
	Priority          sql.NullInt32  `json:"priority"`
	Status            sql.NullString `json:"status"`
	Attempts          sql.NullInt32  `json:"attempts"`
	ScheduledAt       sql.NullTime   `json:"scheduled_at"`
	StartedAt         sql.NullTime   `json:"started_at"`
	CompletedAt       sql.NullTime   `json:"completed_at"`
	ErrorMessage      sql.NullString `json:"error_message"`
	CreatedAt_2       sql.NullTime   `json:"created_at_2"`
	UpdatedAt_2       sql.NullTime   `json:"updated_at_2"`
}

func (q *Queries) GetQueueWithItems(ctx context.Context, id uuid.UUID) ([]GetQueueWithItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetQueueWithItems, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetQueueWithItemsRow{}
	for rows.Next() {
		var i GetQueueWithItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.DomainID,
			&i.Name,
			&i.Description,
			&i.IsActive,
			&i.MaxRetries,
			&i.RetryDelaySeconds,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.QueueID,
			&i.Data,
			&i.Priority,
			&i.Status,
			&i.Attempts,
			&i.ScheduledAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ErrorMessage,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListActiveQueuesByDomain = `-- name: ListActiveQueuesByDomain :many
SELECT id, domain_id, name, description, is_active, max_retries, retry_delay_seconds, created_at, updated_at FROM queues 
WHERE domain_id = $1 AND is_active = TRUE 
ORDER BY name ASC
`

func (q *Queries) ListActiveQueuesByDomain(ctx context.Context, domainID uuid.UUID) ([]Queue, error) {
	rows, err := q.db.QueryContext(ctx, ListActiveQueuesByDomain, domainID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Queue{}
	for rows.Next() {
		var i Queue
		if err := rows.Scan(
			&i.ID,
			&i.DomainID,
			&i.Name,
			&i.Description,
			&i.IsActive,
			&i.MaxRetries,
			&i.RetryDelaySeconds,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListAllQueues = `-- name: ListAllQueues :many
SELECT q.id, q.domain_id, q.name, q.description, q.is_active, q.max_retries, q.retry_delay_seconds, q.created_at, q.updated_at, d.name as domain_name FROM queues q
INNER JOIN domains d ON q.domain_id = d.id
ORDER BY d.name ASC, q.name ASC
`

type ListAllQueuesRow struct {
	ID                uuid.UUID      `json:"id"`
	DomainID          uuid.UUID      `json:"domain_id"`
	Name              string         `json:"name"`
	Description       sql.NullString `json:"description"`
	IsActive          sql.NullBool   `json:"is_active"`
	MaxRetries        sql.NullInt32  `json:"max_retries"`
	RetryDelaySeconds sql.NullInt32  `json:"retry_delay_seconds"`
	CreatedAt         sql.NullTime   `json:"created_at"`
	UpdatedAt         sql.NullTime   `json:"updated_at"`
	DomainName        string         `json:"domain_name"`
}

func (q *Queries) ListAllQueues(ctx context.Context) ([]ListAllQueuesRow, error) {
	rows, err := q.db.QueryContext(ctx, ListAllQueues)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllQueuesRow{}
	for rows.Next() {
		var i ListAllQueuesRow
		if err := rows.Scan(
			&i.ID,
			&i.DomainID,
			&i.Name,
			&i.Description,
			&i.IsActive,
			&i.MaxRetries,
			&i.RetryDelaySeconds,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DomainName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListQueuesByDomain = `-- name: ListQueuesByDomain :many
SELECT id, domain_id, name, description, is_active, max_retries, retry_delay_seconds, created_at, updated_at FROM queues 
WHERE domain_id = $1 
ORDER BY name ASC
`

func (q *Queries) ListQueuesByDomain(ctx context.Context, domainID uuid.UUID) ([]Queue, error) {
	rows, err := q.db.QueryContext(ctx, ListQueuesByDomain, domainID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Queue{}
	for rows.Next() {
		var i Queue
		if err := rows.Scan(
			&i.ID,
			&i.DomainID,
			&i.Name,
			&i.Description,
			&i.IsActive,
			&i.MaxRetries,
			&i.RetryDelaySeconds,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchQueues = `-- name: SearchQueues :many
SELECT q.id, q.domain_id, q.name, q.description, q.is_active, q.max_retries, q.retry_delay_seconds, q.created_at, q.updated_at, d.name as domain_name FROM queues q
INNER JOIN domains d ON q.domain_id = d.id
WHERE q.name ILIKE $1 OR q.description ILIKE $1
ORDER BY d.name ASC, q.name ASC
LIMIT $2 OFFSET $3
`

type SearchQueuesParams struct {
	Name   string `json:"name"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type SearchQueuesRow struct {
	ID                uuid.UUID      `json:"id"`
	DomainID          uuid.UUID      `json:"domain_id"`
	Name              string         `json:"name"`
	Description       sql.NullString `json:"description"`
	IsActive          sql.NullBool   `json:"is_active"`
	MaxRetries        sql.NullInt32  `json:"max_retries"`
	RetryDelaySeconds sql.NullInt32  `json:"retry_delay_seconds"`
	CreatedAt         sql.NullTime   `json:"created_at"`
	UpdatedAt         sql.NullTime   `json:"updated_at"`
	DomainName        string         `json:"domain_name"`
}

func (q *Queries) SearchQueues(ctx context.Context, arg SearchQueuesParams) ([]SearchQueuesRow, error) {
	rows, err := q.db.QueryContext(ctx, SearchQueues, arg.Name, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchQueuesRow{}
	for rows.Next() {
		var i SearchQueuesRow
		if err := rows.Scan(
			&i.ID,
			&i.DomainID,
			&i.Name,
			&i.Description,
			&i.IsActive,
			&i.MaxRetries,
			&i.RetryDelaySeconds,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DomainName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateQueue = `-- name: UpdateQueue :one
UPDATE queues 
SET 
    name = $3,
    description = $4,
    is_active = $5,
    max_retries = $6,
    retry_delay_seconds = $7,
    updated_at = NOW()
WHERE id = $1 AND domain_id = $2 
RETURNING id, domain_id, name, description, is_active, max_retries, retry_delay_seconds, created_at, updated_at
`

type UpdateQueueParams struct {
	ID                uuid.UUID      `json:"id"`
	DomainID          uuid.UUID      `json:"domain_id"`
	Name              string         `json:"name"`
	Description       sql.NullString `json:"description"`
	IsActive          sql.NullBool   `json:"is_active"`
	MaxRetries        sql.NullInt32  `json:"max_retries"`
	RetryDelaySeconds sql.NullInt32  `json:"retry_delay_seconds"`
}

func (q *Queries) UpdateQueue(ctx context.Context, arg UpdateQueueParams) (Queue, error) {
	row := q.db.QueryRowContext(ctx, UpdateQueue,
		arg.ID,
		arg.DomainID,
		arg.Name,
		arg.Description,
		arg.IsActive,
		arg.MaxRetries,
		arg.RetryDelaySeconds,
	)
	var i Queue
	err := row.Scan(
		&i.ID,
		&i.DomainID,
		&i.Name,
		&i.Description,
		&i.IsActive,
		&i.MaxRetries,
		&i.RetryDelaySeconds,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateQueueStatus = `-- name: UpdateQueueStatus :one
UPDATE queues 
SET 
    is_active = $3,
    updated_at = NOW()
WHERE id = $1 AND domain_id = $2 
RETURNING id, domain_id, name, description, is_active, max_retries, retry_delay_seconds, created_at, updated_at
`

type UpdateQueueStatusParams struct {
	ID       uuid.UUID    `json:"id"`
	DomainID uuid.UUID    `json:"domain_id"`
	IsActive sql.NullBool `json:"is_active"`
}

func (q *Queries) UpdateQueueStatus(ctx context.Context, arg UpdateQueueStatusParams) (Queue, error) {
	row := q.db.QueryRowContext(ctx, UpdateQueueStatus, arg.ID, arg.DomainID, arg.IsActive)
	var i Queue
	err := row.Scan(
		&i.ID,
		&i.DomainID,
		&i.Name,
		&i.Description,
		&i.IsActive,
		&i.MaxRetries,
		&i.RetryDelaySeconds,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
