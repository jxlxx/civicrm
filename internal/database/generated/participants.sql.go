// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: participants.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const CountParticipants = `-- name: CountParticipants :one
SELECT COUNT(*) FROM participants
`

func (q *Queries) CountParticipants(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountParticipants)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountParticipantsByCampaign = `-- name: CountParticipantsByCampaign :one
SELECT COUNT(*) FROM participants WHERE campaign_id = $1
`

func (q *Queries) CountParticipantsByCampaign(ctx context.Context, campaignID uuid.NullUUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountParticipantsByCampaign, campaignID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountParticipantsByContact = `-- name: CountParticipantsByContact :one
SELECT COUNT(*) FROM participants WHERE contact_id = $1
`

func (q *Queries) CountParticipantsByContact(ctx context.Context, contactID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountParticipantsByContact, contactID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountParticipantsByEvent = `-- name: CountParticipantsByEvent :one
SELECT COUNT(*) FROM participants WHERE event_id = $1
`

func (q *Queries) CountParticipantsByEvent(ctx context.Context, eventID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountParticipantsByEvent, eventID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountParticipantsByStatus = `-- name: CountParticipantsByStatus :one
SELECT COUNT(*) FROM participants WHERE status_id = $1
`

func (q *Queries) CountParticipantsByStatus(ctx context.Context, statusID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountParticipantsByStatus, statusID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateParticipant = `-- name: CreateParticipant :one
INSERT INTO participants (
    event_id, contact_id, status_id, role_id, register_date, source,
    fee_level, is_test, is_pay_later, fee_amount, registered_by_id,
    discount_id, fee_currency, campaign_id, discount_amount, cart_id, must_wait
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17
) RETURNING id, event_id, contact_id, status_id, role_id, register_date, source, fee_level, is_test, is_pay_later, fee_amount, registered_by_id, discount_id, fee_currency, campaign_id, discount_amount, cart_id, must_wait, created_at, updated_at
`

type CreateParticipantParams struct {
	EventID        uuid.UUID      `json:"event_id"`
	ContactID      uuid.UUID      `json:"contact_id"`
	StatusID       uuid.UUID      `json:"status_id"`
	RoleID         uuid.NullUUID  `json:"role_id"`
	RegisterDate   sql.NullTime   `json:"register_date"`
	Source         sql.NullString `json:"source"`
	FeeLevel       sql.NullString `json:"fee_level"`
	IsTest         sql.NullBool   `json:"is_test"`
	IsPayLater     sql.NullBool   `json:"is_pay_later"`
	FeeAmount      sql.NullString `json:"fee_amount"`
	RegisteredByID uuid.NullUUID  `json:"registered_by_id"`
	DiscountID     uuid.NullUUID  `json:"discount_id"`
	FeeCurrency    sql.NullString `json:"fee_currency"`
	CampaignID     uuid.NullUUID  `json:"campaign_id"`
	DiscountAmount sql.NullString `json:"discount_amount"`
	CartID         uuid.NullUUID  `json:"cart_id"`
	MustWait       sql.NullBool   `json:"must_wait"`
}

func (q *Queries) CreateParticipant(ctx context.Context, arg CreateParticipantParams) (Participant, error) {
	row := q.db.QueryRowContext(ctx, CreateParticipant,
		arg.EventID,
		arg.ContactID,
		arg.StatusID,
		arg.RoleID,
		arg.RegisterDate,
		arg.Source,
		arg.FeeLevel,
		arg.IsTest,
		arg.IsPayLater,
		arg.FeeAmount,
		arg.RegisteredByID,
		arg.DiscountID,
		arg.FeeCurrency,
		arg.CampaignID,
		arg.DiscountAmount,
		arg.CartID,
		arg.MustWait,
	)
	var i Participant
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.ContactID,
		&i.StatusID,
		&i.RoleID,
		&i.RegisterDate,
		&i.Source,
		&i.FeeLevel,
		&i.IsTest,
		&i.IsPayLater,
		&i.FeeAmount,
		&i.RegisteredByID,
		&i.DiscountID,
		&i.FeeCurrency,
		&i.CampaignID,
		&i.DiscountAmount,
		&i.CartID,
		&i.MustWait,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const DeleteParticipant = `-- name: DeleteParticipant :exec
DELETE FROM participants WHERE id = $1
`

func (q *Queries) DeleteParticipant(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteParticipant, id)
	return err
}

const GetParticipant = `-- name: GetParticipant :one
SELECT id, event_id, contact_id, status_id, role_id, register_date, source, fee_level, is_test, is_pay_later, fee_amount, registered_by_id, discount_id, fee_currency, campaign_id, discount_amount, cart_id, must_wait, created_at, updated_at FROM participants WHERE id = $1
`

func (q *Queries) GetParticipant(ctx context.Context, id uuid.UUID) (Participant, error) {
	row := q.db.QueryRowContext(ctx, GetParticipant, id)
	var i Participant
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.ContactID,
		&i.StatusID,
		&i.RoleID,
		&i.RegisterDate,
		&i.Source,
		&i.FeeLevel,
		&i.IsTest,
		&i.IsPayLater,
		&i.FeeAmount,
		&i.RegisteredByID,
		&i.DiscountID,
		&i.FeeCurrency,
		&i.CampaignID,
		&i.DiscountAmount,
		&i.CartID,
		&i.MustWait,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetParticipantByEventAndContact = `-- name: GetParticipantByEventAndContact :one
SELECT id, event_id, contact_id, status_id, role_id, register_date, source, fee_level, is_test, is_pay_later, fee_amount, registered_by_id, discount_id, fee_currency, campaign_id, discount_amount, cart_id, must_wait, created_at, updated_at FROM participants 
WHERE event_id = $1 AND contact_id = $2
`

type GetParticipantByEventAndContactParams struct {
	EventID   uuid.UUID `json:"event_id"`
	ContactID uuid.UUID `json:"contact_id"`
}

func (q *Queries) GetParticipantByEventAndContact(ctx context.Context, arg GetParticipantByEventAndContactParams) (Participant, error) {
	row := q.db.QueryRowContext(ctx, GetParticipantByEventAndContact, arg.EventID, arg.ContactID)
	var i Participant
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.ContactID,
		&i.StatusID,
		&i.RoleID,
		&i.RegisterDate,
		&i.Source,
		&i.FeeLevel,
		&i.IsTest,
		&i.IsPayLater,
		&i.FeeAmount,
		&i.RegisteredByID,
		&i.DiscountID,
		&i.FeeCurrency,
		&i.CampaignID,
		&i.DiscountAmount,
		&i.CartID,
		&i.MustWait,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetParticipantsByCampaign = `-- name: GetParticipantsByCampaign :many
SELECT id, event_id, contact_id, status_id, role_id, register_date, source, fee_level, is_test, is_pay_later, fee_amount, registered_by_id, discount_id, fee_currency, campaign_id, discount_amount, cart_id, must_wait, created_at, updated_at FROM participants 
WHERE campaign_id = $1
ORDER BY register_date DESC
`

func (q *Queries) GetParticipantsByCampaign(ctx context.Context, campaignID uuid.NullUUID) ([]Participant, error) {
	rows, err := q.db.QueryContext(ctx, GetParticipantsByCampaign, campaignID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Participant{}
	for rows.Next() {
		var i Participant
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.ContactID,
			&i.StatusID,
			&i.RoleID,
			&i.RegisterDate,
			&i.Source,
			&i.FeeLevel,
			&i.IsTest,
			&i.IsPayLater,
			&i.FeeAmount,
			&i.RegisteredByID,
			&i.DiscountID,
			&i.FeeCurrency,
			&i.CampaignID,
			&i.DiscountAmount,
			&i.CartID,
			&i.MustWait,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetParticipantsByContact = `-- name: GetParticipantsByContact :many
SELECT id, event_id, contact_id, status_id, role_id, register_date, source, fee_level, is_test, is_pay_later, fee_amount, registered_by_id, discount_id, fee_currency, campaign_id, discount_amount, cart_id, must_wait, created_at, updated_at FROM participants 
WHERE contact_id = $1
ORDER BY register_date DESC
`

func (q *Queries) GetParticipantsByContact(ctx context.Context, contactID uuid.UUID) ([]Participant, error) {
	rows, err := q.db.QueryContext(ctx, GetParticipantsByContact, contactID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Participant{}
	for rows.Next() {
		var i Participant
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.ContactID,
			&i.StatusID,
			&i.RoleID,
			&i.RegisterDate,
			&i.Source,
			&i.FeeLevel,
			&i.IsTest,
			&i.IsPayLater,
			&i.FeeAmount,
			&i.RegisteredByID,
			&i.DiscountID,
			&i.FeeCurrency,
			&i.CampaignID,
			&i.DiscountAmount,
			&i.CartID,
			&i.MustWait,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetParticipantsByEvent = `-- name: GetParticipantsByEvent :many
SELECT id, event_id, contact_id, status_id, role_id, register_date, source, fee_level, is_test, is_pay_later, fee_amount, registered_by_id, discount_id, fee_currency, campaign_id, discount_amount, cart_id, must_wait, created_at, updated_at FROM participants 
WHERE event_id = $1
ORDER BY register_date
`

func (q *Queries) GetParticipantsByEvent(ctx context.Context, eventID uuid.UUID) ([]Participant, error) {
	rows, err := q.db.QueryContext(ctx, GetParticipantsByEvent, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Participant{}
	for rows.Next() {
		var i Participant
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.ContactID,
			&i.StatusID,
			&i.RoleID,
			&i.RegisterDate,
			&i.Source,
			&i.FeeLevel,
			&i.IsTest,
			&i.IsPayLater,
			&i.FeeAmount,
			&i.RegisteredByID,
			&i.DiscountID,
			&i.FeeCurrency,
			&i.CampaignID,
			&i.DiscountAmount,
			&i.CartID,
			&i.MustWait,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetParticipantsByStatus = `-- name: GetParticipantsByStatus :many
SELECT id, event_id, contact_id, status_id, role_id, register_date, source, fee_level, is_test, is_pay_later, fee_amount, registered_by_id, discount_id, fee_currency, campaign_id, discount_amount, cart_id, must_wait, created_at, updated_at FROM participants 
WHERE status_id = $1
ORDER BY register_date DESC
`

func (q *Queries) GetParticipantsByStatus(ctx context.Context, statusID uuid.UUID) ([]Participant, error) {
	rows, err := q.db.QueryContext(ctx, GetParticipantsByStatus, statusID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Participant{}
	for rows.Next() {
		var i Participant
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.ContactID,
			&i.StatusID,
			&i.RoleID,
			&i.RegisterDate,
			&i.Source,
			&i.FeeLevel,
			&i.IsTest,
			&i.IsPayLater,
			&i.FeeAmount,
			&i.RegisteredByID,
			&i.DiscountID,
			&i.FeeCurrency,
			&i.CampaignID,
			&i.DiscountAmount,
			&i.CartID,
			&i.MustWait,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListAllParticipants = `-- name: ListAllParticipants :many
SELECT id, event_id, contact_id, status_id, role_id, register_date, source, fee_level, is_test, is_pay_later, fee_amount, registered_by_id, discount_id, fee_currency, campaign_id, discount_amount, cart_id, must_wait, created_at, updated_at FROM participants 
ORDER BY register_date DESC
`

func (q *Queries) ListAllParticipants(ctx context.Context) ([]Participant, error) {
	rows, err := q.db.QueryContext(ctx, ListAllParticipants)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Participant{}
	for rows.Next() {
		var i Participant
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.ContactID,
			&i.StatusID,
			&i.RoleID,
			&i.RegisterDate,
			&i.Source,
			&i.FeeLevel,
			&i.IsTest,
			&i.IsPayLater,
			&i.FeeAmount,
			&i.RegisteredByID,
			&i.DiscountID,
			&i.FeeCurrency,
			&i.CampaignID,
			&i.DiscountAmount,
			&i.CartID,
			&i.MustWait,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListTestParticipants = `-- name: ListTestParticipants :many
SELECT id, event_id, contact_id, status_id, role_id, register_date, source, fee_level, is_test, is_pay_later, fee_amount, registered_by_id, discount_id, fee_currency, campaign_id, discount_amount, cart_id, must_wait, created_at, updated_at FROM participants 
WHERE is_test = $1
ORDER BY register_date DESC
`

func (q *Queries) ListTestParticipants(ctx context.Context, isTest sql.NullBool) ([]Participant, error) {
	rows, err := q.db.QueryContext(ctx, ListTestParticipants, isTest)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Participant{}
	for rows.Next() {
		var i Participant
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.ContactID,
			&i.StatusID,
			&i.RoleID,
			&i.RegisterDate,
			&i.Source,
			&i.FeeLevel,
			&i.IsTest,
			&i.IsPayLater,
			&i.FeeAmount,
			&i.RegisteredByID,
			&i.DiscountID,
			&i.FeeCurrency,
			&i.CampaignID,
			&i.DiscountAmount,
			&i.CartID,
			&i.MustWait,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchParticipants = `-- name: SearchParticipants :many
SELECT id, event_id, contact_id, status_id, role_id, register_date, source, fee_level, is_test, is_pay_later, fee_amount, registered_by_id, discount_id, fee_currency, campaign_id, discount_amount, cart_id, must_wait, created_at, updated_at FROM participants 
WHERE (source ILIKE $1 OR fee_level ILIKE $1)
ORDER BY register_date DESC
`

func (q *Queries) SearchParticipants(ctx context.Context, source sql.NullString) ([]Participant, error) {
	rows, err := q.db.QueryContext(ctx, SearchParticipants, source)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Participant{}
	for rows.Next() {
		var i Participant
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.ContactID,
			&i.StatusID,
			&i.RoleID,
			&i.RegisterDate,
			&i.Source,
			&i.FeeLevel,
			&i.IsTest,
			&i.IsPayLater,
			&i.FeeAmount,
			&i.RegisteredByID,
			&i.DiscountID,
			&i.FeeCurrency,
			&i.CampaignID,
			&i.DiscountAmount,
			&i.CartID,
			&i.MustWait,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateParticipant = `-- name: UpdateParticipant :one
UPDATE participants SET
    event_id = $2, contact_id = $3, status_id = $4, role_id = $5,
    register_date = $6, source = $7, fee_level = $8, is_test = $9,
    is_pay_later = $10, fee_amount = $11, registered_by_id = $12,
    discount_id = $13, fee_currency = $14, campaign_id = $15,
    discount_amount = $16, cart_id = $17, must_wait = $18, updated_at = NOW()
WHERE id = $1 RETURNING id, event_id, contact_id, status_id, role_id, register_date, source, fee_level, is_test, is_pay_later, fee_amount, registered_by_id, discount_id, fee_currency, campaign_id, discount_amount, cart_id, must_wait, created_at, updated_at
`

type UpdateParticipantParams struct {
	ID             uuid.UUID      `json:"id"`
	EventID        uuid.UUID      `json:"event_id"`
	ContactID      uuid.UUID      `json:"contact_id"`
	StatusID       uuid.UUID      `json:"status_id"`
	RoleID         uuid.NullUUID  `json:"role_id"`
	RegisterDate   sql.NullTime   `json:"register_date"`
	Source         sql.NullString `json:"source"`
	FeeLevel       sql.NullString `json:"fee_level"`
	IsTest         sql.NullBool   `json:"is_test"`
	IsPayLater     sql.NullBool   `json:"is_pay_later"`
	FeeAmount      sql.NullString `json:"fee_amount"`
	RegisteredByID uuid.NullUUID  `json:"registered_by_id"`
	DiscountID     uuid.NullUUID  `json:"discount_id"`
	FeeCurrency    sql.NullString `json:"fee_currency"`
	CampaignID     uuid.NullUUID  `json:"campaign_id"`
	DiscountAmount sql.NullString `json:"discount_amount"`
	CartID         uuid.NullUUID  `json:"cart_id"`
	MustWait       sql.NullBool   `json:"must_wait"`
}

func (q *Queries) UpdateParticipant(ctx context.Context, arg UpdateParticipantParams) (Participant, error) {
	row := q.db.QueryRowContext(ctx, UpdateParticipant,
		arg.ID,
		arg.EventID,
		arg.ContactID,
		arg.StatusID,
		arg.RoleID,
		arg.RegisterDate,
		arg.Source,
		arg.FeeLevel,
		arg.IsTest,
		arg.IsPayLater,
		arg.FeeAmount,
		arg.RegisteredByID,
		arg.DiscountID,
		arg.FeeCurrency,
		arg.CampaignID,
		arg.DiscountAmount,
		arg.CartID,
		arg.MustWait,
	)
	var i Participant
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.ContactID,
		&i.StatusID,
		&i.RoleID,
		&i.RegisterDate,
		&i.Source,
		&i.FeeLevel,
		&i.IsTest,
		&i.IsPayLater,
		&i.FeeAmount,
		&i.RegisteredByID,
		&i.DiscountID,
		&i.FeeCurrency,
		&i.CampaignID,
		&i.DiscountAmount,
		&i.CartID,
		&i.MustWait,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
