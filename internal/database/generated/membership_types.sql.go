// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: membership_types.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const ActivateMembershipType = `-- name: ActivateMembershipType :exec
UPDATE membership_types SET is_active = TRUE, updated_at = NOW() WHERE id = $1
`

func (q *Queries) ActivateMembershipType(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, ActivateMembershipType, id)
	return err
}

const CreateMembershipType = `-- name: CreateMembershipType :one
INSERT INTO membership_types (
    name, description, member_of_contact_id, financial_type_id, minimum_fee,
    duration_unit, duration_interval, period_type, fixed_period_start_day,
    fixed_period_rollover_day, relationship_type_id, relationship_direction,
    visibility, weight, is_active, is_reserved
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16
) RETURNING id, name, description, member_of_contact_id, financial_type_id, minimum_fee, duration_unit, duration_interval, period_type, fixed_period_start_day, fixed_period_rollover_day, relationship_type_id, relationship_direction, visibility, weight, is_active, is_reserved, created_at, updated_at
`

type CreateMembershipTypeParams struct {
	Name                   string         `json:"name"`
	Description            sql.NullString `json:"description"`
	MemberOfContactID      uuid.NullUUID  `json:"member_of_contact_id"`
	FinancialTypeID        uuid.NullUUID  `json:"financial_type_id"`
	MinimumFee             sql.NullString `json:"minimum_fee"`
	DurationUnit           string         `json:"duration_unit"`
	DurationInterval       int32          `json:"duration_interval"`
	PeriodType             string         `json:"period_type"`
	FixedPeriodStartDay    sql.NullInt32  `json:"fixed_period_start_day"`
	FixedPeriodRolloverDay sql.NullInt32  `json:"fixed_period_rollover_day"`
	RelationshipTypeID     uuid.NullUUID  `json:"relationship_type_id"`
	RelationshipDirection  sql.NullString `json:"relationship_direction"`
	Visibility             sql.NullString `json:"visibility"`
	Weight                 sql.NullInt32  `json:"weight"`
	IsActive               sql.NullBool   `json:"is_active"`
	IsReserved             sql.NullBool   `json:"is_reserved"`
}

func (q *Queries) CreateMembershipType(ctx context.Context, arg CreateMembershipTypeParams) (MembershipType, error) {
	row := q.db.QueryRowContext(ctx, CreateMembershipType,
		arg.Name,
		arg.Description,
		arg.MemberOfContactID,
		arg.FinancialTypeID,
		arg.MinimumFee,
		arg.DurationUnit,
		arg.DurationInterval,
		arg.PeriodType,
		arg.FixedPeriodStartDay,
		arg.FixedPeriodRolloverDay,
		arg.RelationshipTypeID,
		arg.RelationshipDirection,
		arg.Visibility,
		arg.Weight,
		arg.IsActive,
		arg.IsReserved,
	)
	var i MembershipType
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.MemberOfContactID,
		&i.FinancialTypeID,
		&i.MinimumFee,
		&i.DurationUnit,
		&i.DurationInterval,
		&i.PeriodType,
		&i.FixedPeriodStartDay,
		&i.FixedPeriodRolloverDay,
		&i.RelationshipTypeID,
		&i.RelationshipDirection,
		&i.Visibility,
		&i.Weight,
		&i.IsActive,
		&i.IsReserved,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const DeactivateMembershipType = `-- name: DeactivateMembershipType :exec
UPDATE membership_types SET is_active = FALSE, updated_at = NOW() WHERE id = $1
`

func (q *Queries) DeactivateMembershipType(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeactivateMembershipType, id)
	return err
}

const DeleteMembershipType = `-- name: DeleteMembershipType :exec
DELETE FROM membership_types WHERE id = $1
`

func (q *Queries) DeleteMembershipType(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteMembershipType, id)
	return err
}

const GetMembershipType = `-- name: GetMembershipType :one
SELECT id, name, description, member_of_contact_id, financial_type_id, minimum_fee, duration_unit, duration_interval, period_type, fixed_period_start_day, fixed_period_rollover_day, relationship_type_id, relationship_direction, visibility, weight, is_active, is_reserved, created_at, updated_at FROM membership_types WHERE id = $1
`

func (q *Queries) GetMembershipType(ctx context.Context, id uuid.UUID) (MembershipType, error) {
	row := q.db.QueryRowContext(ctx, GetMembershipType, id)
	var i MembershipType
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.MemberOfContactID,
		&i.FinancialTypeID,
		&i.MinimumFee,
		&i.DurationUnit,
		&i.DurationInterval,
		&i.PeriodType,
		&i.FixedPeriodStartDay,
		&i.FixedPeriodRolloverDay,
		&i.RelationshipTypeID,
		&i.RelationshipDirection,
		&i.Visibility,
		&i.Weight,
		&i.IsActive,
		&i.IsReserved,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetMembershipTypeByName = `-- name: GetMembershipTypeByName :one
SELECT id, name, description, member_of_contact_id, financial_type_id, minimum_fee, duration_unit, duration_interval, period_type, fixed_period_start_day, fixed_period_rollover_day, relationship_type_id, relationship_direction, visibility, weight, is_active, is_reserved, created_at, updated_at FROM membership_types WHERE name = $1
`

func (q *Queries) GetMembershipTypeByName(ctx context.Context, name string) (MembershipType, error) {
	row := q.db.QueryRowContext(ctx, GetMembershipTypeByName, name)
	var i MembershipType
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.MemberOfContactID,
		&i.FinancialTypeID,
		&i.MinimumFee,
		&i.DurationUnit,
		&i.DurationInterval,
		&i.PeriodType,
		&i.FixedPeriodStartDay,
		&i.FixedPeriodRolloverDay,
		&i.RelationshipTypeID,
		&i.RelationshipDirection,
		&i.Visibility,
		&i.Weight,
		&i.IsActive,
		&i.IsReserved,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const ListMembershipTypes = `-- name: ListMembershipTypes :many
SELECT id, name, description, member_of_contact_id, financial_type_id, minimum_fee, duration_unit, duration_interval, period_type, fixed_period_start_day, fixed_period_rollover_day, relationship_type_id, relationship_direction, visibility, weight, is_active, is_reserved, created_at, updated_at FROM membership_types 
WHERE is_active = $1 
ORDER BY weight, name
`

func (q *Queries) ListMembershipTypes(ctx context.Context, isActive sql.NullBool) ([]MembershipType, error) {
	rows, err := q.db.QueryContext(ctx, ListMembershipTypes, isActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MembershipType{}
	for rows.Next() {
		var i MembershipType
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MemberOfContactID,
			&i.FinancialTypeID,
			&i.MinimumFee,
			&i.DurationUnit,
			&i.DurationInterval,
			&i.PeriodType,
			&i.FixedPeriodStartDay,
			&i.FixedPeriodRolloverDay,
			&i.RelationshipTypeID,
			&i.RelationshipDirection,
			&i.Visibility,
			&i.Weight,
			&i.IsActive,
			&i.IsReserved,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListMembershipTypesByPeriodType = `-- name: ListMembershipTypesByPeriodType :many
SELECT id, name, description, member_of_contact_id, financial_type_id, minimum_fee, duration_unit, duration_interval, period_type, fixed_period_start_day, fixed_period_rollover_day, relationship_type_id, relationship_direction, visibility, weight, is_active, is_reserved, created_at, updated_at FROM membership_types 
WHERE period_type = $1 AND is_active = $2 
ORDER BY weight, name
`

type ListMembershipTypesByPeriodTypeParams struct {
	PeriodType string       `json:"period_type"`
	IsActive   sql.NullBool `json:"is_active"`
}

func (q *Queries) ListMembershipTypesByPeriodType(ctx context.Context, arg ListMembershipTypesByPeriodTypeParams) ([]MembershipType, error) {
	rows, err := q.db.QueryContext(ctx, ListMembershipTypesByPeriodType, arg.PeriodType, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MembershipType{}
	for rows.Next() {
		var i MembershipType
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MemberOfContactID,
			&i.FinancialTypeID,
			&i.MinimumFee,
			&i.DurationUnit,
			&i.DurationInterval,
			&i.PeriodType,
			&i.FixedPeriodStartDay,
			&i.FixedPeriodRolloverDay,
			&i.RelationshipTypeID,
			&i.RelationshipDirection,
			&i.Visibility,
			&i.Weight,
			&i.IsActive,
			&i.IsReserved,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListMembershipTypesByVisibility = `-- name: ListMembershipTypesByVisibility :many
SELECT id, name, description, member_of_contact_id, financial_type_id, minimum_fee, duration_unit, duration_interval, period_type, fixed_period_start_day, fixed_period_rollover_day, relationship_type_id, relationship_direction, visibility, weight, is_active, is_reserved, created_at, updated_at FROM membership_types 
WHERE visibility = $1 AND is_active = $2 
ORDER BY weight, name
`

type ListMembershipTypesByVisibilityParams struct {
	Visibility sql.NullString `json:"visibility"`
	IsActive   sql.NullBool   `json:"is_active"`
}

func (q *Queries) ListMembershipTypesByVisibility(ctx context.Context, arg ListMembershipTypesByVisibilityParams) ([]MembershipType, error) {
	rows, err := q.db.QueryContext(ctx, ListMembershipTypesByVisibility, arg.Visibility, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MembershipType{}
	for rows.Next() {
		var i MembershipType
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MemberOfContactID,
			&i.FinancialTypeID,
			&i.MinimumFee,
			&i.DurationUnit,
			&i.DurationInterval,
			&i.PeriodType,
			&i.FixedPeriodStartDay,
			&i.FixedPeriodRolloverDay,
			&i.RelationshipTypeID,
			&i.RelationshipDirection,
			&i.Visibility,
			&i.Weight,
			&i.IsActive,
			&i.IsReserved,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchMembershipTypes = `-- name: SearchMembershipTypes :many
SELECT id, name, description, member_of_contact_id, financial_type_id, minimum_fee, duration_unit, duration_interval, period_type, fixed_period_start_day, fixed_period_rollover_day, relationship_type_id, relationship_direction, visibility, weight, is_active, is_reserved, created_at, updated_at FROM membership_types 
WHERE (name ILIKE $1 OR description ILIKE $1) 
AND is_active = $2 
ORDER BY weight, name
`

type SearchMembershipTypesParams struct {
	Name     string       `json:"name"`
	IsActive sql.NullBool `json:"is_active"`
}

func (q *Queries) SearchMembershipTypes(ctx context.Context, arg SearchMembershipTypesParams) ([]MembershipType, error) {
	rows, err := q.db.QueryContext(ctx, SearchMembershipTypes, arg.Name, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MembershipType{}
	for rows.Next() {
		var i MembershipType
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MemberOfContactID,
			&i.FinancialTypeID,
			&i.MinimumFee,
			&i.DurationUnit,
			&i.DurationInterval,
			&i.PeriodType,
			&i.FixedPeriodStartDay,
			&i.FixedPeriodRolloverDay,
			&i.RelationshipTypeID,
			&i.RelationshipDirection,
			&i.Visibility,
			&i.Weight,
			&i.IsActive,
			&i.IsReserved,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateMembershipType = `-- name: UpdateMembershipType :one
UPDATE membership_types SET
    name = $2, description = $3, member_of_contact_id = $4, financial_type_id = $5,
    minimum_fee = $6, duration_unit = $7, duration_interval = $8, period_type = $9,
    fixed_period_start_day = $10, fixed_period_rollover_day = $11,
    relationship_type_id = $12, relationship_direction = $13, visibility = $14,
    weight = $15, is_active = $16, is_reserved = $17, updated_at = NOW()
WHERE id = $1 RETURNING id, name, description, member_of_contact_id, financial_type_id, minimum_fee, duration_unit, duration_interval, period_type, fixed_period_start_day, fixed_period_rollover_day, relationship_type_id, relationship_direction, visibility, weight, is_active, is_reserved, created_at, updated_at
`

type UpdateMembershipTypeParams struct {
	ID                     uuid.UUID      `json:"id"`
	Name                   string         `json:"name"`
	Description            sql.NullString `json:"description"`
	MemberOfContactID      uuid.NullUUID  `json:"member_of_contact_id"`
	FinancialTypeID        uuid.NullUUID  `json:"financial_type_id"`
	MinimumFee             sql.NullString `json:"minimum_fee"`
	DurationUnit           string         `json:"duration_unit"`
	DurationInterval       int32          `json:"duration_interval"`
	PeriodType             string         `json:"period_type"`
	FixedPeriodStartDay    sql.NullInt32  `json:"fixed_period_start_day"`
	FixedPeriodRolloverDay sql.NullInt32  `json:"fixed_period_rollover_day"`
	RelationshipTypeID     uuid.NullUUID  `json:"relationship_type_id"`
	RelationshipDirection  sql.NullString `json:"relationship_direction"`
	Visibility             sql.NullString `json:"visibility"`
	Weight                 sql.NullInt32  `json:"weight"`
	IsActive               sql.NullBool   `json:"is_active"`
	IsReserved             sql.NullBool   `json:"is_reserved"`
}

func (q *Queries) UpdateMembershipType(ctx context.Context, arg UpdateMembershipTypeParams) (MembershipType, error) {
	row := q.db.QueryRowContext(ctx, UpdateMembershipType,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.MemberOfContactID,
		arg.FinancialTypeID,
		arg.MinimumFee,
		arg.DurationUnit,
		arg.DurationInterval,
		arg.PeriodType,
		arg.FixedPeriodStartDay,
		arg.FixedPeriodRolloverDay,
		arg.RelationshipTypeID,
		arg.RelationshipDirection,
		arg.Visibility,
		arg.Weight,
		arg.IsActive,
		arg.IsReserved,
	)
	var i MembershipType
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.MemberOfContactID,
		&i.FinancialTypeID,
		&i.MinimumFee,
		&i.DurationUnit,
		&i.DurationInterval,
		&i.PeriodType,
		&i.FixedPeriodStartDay,
		&i.FixedPeriodRolloverDay,
		&i.RelationshipTypeID,
		&i.RelationshipDirection,
		&i.Visibility,
		&i.Weight,
		&i.IsActive,
		&i.IsReserved,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateMembershipTypeWeight = `-- name: UpdateMembershipTypeWeight :exec
UPDATE membership_types SET weight = $2, updated_at = NOW() WHERE id = $1
`

type UpdateMembershipTypeWeightParams struct {
	ID     uuid.UUID     `json:"id"`
	Weight sql.NullInt32 `json:"weight"`
}

func (q *Queries) UpdateMembershipTypeWeight(ctx context.Context, arg UpdateMembershipTypeWeightParams) error {
	_, err := q.db.ExecContext(ctx, UpdateMembershipTypeWeight, arg.ID, arg.Weight)
	return err
}
