// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: pledges.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const CountPledgesByStatus = `-- name: CountPledgesByStatus :one
SELECT 
    COUNT(CASE WHEN status = 'Pending' THEN 1 END) as pending_count,
    COUNT(CASE WHEN status = 'In Progress' THEN 1 END) as in_progress_count,
    COUNT(CASE WHEN status = 'Overdue' THEN 1 END) as overdue_count,
    COUNT(CASE WHEN status = 'Completed' THEN 1 END) as completed_count,
    COUNT(CASE WHEN status = 'Cancelled' THEN 1 END) as cancelled_count
FROM pledges
WHERE campaign_id = $1
`

type CountPledgesByStatusRow struct {
	PendingCount    int64 `json:"pending_count"`
	InProgressCount int64 `json:"in_progress_count"`
	OverdueCount    int64 `json:"overdue_count"`
	CompletedCount  int64 `json:"completed_count"`
	CancelledCount  int64 `json:"cancelled_count"`
}

func (q *Queries) CountPledgesByStatus(ctx context.Context, campaignID uuid.NullUUID) (CountPledgesByStatusRow, error) {
	row := q.db.QueryRowContext(ctx, CountPledgesByStatus, campaignID)
	var i CountPledgesByStatusRow
	err := row.Scan(
		&i.PendingCount,
		&i.InProgressCount,
		&i.OverdueCount,
		&i.CompletedCount,
		&i.CancelledCount,
	)
	return i, err
}

const CreatePledge = `-- name: CreatePledge :one
INSERT INTO pledges (
    contact_id, campaign_id, pledge_block_id, amount, installments, frequency,
    frequency_interval, start_date, end_date, next_payment_date, status,
    currency, financial_type_id, payment_instrument_id, is_test
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15
) RETURNING id, contact_id, campaign_id, pledge_block_id, amount, installments, frequency, frequency_interval, start_date, end_date, next_payment_date, status, currency, financial_type_id, payment_instrument_id, is_test, created_at, updated_at
`

type CreatePledgeParams struct {
	ContactID           uuid.UUID      `json:"contact_id"`
	CampaignID          uuid.NullUUID  `json:"campaign_id"`
	PledgeBlockID       uuid.NullUUID  `json:"pledge_block_id"`
	Amount              string         `json:"amount"`
	Installments        sql.NullInt32  `json:"installments"`
	Frequency           sql.NullString `json:"frequency"`
	FrequencyInterval   sql.NullInt32  `json:"frequency_interval"`
	StartDate           time.Time      `json:"start_date"`
	EndDate             sql.NullTime   `json:"end_date"`
	NextPaymentDate     sql.NullTime   `json:"next_payment_date"`
	Status              sql.NullString `json:"status"`
	Currency            sql.NullString `json:"currency"`
	FinancialTypeID     uuid.NullUUID  `json:"financial_type_id"`
	PaymentInstrumentID uuid.NullUUID  `json:"payment_instrument_id"`
	IsTest              sql.NullBool   `json:"is_test"`
}

// Pledges CRUD operations
func (q *Queries) CreatePledge(ctx context.Context, arg CreatePledgeParams) (Pledge, error) {
	row := q.db.QueryRowContext(ctx, CreatePledge,
		arg.ContactID,
		arg.CampaignID,
		arg.PledgeBlockID,
		arg.Amount,
		arg.Installments,
		arg.Frequency,
		arg.FrequencyInterval,
		arg.StartDate,
		arg.EndDate,
		arg.NextPaymentDate,
		arg.Status,
		arg.Currency,
		arg.FinancialTypeID,
		arg.PaymentInstrumentID,
		arg.IsTest,
	)
	var i Pledge
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.CampaignID,
		&i.PledgeBlockID,
		&i.Amount,
		&i.Installments,
		&i.Frequency,
		&i.FrequencyInterval,
		&i.StartDate,
		&i.EndDate,
		&i.NextPaymentDate,
		&i.Status,
		&i.Currency,
		&i.FinancialTypeID,
		&i.PaymentInstrumentID,
		&i.IsTest,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const CreatePledgeBlock = `-- name: CreatePledgeBlock :one

INSERT INTO pledge_blocks (
    name, title, description, campaign_id, is_active, start_date, end_date, goal_amount
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id, name, title, description, campaign_id, is_active, start_date, end_date, goal_amount, created_at, updated_at
`

type CreatePledgeBlockParams struct {
	Name        string         `json:"name"`
	Title       string         `json:"title"`
	Description sql.NullString `json:"description"`
	CampaignID  uuid.NullUUID  `json:"campaign_id"`
	IsActive    sql.NullBool   `json:"is_active"`
	StartDate   sql.NullTime   `json:"start_date"`
	EndDate     sql.NullTime   `json:"end_date"`
	GoalAmount  sql.NullString `json:"goal_amount"`
}

// Pledge System Queries
// Provides CRUD operations and specialized queries for pledge management
// Pledge Blocks CRUD operations
func (q *Queries) CreatePledgeBlock(ctx context.Context, arg CreatePledgeBlockParams) (PledgeBlock, error) {
	row := q.db.QueryRowContext(ctx, CreatePledgeBlock,
		arg.Name,
		arg.Title,
		arg.Description,
		arg.CampaignID,
		arg.IsActive,
		arg.StartDate,
		arg.EndDate,
		arg.GoalAmount,
	)
	var i PledgeBlock
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Title,
		&i.Description,
		&i.CampaignID,
		&i.IsActive,
		&i.StartDate,
		&i.EndDate,
		&i.GoalAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const CreatePledgeGroup = `-- name: CreatePledgeGroup :one
INSERT INTO pledge_groups (
    name, description, goal_amount, current_amount, is_active
) VALUES ($1, $2, $3, $4, $5) RETURNING id, name, description, goal_amount, current_amount, is_active, created_at, updated_at
`

type CreatePledgeGroupParams struct {
	Name          string         `json:"name"`
	Description   sql.NullString `json:"description"`
	GoalAmount    sql.NullString `json:"goal_amount"`
	CurrentAmount sql.NullString `json:"current_amount"`
	IsActive      sql.NullBool   `json:"is_active"`
}

// Pledge Groups CRUD operations
func (q *Queries) CreatePledgeGroup(ctx context.Context, arg CreatePledgeGroupParams) (PledgeGroup, error) {
	row := q.db.QueryRowContext(ctx, CreatePledgeGroup,
		arg.Name,
		arg.Description,
		arg.GoalAmount,
		arg.CurrentAmount,
		arg.IsActive,
	)
	var i PledgeGroup
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.GoalAmount,
		&i.CurrentAmount,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const CreatePledgeGroupMember = `-- name: CreatePledgeGroupMember :one
INSERT INTO pledge_group_members (
    pledge_group_id, contact_id, pledge_id, role
) VALUES ($1, $2, $3, $4) RETURNING id, pledge_group_id, contact_id, pledge_id, role, is_active, joined_date, created_at, updated_at
`

type CreatePledgeGroupMemberParams struct {
	PledgeGroupID uuid.UUID      `json:"pledge_group_id"`
	ContactID     uuid.UUID      `json:"contact_id"`
	PledgeID      uuid.NullUUID  `json:"pledge_id"`
	Role          sql.NullString `json:"role"`
}

// Pledge Group Members CRUD operations
func (q *Queries) CreatePledgeGroupMember(ctx context.Context, arg CreatePledgeGroupMemberParams) (PledgeGroupMember, error) {
	row := q.db.QueryRowContext(ctx, CreatePledgeGroupMember,
		arg.PledgeGroupID,
		arg.ContactID,
		arg.PledgeID,
		arg.Role,
	)
	var i PledgeGroupMember
	err := row.Scan(
		&i.ID,
		&i.PledgeGroupID,
		&i.ContactID,
		&i.PledgeID,
		&i.Role,
		&i.IsActive,
		&i.JoinedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const CreatePledgeLog = `-- name: CreatePledgeLog :one
INSERT INTO pledge_logs (
    pledge_id, action, description, amount_before, amount_after,
    status_before, status_after, created_by
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id, pledge_id, action, description, amount_before, amount_after, status_before, status_after, created_by, created_at
`

type CreatePledgeLogParams struct {
	PledgeID     uuid.UUID      `json:"pledge_id"`
	Action       string         `json:"action"`
	Description  sql.NullString `json:"description"`
	AmountBefore sql.NullString `json:"amount_before"`
	AmountAfter  sql.NullString `json:"amount_after"`
	StatusBefore sql.NullString `json:"status_before"`
	StatusAfter  sql.NullString `json:"status_after"`
	CreatedBy    uuid.NullUUID  `json:"created_by"`
}

// Pledge Logs CRUD operations
func (q *Queries) CreatePledgeLog(ctx context.Context, arg CreatePledgeLogParams) (PledgeLog, error) {
	row := q.db.QueryRowContext(ctx, CreatePledgeLog,
		arg.PledgeID,
		arg.Action,
		arg.Description,
		arg.AmountBefore,
		arg.AmountAfter,
		arg.StatusBefore,
		arg.StatusAfter,
		arg.CreatedBy,
	)
	var i PledgeLog
	err := row.Scan(
		&i.ID,
		&i.PledgeID,
		&i.Action,
		&i.Description,
		&i.AmountBefore,
		&i.AmountAfter,
		&i.StatusBefore,
		&i.StatusAfter,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const CreatePledgePayment = `-- name: CreatePledgePayment :one
INSERT INTO pledge_payments (
    pledge_id, contribution_id, scheduled_amount, actual_amount,
    scheduled_date, actual_date, status
) VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, pledge_id, contribution_id, scheduled_amount, actual_amount, scheduled_date, actual_date, status, reminder_count, reminder_date, created_at, updated_at
`

type CreatePledgePaymentParams struct {
	PledgeID        uuid.UUID      `json:"pledge_id"`
	ContributionID  uuid.NullUUID  `json:"contribution_id"`
	ScheduledAmount string         `json:"scheduled_amount"`
	ActualAmount    sql.NullString `json:"actual_amount"`
	ScheduledDate   time.Time      `json:"scheduled_date"`
	ActualDate      sql.NullTime   `json:"actual_date"`
	Status          sql.NullString `json:"status"`
}

// Pledge Payments CRUD operations
func (q *Queries) CreatePledgePayment(ctx context.Context, arg CreatePledgePaymentParams) (PledgePayment, error) {
	row := q.db.QueryRowContext(ctx, CreatePledgePayment,
		arg.PledgeID,
		arg.ContributionID,
		arg.ScheduledAmount,
		arg.ActualAmount,
		arg.ScheduledDate,
		arg.ActualDate,
		arg.Status,
	)
	var i PledgePayment
	err := row.Scan(
		&i.ID,
		&i.PledgeID,
		&i.ContributionID,
		&i.ScheduledAmount,
		&i.ActualAmount,
		&i.ScheduledDate,
		&i.ActualDate,
		&i.Status,
		&i.ReminderCount,
		&i.ReminderDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const CreatePledgeReminder = `-- name: CreatePledgeReminder :one
INSERT INTO pledge_reminders (
    pledge_id, pledge_payment_id, reminder_type, scheduled_date,
    message_template_id
) VALUES ($1, $2, $3, $4, $5) RETURNING id, pledge_id, pledge_payment_id, reminder_type, scheduled_date, sent_date, status, message_template_id, created_at, updated_at
`

type CreatePledgeReminderParams struct {
	PledgeID          uuid.UUID     `json:"pledge_id"`
	PledgePaymentID   uuid.NullUUID `json:"pledge_payment_id"`
	ReminderType      string        `json:"reminder_type"`
	ScheduledDate     time.Time     `json:"scheduled_date"`
	MessageTemplateID uuid.NullUUID `json:"message_template_id"`
}

// Pledge Reminders CRUD operations
func (q *Queries) CreatePledgeReminder(ctx context.Context, arg CreatePledgeReminderParams) (PledgeReminder, error) {
	row := q.db.QueryRowContext(ctx, CreatePledgeReminder,
		arg.PledgeID,
		arg.PledgePaymentID,
		arg.ReminderType,
		arg.ScheduledDate,
		arg.MessageTemplateID,
	)
	var i PledgeReminder
	err := row.Scan(
		&i.ID,
		&i.PledgeID,
		&i.PledgePaymentID,
		&i.ReminderType,
		&i.ScheduledDate,
		&i.SentDate,
		&i.Status,
		&i.MessageTemplateID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const DeletePledge = `-- name: DeletePledge :exec
DELETE FROM pledges WHERE id = $1
`

func (q *Queries) DeletePledge(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeletePledge, id)
	return err
}

const DeletePledgeBlock = `-- name: DeletePledgeBlock :exec
DELETE FROM pledge_blocks WHERE id = $1
`

func (q *Queries) DeletePledgeBlock(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeletePledgeBlock, id)
	return err
}

const DeletePledgeGroup = `-- name: DeletePledgeGroup :exec
DELETE FROM pledge_groups WHERE id = $1
`

func (q *Queries) DeletePledgeGroup(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeletePledgeGroup, id)
	return err
}

const DeletePledgeGroupMember = `-- name: DeletePledgeGroupMember :exec
DELETE FROM pledge_group_members WHERE id = $1
`

func (q *Queries) DeletePledgeGroupMember(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeletePledgeGroupMember, id)
	return err
}

const DeletePledgePayment = `-- name: DeletePledgePayment :exec
DELETE FROM pledge_payments WHERE id = $1
`

func (q *Queries) DeletePledgePayment(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeletePledgePayment, id)
	return err
}

const DeletePledgeReminder = `-- name: DeletePledgeReminder :exec
DELETE FROM pledge_reminders WHERE id = $1
`

func (q *Queries) DeletePledgeReminder(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeletePledgeReminder, id)
	return err
}

const GetOverduePledges = `-- name: GetOverduePledges :many
SELECT 
    p.id, p.contact_id, p.campaign_id, p.pledge_block_id, p.amount, p.installments, p.frequency, p.frequency_interval, p.start_date, p.end_date, p.next_payment_date, p.status, p.currency, p.financial_type_id, p.payment_instrument_id, p.is_test, p.created_at, p.updated_at,
    c.first_name,
    c.last_name,
    c.email,
    pp.scheduled_date as next_payment_date,
    pp.scheduled_amount as next_payment_amount
FROM pledges p
INNER JOIN contacts c ON p.contact_id = c.id
INNER JOIN pledge_payments pp ON p.id = pp.pledge_id
WHERE p.status = 'In Progress' 
  AND pp.status = 'Scheduled' 
  AND pp.scheduled_date < $1
ORDER BY pp.scheduled_date ASC
`

type GetOverduePledgesRow struct {
	ID                  uuid.UUID      `json:"id"`
	ContactID           uuid.UUID      `json:"contact_id"`
	CampaignID          uuid.NullUUID  `json:"campaign_id"`
	PledgeBlockID       uuid.NullUUID  `json:"pledge_block_id"`
	Amount              string         `json:"amount"`
	Installments        sql.NullInt32  `json:"installments"`
	Frequency           sql.NullString `json:"frequency"`
	FrequencyInterval   sql.NullInt32  `json:"frequency_interval"`
	StartDate           time.Time      `json:"start_date"`
	EndDate             sql.NullTime   `json:"end_date"`
	NextPaymentDate     sql.NullTime   `json:"next_payment_date"`
	Status              sql.NullString `json:"status"`
	Currency            sql.NullString `json:"currency"`
	FinancialTypeID     uuid.NullUUID  `json:"financial_type_id"`
	PaymentInstrumentID uuid.NullUUID  `json:"payment_instrument_id"`
	IsTest              sql.NullBool   `json:"is_test"`
	CreatedAt           sql.NullTime   `json:"created_at"`
	UpdatedAt           sql.NullTime   `json:"updated_at"`
	FirstName           sql.NullString `json:"first_name"`
	LastName            sql.NullString `json:"last_name"`
	Email               sql.NullString `json:"email"`
	NextPaymentDate_2   time.Time      `json:"next_payment_date_2"`
	NextPaymentAmount   string         `json:"next_payment_amount"`
}

func (q *Queries) GetOverduePledges(ctx context.Context, scheduledDate time.Time) ([]GetOverduePledgesRow, error) {
	rows, err := q.db.QueryContext(ctx, GetOverduePledges, scheduledDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOverduePledgesRow{}
	for rows.Next() {
		var i GetOverduePledgesRow
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.CampaignID,
			&i.PledgeBlockID,
			&i.Amount,
			&i.Installments,
			&i.Frequency,
			&i.FrequencyInterval,
			&i.StartDate,
			&i.EndDate,
			&i.NextPaymentDate,
			&i.Status,
			&i.Currency,
			&i.FinancialTypeID,
			&i.PaymentInstrumentID,
			&i.IsTest,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.NextPaymentDate_2,
			&i.NextPaymentAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetPledge = `-- name: GetPledge :one
SELECT id, contact_id, campaign_id, pledge_block_id, amount, installments, frequency, frequency_interval, start_date, end_date, next_payment_date, status, currency, financial_type_id, payment_instrument_id, is_test, created_at, updated_at FROM pledges WHERE id = $1
`

func (q *Queries) GetPledge(ctx context.Context, id uuid.UUID) (Pledge, error) {
	row := q.db.QueryRowContext(ctx, GetPledge, id)
	var i Pledge
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.CampaignID,
		&i.PledgeBlockID,
		&i.Amount,
		&i.Installments,
		&i.Frequency,
		&i.FrequencyInterval,
		&i.StartDate,
		&i.EndDate,
		&i.NextPaymentDate,
		&i.Status,
		&i.Currency,
		&i.FinancialTypeID,
		&i.PaymentInstrumentID,
		&i.IsTest,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetPledgeBlock = `-- name: GetPledgeBlock :one
SELECT id, name, title, description, campaign_id, is_active, start_date, end_date, goal_amount, created_at, updated_at FROM pledge_blocks WHERE id = $1
`

func (q *Queries) GetPledgeBlock(ctx context.Context, id uuid.UUID) (PledgeBlock, error) {
	row := q.db.QueryRowContext(ctx, GetPledgeBlock, id)
	var i PledgeBlock
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Title,
		&i.Description,
		&i.CampaignID,
		&i.IsActive,
		&i.StartDate,
		&i.EndDate,
		&i.GoalAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetPledgeByContact = `-- name: GetPledgeByContact :one
SELECT id, contact_id, campaign_id, pledge_block_id, amount, installments, frequency, frequency_interval, start_date, end_date, next_payment_date, status, currency, financial_type_id, payment_instrument_id, is_test, created_at, updated_at FROM pledges WHERE contact_id = $1 AND status = $2 LIMIT 1
`

type GetPledgeByContactParams struct {
	ContactID uuid.UUID      `json:"contact_id"`
	Status    sql.NullString `json:"status"`
}

func (q *Queries) GetPledgeByContact(ctx context.Context, arg GetPledgeByContactParams) (Pledge, error) {
	row := q.db.QueryRowContext(ctx, GetPledgeByContact, arg.ContactID, arg.Status)
	var i Pledge
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.CampaignID,
		&i.PledgeBlockID,
		&i.Amount,
		&i.Installments,
		&i.Frequency,
		&i.FrequencyInterval,
		&i.StartDate,
		&i.EndDate,
		&i.NextPaymentDate,
		&i.Status,
		&i.Currency,
		&i.FinancialTypeID,
		&i.PaymentInstrumentID,
		&i.IsTest,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetPledgeGroup = `-- name: GetPledgeGroup :one
SELECT id, name, description, goal_amount, current_amount, is_active, created_at, updated_at FROM pledge_groups WHERE id = $1
`

func (q *Queries) GetPledgeGroup(ctx context.Context, id uuid.UUID) (PledgeGroup, error) {
	row := q.db.QueryRowContext(ctx, GetPledgeGroup, id)
	var i PledgeGroup
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.GoalAmount,
		&i.CurrentAmount,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetPledgeGroupMember = `-- name: GetPledgeGroupMember :one
SELECT id, pledge_group_id, contact_id, pledge_id, role, is_active, joined_date, created_at, updated_at FROM pledge_group_members WHERE id = $1
`

func (q *Queries) GetPledgeGroupMember(ctx context.Context, id uuid.UUID) (PledgeGroupMember, error) {
	row := q.db.QueryRowContext(ctx, GetPledgeGroupMember, id)
	var i PledgeGroupMember
	err := row.Scan(
		&i.ID,
		&i.PledgeGroupID,
		&i.ContactID,
		&i.PledgeID,
		&i.Role,
		&i.IsActive,
		&i.JoinedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetPledgeGroupProgress = `-- name: GetPledgeGroupProgress :many
SELECT 
    pg.name,
    pg.goal_amount,
    pg.current_amount,
    ROUND((pg.current_amount / pg.goal_amount) * 100, 2) as progress_percentage,
    COUNT(pgm.contact_id) as member_count
FROM pledge_groups pg
LEFT JOIN pledge_group_members pgm ON pg.id = pgm.pledge_group_id AND pgm.is_active = true
WHERE pg.is_active = $1
GROUP BY pg.id, pg.name, pg.goal_amount, pg.current_amount
ORDER BY progress_percentage DESC
`

type GetPledgeGroupProgressRow struct {
	Name               string         `json:"name"`
	GoalAmount         sql.NullString `json:"goal_amount"`
	CurrentAmount      sql.NullString `json:"current_amount"`
	ProgressPercentage string         `json:"progress_percentage"`
	MemberCount        int64          `json:"member_count"`
}

func (q *Queries) GetPledgeGroupProgress(ctx context.Context, isActive sql.NullBool) ([]GetPledgeGroupProgressRow, error) {
	rows, err := q.db.QueryContext(ctx, GetPledgeGroupProgress, isActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPledgeGroupProgressRow{}
	for rows.Next() {
		var i GetPledgeGroupProgressRow
		if err := rows.Scan(
			&i.Name,
			&i.GoalAmount,
			&i.CurrentAmount,
			&i.ProgressPercentage,
			&i.MemberCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetPledgeLogs = `-- name: GetPledgeLogs :many
SELECT id, pledge_id, action, description, amount_before, amount_after, status_before, status_after, created_by, created_at FROM pledge_logs 
WHERE pledge_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetPledgeLogs(ctx context.Context, pledgeID uuid.UUID) ([]PledgeLog, error) {
	rows, err := q.db.QueryContext(ctx, GetPledgeLogs, pledgeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PledgeLog{}
	for rows.Next() {
		var i PledgeLog
		if err := rows.Scan(
			&i.ID,
			&i.PledgeID,
			&i.Action,
			&i.Description,
			&i.AmountBefore,
			&i.AmountAfter,
			&i.StatusBefore,
			&i.StatusAfter,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetPledgePayment = `-- name: GetPledgePayment :one
SELECT id, pledge_id, contribution_id, scheduled_amount, actual_amount, scheduled_date, actual_date, status, reminder_count, reminder_date, created_at, updated_at FROM pledge_payments WHERE id = $1
`

func (q *Queries) GetPledgePayment(ctx context.Context, id uuid.UUID) (PledgePayment, error) {
	row := q.db.QueryRowContext(ctx, GetPledgePayment, id)
	var i PledgePayment
	err := row.Scan(
		&i.ID,
		&i.PledgeID,
		&i.ContributionID,
		&i.ScheduledAmount,
		&i.ActualAmount,
		&i.ScheduledDate,
		&i.ActualDate,
		&i.Status,
		&i.ReminderCount,
		&i.ReminderDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetPledgePaymentSchedule = `-- name: GetPledgePaymentSchedule :many
SELECT 
    pp.scheduled_date,
    pp.scheduled_amount,
    pp.status,
    p.contact_id,
    c.first_name,
    c.last_name,
    c.email
FROM pledge_payments pp
INNER JOIN pledges p ON pp.pledge_id = p.id
INNER JOIN contacts c ON p.contact_id = c.id
WHERE pp.pledge_id = $1
ORDER BY pp.scheduled_date
`

type GetPledgePaymentScheduleRow struct {
	ScheduledDate   time.Time      `json:"scheduled_date"`
	ScheduledAmount string         `json:"scheduled_amount"`
	Status          sql.NullString `json:"status"`
	ContactID       uuid.UUID      `json:"contact_id"`
	FirstName       sql.NullString `json:"first_name"`
	LastName        sql.NullString `json:"last_name"`
	Email           sql.NullString `json:"email"`
}

func (q *Queries) GetPledgePaymentSchedule(ctx context.Context, pledgeID uuid.UUID) ([]GetPledgePaymentScheduleRow, error) {
	rows, err := q.db.QueryContext(ctx, GetPledgePaymentSchedule, pledgeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPledgePaymentScheduleRow{}
	for rows.Next() {
		var i GetPledgePaymentScheduleRow
		if err := rows.Scan(
			&i.ScheduledDate,
			&i.ScheduledAmount,
			&i.Status,
			&i.ContactID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetPledgePerformance = `-- name: GetPledgePerformance :many
SELECT 
    DATE_TRUNC('month', p.created_at) as month,
    COUNT(*) as new_pledges,
    SUM(p.amount) as pledged_amount,
    COUNT(CASE WHEN p.status = 'Completed' THEN 1 END) as completed_pledges,
    SUM(CASE WHEN p.status = 'Completed' THEN p.amount ELSE 0 END) as completed_amount
FROM pledges p
WHERE p.created_at >= $1
GROUP BY DATE_TRUNC('month', p.created_at)
ORDER BY month
`

type GetPledgePerformanceRow struct {
	Month            int64 `json:"month"`
	NewPledges       int64 `json:"new_pledges"`
	PledgedAmount    int64 `json:"pledged_amount"`
	CompletedPledges int64 `json:"completed_pledges"`
	CompletedAmount  int64 `json:"completed_amount"`
}

func (q *Queries) GetPledgePerformance(ctx context.Context, createdAt sql.NullTime) ([]GetPledgePerformanceRow, error) {
	rows, err := q.db.QueryContext(ctx, GetPledgePerformance, createdAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPledgePerformanceRow{}
	for rows.Next() {
		var i GetPledgePerformanceRow
		if err := rows.Scan(
			&i.Month,
			&i.NewPledges,
			&i.PledgedAmount,
			&i.CompletedPledges,
			&i.CompletedAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetPledgeReminder = `-- name: GetPledgeReminder :one
SELECT id, pledge_id, pledge_payment_id, reminder_type, scheduled_date, sent_date, status, message_template_id, created_at, updated_at FROM pledge_reminders WHERE id = $1
`

func (q *Queries) GetPledgeReminder(ctx context.Context, id uuid.UUID) (PledgeReminder, error) {
	row := q.db.QueryRowContext(ctx, GetPledgeReminder, id)
	var i PledgeReminder
	err := row.Scan(
		&i.ID,
		&i.PledgeID,
		&i.PledgePaymentID,
		&i.ReminderType,
		&i.ScheduledDate,
		&i.SentDate,
		&i.Status,
		&i.MessageTemplateID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetPledgeReminderQueue = `-- name: GetPledgeReminderQueue :many
SELECT 
    pr.id, pr.pledge_id, pr.pledge_payment_id, pr.reminder_type, pr.scheduled_date, pr.sent_date, pr.status, pr.message_template_id, pr.created_at, pr.updated_at,
    p.contact_id,
    c.first_name,
    c.last_name,
    c.email,
    p.amount as pledge_amount,
    p.frequency
FROM pledge_reminders pr
INNER JOIN pledges p ON pr.pledge_id = p.id
INNER JOIN contacts c ON p.contact_id = c.id
WHERE pr.status = 'Scheduled' 
  AND pr.scheduled_date <= $1
  AND p.status IN ('In Progress', 'Overdue')
ORDER BY pr.scheduled_date ASC
`

type GetPledgeReminderQueueRow struct {
	ID                uuid.UUID      `json:"id"`
	PledgeID          uuid.UUID      `json:"pledge_id"`
	PledgePaymentID   uuid.NullUUID  `json:"pledge_payment_id"`
	ReminderType      string         `json:"reminder_type"`
	ScheduledDate     time.Time      `json:"scheduled_date"`
	SentDate          sql.NullTime   `json:"sent_date"`
	Status            sql.NullString `json:"status"`
	MessageTemplateID uuid.NullUUID  `json:"message_template_id"`
	CreatedAt         sql.NullTime   `json:"created_at"`
	UpdatedAt         sql.NullTime   `json:"updated_at"`
	ContactID         uuid.UUID      `json:"contact_id"`
	FirstName         sql.NullString `json:"first_name"`
	LastName          sql.NullString `json:"last_name"`
	Email             sql.NullString `json:"email"`
	PledgeAmount      string         `json:"pledge_amount"`
	Frequency         sql.NullString `json:"frequency"`
}

func (q *Queries) GetPledgeReminderQueue(ctx context.Context, scheduledDate time.Time) ([]GetPledgeReminderQueueRow, error) {
	rows, err := q.db.QueryContext(ctx, GetPledgeReminderQueue, scheduledDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPledgeReminderQueueRow{}
	for rows.Next() {
		var i GetPledgeReminderQueueRow
		if err := rows.Scan(
			&i.ID,
			&i.PledgeID,
			&i.PledgePaymentID,
			&i.ReminderType,
			&i.ScheduledDate,
			&i.SentDate,
			&i.Status,
			&i.MessageTemplateID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ContactID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.PledgeAmount,
			&i.Frequency,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetPledgeSummary = `-- name: GetPledgeSummary :one
SELECT 
    COUNT(*) as total_pledges,
    COUNT(CASE WHEN status = 'Pending' THEN 1 END) as pending_pledges,
    COUNT(CASE WHEN status = 'In Progress' THEN 1 END) as active_pledges,
    COUNT(CASE WHEN status = 'Overdue' THEN 1 END) as overdue_pledges,
    COUNT(CASE WHEN status = 'Completed' THEN 1 END) as completed_pledges,
    SUM(amount) as total_pledged_amount,
    SUM(CASE WHEN status = 'Completed' THEN amount ELSE 0 END) as total_completed_amount
FROM pledges
WHERE campaign_id = $1
`

type GetPledgeSummaryRow struct {
	TotalPledges         int64 `json:"total_pledges"`
	PendingPledges       int64 `json:"pending_pledges"`
	ActivePledges        int64 `json:"active_pledges"`
	OverduePledges       int64 `json:"overdue_pledges"`
	CompletedPledges     int64 `json:"completed_pledges"`
	TotalPledgedAmount   int64 `json:"total_pledged_amount"`
	TotalCompletedAmount int64 `json:"total_completed_amount"`
}

// Specialized queries for pledge system
func (q *Queries) GetPledgeSummary(ctx context.Context, campaignID uuid.NullUUID) (GetPledgeSummaryRow, error) {
	row := q.db.QueryRowContext(ctx, GetPledgeSummary, campaignID)
	var i GetPledgeSummaryRow
	err := row.Scan(
		&i.TotalPledges,
		&i.PendingPledges,
		&i.ActivePledges,
		&i.OverduePledges,
		&i.CompletedPledges,
		&i.TotalPledgedAmount,
		&i.TotalCompletedAmount,
	)
	return i, err
}

const ListPledgeBlocks = `-- name: ListPledgeBlocks :many
SELECT id, name, title, description, campaign_id, is_active, start_date, end_date, goal_amount, created_at, updated_at FROM pledge_blocks 
WHERE is_active = $1
ORDER BY start_date DESC
`

func (q *Queries) ListPledgeBlocks(ctx context.Context, isActive sql.NullBool) ([]PledgeBlock, error) {
	rows, err := q.db.QueryContext(ctx, ListPledgeBlocks, isActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PledgeBlock{}
	for rows.Next() {
		var i PledgeBlock
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Title,
			&i.Description,
			&i.CampaignID,
			&i.IsActive,
			&i.StartDate,
			&i.EndDate,
			&i.GoalAmount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListPledgeBlocksByCampaign = `-- name: ListPledgeBlocksByCampaign :many
SELECT id, name, title, description, campaign_id, is_active, start_date, end_date, goal_amount, created_at, updated_at FROM pledge_blocks 
WHERE campaign_id = $1 AND is_active = $2
ORDER BY start_date DESC
`

type ListPledgeBlocksByCampaignParams struct {
	CampaignID uuid.NullUUID `json:"campaign_id"`
	IsActive   sql.NullBool  `json:"is_active"`
}

func (q *Queries) ListPledgeBlocksByCampaign(ctx context.Context, arg ListPledgeBlocksByCampaignParams) ([]PledgeBlock, error) {
	rows, err := q.db.QueryContext(ctx, ListPledgeBlocksByCampaign, arg.CampaignID, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PledgeBlock{}
	for rows.Next() {
		var i PledgeBlock
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Title,
			&i.Description,
			&i.CampaignID,
			&i.IsActive,
			&i.StartDate,
			&i.EndDate,
			&i.GoalAmount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListPledgeGroupMembers = `-- name: ListPledgeGroupMembers :many
SELECT pgm.id, pgm.pledge_group_id, pgm.contact_id, pgm.pledge_id, pgm.role, pgm.is_active, pgm.joined_date, pgm.created_at, pgm.updated_at, c.first_name, c.last_name, c.email
FROM pledge_group_members pgm
INNER JOIN contacts c ON pgm.contact_id = c.id
WHERE pgm.pledge_group_id = $1 AND pgm.is_active = $2
ORDER BY pgm.role, c.last_name, c.first_name
`

type ListPledgeGroupMembersParams struct {
	PledgeGroupID uuid.UUID    `json:"pledge_group_id"`
	IsActive      sql.NullBool `json:"is_active"`
}

type ListPledgeGroupMembersRow struct {
	ID            uuid.UUID      `json:"id"`
	PledgeGroupID uuid.UUID      `json:"pledge_group_id"`
	ContactID     uuid.UUID      `json:"contact_id"`
	PledgeID      uuid.NullUUID  `json:"pledge_id"`
	Role          sql.NullString `json:"role"`
	IsActive      sql.NullBool   `json:"is_active"`
	JoinedDate    sql.NullTime   `json:"joined_date"`
	CreatedAt     sql.NullTime   `json:"created_at"`
	UpdatedAt     sql.NullTime   `json:"updated_at"`
	FirstName     sql.NullString `json:"first_name"`
	LastName      sql.NullString `json:"last_name"`
	Email         sql.NullString `json:"email"`
}

func (q *Queries) ListPledgeGroupMembers(ctx context.Context, arg ListPledgeGroupMembersParams) ([]ListPledgeGroupMembersRow, error) {
	rows, err := q.db.QueryContext(ctx, ListPledgeGroupMembers, arg.PledgeGroupID, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPledgeGroupMembersRow{}
	for rows.Next() {
		var i ListPledgeGroupMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.PledgeGroupID,
			&i.ContactID,
			&i.PledgeID,
			&i.Role,
			&i.IsActive,
			&i.JoinedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListPledgeGroups = `-- name: ListPledgeGroups :many
SELECT id, name, description, goal_amount, current_amount, is_active, created_at, updated_at FROM pledge_groups 
WHERE is_active = $1
ORDER BY name
`

func (q *Queries) ListPledgeGroups(ctx context.Context, isActive sql.NullBool) ([]PledgeGroup, error) {
	rows, err := q.db.QueryContext(ctx, ListPledgeGroups, isActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PledgeGroup{}
	for rows.Next() {
		var i PledgeGroup
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.GoalAmount,
			&i.CurrentAmount,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListPledgeLogsByUser = `-- name: ListPledgeLogsByUser :many
SELECT pl.id, pl.pledge_id, pl.action, pl.description, pl.amount_before, pl.amount_after, pl.status_before, pl.status_after, pl.created_by, pl.created_at, p.contact_id, c.first_name, c.last_name
FROM pledge_logs pl
INNER JOIN pledges p ON pl.pledge_id = p.id
INNER JOIN contacts c ON p.contact_id = c.id
WHERE pl.created_by = $1
ORDER BY pl.created_at DESC
LIMIT $2
`

type ListPledgeLogsByUserParams struct {
	CreatedBy uuid.NullUUID `json:"created_by"`
	Limit     int32         `json:"limit"`
}

type ListPledgeLogsByUserRow struct {
	ID           uuid.UUID      `json:"id"`
	PledgeID     uuid.UUID      `json:"pledge_id"`
	Action       string         `json:"action"`
	Description  sql.NullString `json:"description"`
	AmountBefore sql.NullString `json:"amount_before"`
	AmountAfter  sql.NullString `json:"amount_after"`
	StatusBefore sql.NullString `json:"status_before"`
	StatusAfter  sql.NullString `json:"status_after"`
	CreatedBy    uuid.NullUUID  `json:"created_by"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	ContactID    uuid.UUID      `json:"contact_id"`
	FirstName    sql.NullString `json:"first_name"`
	LastName     sql.NullString `json:"last_name"`
}

func (q *Queries) ListPledgeLogsByUser(ctx context.Context, arg ListPledgeLogsByUserParams) ([]ListPledgeLogsByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, ListPledgeLogsByUser, arg.CreatedBy, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPledgeLogsByUserRow{}
	for rows.Next() {
		var i ListPledgeLogsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.PledgeID,
			&i.Action,
			&i.Description,
			&i.AmountBefore,
			&i.AmountAfter,
			&i.StatusBefore,
			&i.StatusAfter,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ContactID,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListPledgePayments = `-- name: ListPledgePayments :many
SELECT id, pledge_id, contribution_id, scheduled_amount, actual_amount, scheduled_date, actual_date, status, reminder_count, reminder_date, created_at, updated_at FROM pledge_payments 
WHERE pledge_id = $1
ORDER BY scheduled_date
`

func (q *Queries) ListPledgePayments(ctx context.Context, pledgeID uuid.UUID) ([]PledgePayment, error) {
	rows, err := q.db.QueryContext(ctx, ListPledgePayments, pledgeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PledgePayment{}
	for rows.Next() {
		var i PledgePayment
		if err := rows.Scan(
			&i.ID,
			&i.PledgeID,
			&i.ContributionID,
			&i.ScheduledAmount,
			&i.ActualAmount,
			&i.ScheduledDate,
			&i.ActualDate,
			&i.Status,
			&i.ReminderCount,
			&i.ReminderDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListPledgePaymentsByStatus = `-- name: ListPledgePaymentsByStatus :many
SELECT pp.id, pp.pledge_id, pp.contribution_id, pp.scheduled_amount, pp.actual_amount, pp.scheduled_date, pp.actual_date, pp.status, pp.reminder_count, pp.reminder_date, pp.created_at, pp.updated_at, p.contact_id, c.first_name, c.last_name, c.email
FROM pledge_payments pp
INNER JOIN pledges p ON pp.pledge_id = p.id
INNER JOIN contacts c ON p.contact_id = c.id
WHERE pp.status = $1
ORDER BY pp.scheduled_date ASC
`

type ListPledgePaymentsByStatusRow struct {
	ID              uuid.UUID      `json:"id"`
	PledgeID        uuid.UUID      `json:"pledge_id"`
	ContributionID  uuid.NullUUID  `json:"contribution_id"`
	ScheduledAmount string         `json:"scheduled_amount"`
	ActualAmount    sql.NullString `json:"actual_amount"`
	ScheduledDate   time.Time      `json:"scheduled_date"`
	ActualDate      sql.NullTime   `json:"actual_date"`
	Status          sql.NullString `json:"status"`
	ReminderCount   sql.NullInt32  `json:"reminder_count"`
	ReminderDate    sql.NullTime   `json:"reminder_date"`
	CreatedAt       sql.NullTime   `json:"created_at"`
	UpdatedAt       sql.NullTime   `json:"updated_at"`
	ContactID       uuid.UUID      `json:"contact_id"`
	FirstName       sql.NullString `json:"first_name"`
	LastName        sql.NullString `json:"last_name"`
	Email           sql.NullString `json:"email"`
}

func (q *Queries) ListPledgePaymentsByStatus(ctx context.Context, status sql.NullString) ([]ListPledgePaymentsByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, ListPledgePaymentsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPledgePaymentsByStatusRow{}
	for rows.Next() {
		var i ListPledgePaymentsByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.PledgeID,
			&i.ContributionID,
			&i.ScheduledAmount,
			&i.ActualAmount,
			&i.ScheduledDate,
			&i.ActualDate,
			&i.Status,
			&i.ReminderCount,
			&i.ReminderDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ContactID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListPledgeReminders = `-- name: ListPledgeReminders :many
SELECT id, pledge_id, pledge_payment_id, reminder_type, scheduled_date, sent_date, status, message_template_id, created_at, updated_at FROM pledge_reminders 
WHERE pledge_id = $1 AND status = $2
ORDER BY scheduled_date
`

type ListPledgeRemindersParams struct {
	PledgeID uuid.UUID      `json:"pledge_id"`
	Status   sql.NullString `json:"status"`
}

func (q *Queries) ListPledgeReminders(ctx context.Context, arg ListPledgeRemindersParams) ([]PledgeReminder, error) {
	rows, err := q.db.QueryContext(ctx, ListPledgeReminders, arg.PledgeID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PledgeReminder{}
	for rows.Next() {
		var i PledgeReminder
		if err := rows.Scan(
			&i.ID,
			&i.PledgeID,
			&i.PledgePaymentID,
			&i.ReminderType,
			&i.ScheduledDate,
			&i.SentDate,
			&i.Status,
			&i.MessageTemplateID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListPledgesByBlock = `-- name: ListPledgesByBlock :many
SELECT p.id, p.contact_id, p.campaign_id, p.pledge_block_id, p.amount, p.installments, p.frequency, p.frequency_interval, p.start_date, p.end_date, p.next_payment_date, p.status, p.currency, p.financial_type_id, p.payment_instrument_id, p.is_test, p.created_at, p.updated_at, c.first_name, c.last_name, c.email
FROM pledges p
INNER JOIN contacts c ON p.contact_id = c.id
WHERE p.pledge_block_id = $1 AND p.status = $2
ORDER BY p.created_at DESC
`

type ListPledgesByBlockParams struct {
	PledgeBlockID uuid.NullUUID  `json:"pledge_block_id"`
	Status        sql.NullString `json:"status"`
}

type ListPledgesByBlockRow struct {
	ID                  uuid.UUID      `json:"id"`
	ContactID           uuid.UUID      `json:"contact_id"`
	CampaignID          uuid.NullUUID  `json:"campaign_id"`
	PledgeBlockID       uuid.NullUUID  `json:"pledge_block_id"`
	Amount              string         `json:"amount"`
	Installments        sql.NullInt32  `json:"installments"`
	Frequency           sql.NullString `json:"frequency"`
	FrequencyInterval   sql.NullInt32  `json:"frequency_interval"`
	StartDate           time.Time      `json:"start_date"`
	EndDate             sql.NullTime   `json:"end_date"`
	NextPaymentDate     sql.NullTime   `json:"next_payment_date"`
	Status              sql.NullString `json:"status"`
	Currency            sql.NullString `json:"currency"`
	FinancialTypeID     uuid.NullUUID  `json:"financial_type_id"`
	PaymentInstrumentID uuid.NullUUID  `json:"payment_instrument_id"`
	IsTest              sql.NullBool   `json:"is_test"`
	CreatedAt           sql.NullTime   `json:"created_at"`
	UpdatedAt           sql.NullTime   `json:"updated_at"`
	FirstName           sql.NullString `json:"first_name"`
	LastName            sql.NullString `json:"last_name"`
	Email               sql.NullString `json:"email"`
}

func (q *Queries) ListPledgesByBlock(ctx context.Context, arg ListPledgesByBlockParams) ([]ListPledgesByBlockRow, error) {
	rows, err := q.db.QueryContext(ctx, ListPledgesByBlock, arg.PledgeBlockID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPledgesByBlockRow{}
	for rows.Next() {
		var i ListPledgesByBlockRow
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.CampaignID,
			&i.PledgeBlockID,
			&i.Amount,
			&i.Installments,
			&i.Frequency,
			&i.FrequencyInterval,
			&i.StartDate,
			&i.EndDate,
			&i.NextPaymentDate,
			&i.Status,
			&i.Currency,
			&i.FinancialTypeID,
			&i.PaymentInstrumentID,
			&i.IsTest,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListPledgesByCampaign = `-- name: ListPledgesByCampaign :many
SELECT p.id, p.contact_id, p.campaign_id, p.pledge_block_id, p.amount, p.installments, p.frequency, p.frequency_interval, p.start_date, p.end_date, p.next_payment_date, p.status, p.currency, p.financial_type_id, p.payment_instrument_id, p.is_test, p.created_at, p.updated_at, c.first_name, c.last_name, c.email
FROM pledges p
INNER JOIN contacts c ON p.contact_id = c.id
WHERE p.campaign_id = $1 AND p.status = $2
ORDER BY p.created_at DESC
`

type ListPledgesByCampaignParams struct {
	CampaignID uuid.NullUUID  `json:"campaign_id"`
	Status     sql.NullString `json:"status"`
}

type ListPledgesByCampaignRow struct {
	ID                  uuid.UUID      `json:"id"`
	ContactID           uuid.UUID      `json:"contact_id"`
	CampaignID          uuid.NullUUID  `json:"campaign_id"`
	PledgeBlockID       uuid.NullUUID  `json:"pledge_block_id"`
	Amount              string         `json:"amount"`
	Installments        sql.NullInt32  `json:"installments"`
	Frequency           sql.NullString `json:"frequency"`
	FrequencyInterval   sql.NullInt32  `json:"frequency_interval"`
	StartDate           time.Time      `json:"start_date"`
	EndDate             sql.NullTime   `json:"end_date"`
	NextPaymentDate     sql.NullTime   `json:"next_payment_date"`
	Status              sql.NullString `json:"status"`
	Currency            sql.NullString `json:"currency"`
	FinancialTypeID     uuid.NullUUID  `json:"financial_type_id"`
	PaymentInstrumentID uuid.NullUUID  `json:"payment_instrument_id"`
	IsTest              sql.NullBool   `json:"is_test"`
	CreatedAt           sql.NullTime   `json:"created_at"`
	UpdatedAt           sql.NullTime   `json:"updated_at"`
	FirstName           sql.NullString `json:"first_name"`
	LastName            sql.NullString `json:"last_name"`
	Email               sql.NullString `json:"email"`
}

func (q *Queries) ListPledgesByCampaign(ctx context.Context, arg ListPledgesByCampaignParams) ([]ListPledgesByCampaignRow, error) {
	rows, err := q.db.QueryContext(ctx, ListPledgesByCampaign, arg.CampaignID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPledgesByCampaignRow{}
	for rows.Next() {
		var i ListPledgesByCampaignRow
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.CampaignID,
			&i.PledgeBlockID,
			&i.Amount,
			&i.Installments,
			&i.Frequency,
			&i.FrequencyInterval,
			&i.StartDate,
			&i.EndDate,
			&i.NextPaymentDate,
			&i.Status,
			&i.Currency,
			&i.FinancialTypeID,
			&i.PaymentInstrumentID,
			&i.IsTest,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListPledgesByContact = `-- name: ListPledgesByContact :many
SELECT id, contact_id, campaign_id, pledge_block_id, amount, installments, frequency, frequency_interval, start_date, end_date, next_payment_date, status, currency, financial_type_id, payment_instrument_id, is_test, created_at, updated_at FROM pledges 
WHERE contact_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListPledgesByContact(ctx context.Context, contactID uuid.UUID) ([]Pledge, error) {
	rows, err := q.db.QueryContext(ctx, ListPledgesByContact, contactID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Pledge{}
	for rows.Next() {
		var i Pledge
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.CampaignID,
			&i.PledgeBlockID,
			&i.Amount,
			&i.Installments,
			&i.Frequency,
			&i.FrequencyInterval,
			&i.StartDate,
			&i.EndDate,
			&i.NextPaymentDate,
			&i.Status,
			&i.Currency,
			&i.FinancialTypeID,
			&i.PaymentInstrumentID,
			&i.IsTest,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListPledgesByStatus = `-- name: ListPledgesByStatus :many
SELECT p.id, p.contact_id, p.campaign_id, p.pledge_block_id, p.amount, p.installments, p.frequency, p.frequency_interval, p.start_date, p.end_date, p.next_payment_date, p.status, p.currency, p.financial_type_id, p.payment_instrument_id, p.is_test, p.created_at, p.updated_at, c.first_name, c.last_name, c.email
FROM pledges p
INNER JOIN contacts c ON p.contact_id = c.id
WHERE p.status = $1
ORDER BY p.next_payment_date ASC
`

type ListPledgesByStatusRow struct {
	ID                  uuid.UUID      `json:"id"`
	ContactID           uuid.UUID      `json:"contact_id"`
	CampaignID          uuid.NullUUID  `json:"campaign_id"`
	PledgeBlockID       uuid.NullUUID  `json:"pledge_block_id"`
	Amount              string         `json:"amount"`
	Installments        sql.NullInt32  `json:"installments"`
	Frequency           sql.NullString `json:"frequency"`
	FrequencyInterval   sql.NullInt32  `json:"frequency_interval"`
	StartDate           time.Time      `json:"start_date"`
	EndDate             sql.NullTime   `json:"end_date"`
	NextPaymentDate     sql.NullTime   `json:"next_payment_date"`
	Status              sql.NullString `json:"status"`
	Currency            sql.NullString `json:"currency"`
	FinancialTypeID     uuid.NullUUID  `json:"financial_type_id"`
	PaymentInstrumentID uuid.NullUUID  `json:"payment_instrument_id"`
	IsTest              sql.NullBool   `json:"is_test"`
	CreatedAt           sql.NullTime   `json:"created_at"`
	UpdatedAt           sql.NullTime   `json:"updated_at"`
	FirstName           sql.NullString `json:"first_name"`
	LastName            sql.NullString `json:"last_name"`
	Email               sql.NullString `json:"email"`
}

func (q *Queries) ListPledgesByStatus(ctx context.Context, status sql.NullString) ([]ListPledgesByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, ListPledgesByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPledgesByStatusRow{}
	for rows.Next() {
		var i ListPledgesByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.CampaignID,
			&i.PledgeBlockID,
			&i.Amount,
			&i.Installments,
			&i.Frequency,
			&i.FrequencyInterval,
			&i.StartDate,
			&i.EndDate,
			&i.NextPaymentDate,
			&i.Status,
			&i.Currency,
			&i.FinancialTypeID,
			&i.PaymentInstrumentID,
			&i.IsTest,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListScheduledReminders = `-- name: ListScheduledReminders :many
SELECT pr.id, pr.pledge_id, pr.pledge_payment_id, pr.reminder_type, pr.scheduled_date, pr.sent_date, pr.status, pr.message_template_id, pr.created_at, pr.updated_at, p.contact_id, c.first_name, c.last_name, c.email
FROM pledge_reminders pr
INNER JOIN pledges p ON pr.pledge_id = p.id
INNER JOIN contacts c ON p.contact_id = c.id
WHERE pr.status = 'Scheduled' AND pr.scheduled_date <= $1
ORDER BY pr.scheduled_date
`

type ListScheduledRemindersRow struct {
	ID                uuid.UUID      `json:"id"`
	PledgeID          uuid.UUID      `json:"pledge_id"`
	PledgePaymentID   uuid.NullUUID  `json:"pledge_payment_id"`
	ReminderType      string         `json:"reminder_type"`
	ScheduledDate     time.Time      `json:"scheduled_date"`
	SentDate          sql.NullTime   `json:"sent_date"`
	Status            sql.NullString `json:"status"`
	MessageTemplateID uuid.NullUUID  `json:"message_template_id"`
	CreatedAt         sql.NullTime   `json:"created_at"`
	UpdatedAt         sql.NullTime   `json:"updated_at"`
	ContactID         uuid.UUID      `json:"contact_id"`
	FirstName         sql.NullString `json:"first_name"`
	LastName          sql.NullString `json:"last_name"`
	Email             sql.NullString `json:"email"`
}

func (q *Queries) ListScheduledReminders(ctx context.Context, scheduledDate time.Time) ([]ListScheduledRemindersRow, error) {
	rows, err := q.db.QueryContext(ctx, ListScheduledReminders, scheduledDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListScheduledRemindersRow{}
	for rows.Next() {
		var i ListScheduledRemindersRow
		if err := rows.Scan(
			&i.ID,
			&i.PledgeID,
			&i.PledgePaymentID,
			&i.ReminderType,
			&i.ScheduledDate,
			&i.SentDate,
			&i.Status,
			&i.MessageTemplateID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ContactID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdatePledge = `-- name: UpdatePledge :one
UPDATE pledges SET
    amount = $2,
    installments = $3,
    frequency = $4,
    frequency_interval = $5,
    start_date = $6,
    end_date = $7,
    next_payment_date = $8,
    status = $9,
    currency = $10,
    financial_type_id = $11,
    payment_instrument_id = $12,
    updated_at = NOW()
WHERE id = $1 RETURNING id, contact_id, campaign_id, pledge_block_id, amount, installments, frequency, frequency_interval, start_date, end_date, next_payment_date, status, currency, financial_type_id, payment_instrument_id, is_test, created_at, updated_at
`

type UpdatePledgeParams struct {
	ID                  uuid.UUID      `json:"id"`
	Amount              string         `json:"amount"`
	Installments        sql.NullInt32  `json:"installments"`
	Frequency           sql.NullString `json:"frequency"`
	FrequencyInterval   sql.NullInt32  `json:"frequency_interval"`
	StartDate           time.Time      `json:"start_date"`
	EndDate             sql.NullTime   `json:"end_date"`
	NextPaymentDate     sql.NullTime   `json:"next_payment_date"`
	Status              sql.NullString `json:"status"`
	Currency            sql.NullString `json:"currency"`
	FinancialTypeID     uuid.NullUUID  `json:"financial_type_id"`
	PaymentInstrumentID uuid.NullUUID  `json:"payment_instrument_id"`
}

func (q *Queries) UpdatePledge(ctx context.Context, arg UpdatePledgeParams) (Pledge, error) {
	row := q.db.QueryRowContext(ctx, UpdatePledge,
		arg.ID,
		arg.Amount,
		arg.Installments,
		arg.Frequency,
		arg.FrequencyInterval,
		arg.StartDate,
		arg.EndDate,
		arg.NextPaymentDate,
		arg.Status,
		arg.Currency,
		arg.FinancialTypeID,
		arg.PaymentInstrumentID,
	)
	var i Pledge
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.CampaignID,
		&i.PledgeBlockID,
		&i.Amount,
		&i.Installments,
		&i.Frequency,
		&i.FrequencyInterval,
		&i.StartDate,
		&i.EndDate,
		&i.NextPaymentDate,
		&i.Status,
		&i.Currency,
		&i.FinancialTypeID,
		&i.PaymentInstrumentID,
		&i.IsTest,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdatePledgeBlock = `-- name: UpdatePledgeBlock :one
UPDATE pledge_blocks SET
    title = $2,
    description = $3,
    campaign_id = $4,
    is_active = $5,
    start_date = $6,
    end_date = $7,
    goal_amount = $8,
    updated_at = NOW()
WHERE id = $1 RETURNING id, name, title, description, campaign_id, is_active, start_date, end_date, goal_amount, created_at, updated_at
`

type UpdatePledgeBlockParams struct {
	ID          uuid.UUID      `json:"id"`
	Title       string         `json:"title"`
	Description sql.NullString `json:"description"`
	CampaignID  uuid.NullUUID  `json:"campaign_id"`
	IsActive    sql.NullBool   `json:"is_active"`
	StartDate   sql.NullTime   `json:"start_date"`
	EndDate     sql.NullTime   `json:"end_date"`
	GoalAmount  sql.NullString `json:"goal_amount"`
}

func (q *Queries) UpdatePledgeBlock(ctx context.Context, arg UpdatePledgeBlockParams) (PledgeBlock, error) {
	row := q.db.QueryRowContext(ctx, UpdatePledgeBlock,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.CampaignID,
		arg.IsActive,
		arg.StartDate,
		arg.EndDate,
		arg.GoalAmount,
	)
	var i PledgeBlock
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Title,
		&i.Description,
		&i.CampaignID,
		&i.IsActive,
		&i.StartDate,
		&i.EndDate,
		&i.GoalAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdatePledgeGroup = `-- name: UpdatePledgeGroup :one
UPDATE pledge_groups SET
    description = $2,
    goal_amount = $3,
    current_amount = $4,
    is_active = $5,
    updated_at = NOW()
WHERE id = $1 RETURNING id, name, description, goal_amount, current_amount, is_active, created_at, updated_at
`

type UpdatePledgeGroupParams struct {
	ID            uuid.UUID      `json:"id"`
	Description   sql.NullString `json:"description"`
	GoalAmount    sql.NullString `json:"goal_amount"`
	CurrentAmount sql.NullString `json:"current_amount"`
	IsActive      sql.NullBool   `json:"is_active"`
}

func (q *Queries) UpdatePledgeGroup(ctx context.Context, arg UpdatePledgeGroupParams) (PledgeGroup, error) {
	row := q.db.QueryRowContext(ctx, UpdatePledgeGroup,
		arg.ID,
		arg.Description,
		arg.GoalAmount,
		arg.CurrentAmount,
		arg.IsActive,
	)
	var i PledgeGroup
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.GoalAmount,
		&i.CurrentAmount,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdatePledgeGroupAmount = `-- name: UpdatePledgeGroupAmount :one
UPDATE pledge_groups SET
    current_amount = $2,
    updated_at = NOW()
WHERE id = $1 RETURNING id, name, description, goal_amount, current_amount, is_active, created_at, updated_at
`

type UpdatePledgeGroupAmountParams struct {
	ID            uuid.UUID      `json:"id"`
	CurrentAmount sql.NullString `json:"current_amount"`
}

func (q *Queries) UpdatePledgeGroupAmount(ctx context.Context, arg UpdatePledgeGroupAmountParams) (PledgeGroup, error) {
	row := q.db.QueryRowContext(ctx, UpdatePledgeGroupAmount, arg.ID, arg.CurrentAmount)
	var i PledgeGroup
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.GoalAmount,
		&i.CurrentAmount,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdatePledgeGroupMember = `-- name: UpdatePledgeGroupMember :one
UPDATE pledge_group_members SET
    role = $3,
    is_active = $4,
    updated_at = NOW()
WHERE pledge_group_id = $1 AND contact_id = $2 RETURNING id, pledge_group_id, contact_id, pledge_id, role, is_active, joined_date, created_at, updated_at
`

type UpdatePledgeGroupMemberParams struct {
	PledgeGroupID uuid.UUID      `json:"pledge_group_id"`
	ContactID     uuid.UUID      `json:"contact_id"`
	Role          sql.NullString `json:"role"`
	IsActive      sql.NullBool   `json:"is_active"`
}

func (q *Queries) UpdatePledgeGroupMember(ctx context.Context, arg UpdatePledgeGroupMemberParams) (PledgeGroupMember, error) {
	row := q.db.QueryRowContext(ctx, UpdatePledgeGroupMember,
		arg.PledgeGroupID,
		arg.ContactID,
		arg.Role,
		arg.IsActive,
	)
	var i PledgeGroupMember
	err := row.Scan(
		&i.ID,
		&i.PledgeGroupID,
		&i.ContactID,
		&i.PledgeID,
		&i.Role,
		&i.IsActive,
		&i.JoinedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdatePledgePayment = `-- name: UpdatePledgePayment :one
UPDATE pledge_payments SET
    actual_amount = $3,
    actual_date = $4,
    status = $5,
    reminder_count = $6,
    reminder_date = $7,
    updated_at = NOW()
WHERE pledge_id = $1 AND scheduled_date = $2 RETURNING id, pledge_id, contribution_id, scheduled_amount, actual_amount, scheduled_date, actual_date, status, reminder_count, reminder_date, created_at, updated_at
`

type UpdatePledgePaymentParams struct {
	PledgeID      uuid.UUID      `json:"pledge_id"`
	ScheduledDate time.Time      `json:"scheduled_date"`
	ActualAmount  sql.NullString `json:"actual_amount"`
	ActualDate    sql.NullTime   `json:"actual_date"`
	Status        sql.NullString `json:"status"`
	ReminderCount sql.NullInt32  `json:"reminder_count"`
	ReminderDate  sql.NullTime   `json:"reminder_date"`
}

func (q *Queries) UpdatePledgePayment(ctx context.Context, arg UpdatePledgePaymentParams) (PledgePayment, error) {
	row := q.db.QueryRowContext(ctx, UpdatePledgePayment,
		arg.PledgeID,
		arg.ScheduledDate,
		arg.ActualAmount,
		arg.ActualDate,
		arg.Status,
		arg.ReminderCount,
		arg.ReminderDate,
	)
	var i PledgePayment
	err := row.Scan(
		&i.ID,
		&i.PledgeID,
		&i.ContributionID,
		&i.ScheduledAmount,
		&i.ActualAmount,
		&i.ScheduledDate,
		&i.ActualDate,
		&i.Status,
		&i.ReminderCount,
		&i.ReminderDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdatePledgePaymentStatus = `-- name: UpdatePledgePaymentStatus :one
UPDATE pledge_payments SET
    status = $3,
    updated_at = NOW()
WHERE pledge_id = $1 AND scheduled_date = $2 RETURNING id, pledge_id, contribution_id, scheduled_amount, actual_amount, scheduled_date, actual_date, status, reminder_count, reminder_date, created_at, updated_at
`

type UpdatePledgePaymentStatusParams struct {
	PledgeID      uuid.UUID      `json:"pledge_id"`
	ScheduledDate time.Time      `json:"scheduled_date"`
	Status        sql.NullString `json:"status"`
}

func (q *Queries) UpdatePledgePaymentStatus(ctx context.Context, arg UpdatePledgePaymentStatusParams) (PledgePayment, error) {
	row := q.db.QueryRowContext(ctx, UpdatePledgePaymentStatus, arg.PledgeID, arg.ScheduledDate, arg.Status)
	var i PledgePayment
	err := row.Scan(
		&i.ID,
		&i.PledgeID,
		&i.ContributionID,
		&i.ScheduledAmount,
		&i.ActualAmount,
		&i.ScheduledDate,
		&i.ActualDate,
		&i.Status,
		&i.ReminderCount,
		&i.ReminderDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdatePledgeStatus = `-- name: UpdatePledgeStatus :one
UPDATE pledges SET
    status = $2,
    next_payment_date = $3,
    updated_at = NOW()
WHERE id = $1 RETURNING id, contact_id, campaign_id, pledge_block_id, amount, installments, frequency, frequency_interval, start_date, end_date, next_payment_date, status, currency, financial_type_id, payment_instrument_id, is_test, created_at, updated_at
`

type UpdatePledgeStatusParams struct {
	ID              uuid.UUID      `json:"id"`
	Status          sql.NullString `json:"status"`
	NextPaymentDate sql.NullTime   `json:"next_payment_date"`
}

func (q *Queries) UpdatePledgeStatus(ctx context.Context, arg UpdatePledgeStatusParams) (Pledge, error) {
	row := q.db.QueryRowContext(ctx, UpdatePledgeStatus, arg.ID, arg.Status, arg.NextPaymentDate)
	var i Pledge
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.CampaignID,
		&i.PledgeBlockID,
		&i.Amount,
		&i.Installments,
		&i.Frequency,
		&i.FrequencyInterval,
		&i.StartDate,
		&i.EndDate,
		&i.NextPaymentDate,
		&i.Status,
		&i.Currency,
		&i.FinancialTypeID,
		&i.PaymentInstrumentID,
		&i.IsTest,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateReminderStatus = `-- name: UpdateReminderStatus :one
UPDATE pledge_reminders SET
    status = $2,
    sent_date = $3,
    updated_at = NOW()
WHERE id = $1 RETURNING id, pledge_id, pledge_payment_id, reminder_type, scheduled_date, sent_date, status, message_template_id, created_at, updated_at
`

type UpdateReminderStatusParams struct {
	ID       uuid.UUID      `json:"id"`
	Status   sql.NullString `json:"status"`
	SentDate sql.NullTime   `json:"sent_date"`
}

func (q *Queries) UpdateReminderStatus(ctx context.Context, arg UpdateReminderStatusParams) (PledgeReminder, error) {
	row := q.db.QueryRowContext(ctx, UpdateReminderStatus, arg.ID, arg.Status, arg.SentDate)
	var i PledgeReminder
	err := row.Scan(
		&i.ID,
		&i.PledgeID,
		&i.PledgePaymentID,
		&i.ReminderType,
		&i.ScheduledDate,
		&i.SentDate,
		&i.Status,
		&i.MessageTemplateID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
