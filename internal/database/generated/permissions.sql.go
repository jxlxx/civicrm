// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: permissions.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const CheckCampaignPermission = `-- name: CheckCampaignPermission :one
SELECT COUNT(*) > 0 as has_permission FROM acls a
INNER JOIN acl_entity_roles aer ON a.entity_id = aer.acl_role_id
WHERE aer.entity_table = 'users' 
AND aer.entity_id = $1 
AND a.entity_table = 'acl_roles'
AND a.operation = $2
AND a.object_table = 'campaigns'
AND (a.object_id = $3 OR a.object_id IS NULL)
AND a.deny = false
AND a.is_active = true
AND aer.is_active = true
ORDER BY a.priority ASC
LIMIT 1
`

type CheckCampaignPermissionParams struct {
	EntityID  uuid.UUID     `json:"entity_id"`
	Operation string        `json:"operation"`
	ObjectID  uuid.NullUUID `json:"object_id"`
}

func (q *Queries) CheckCampaignPermission(ctx context.Context, arg CheckCampaignPermissionParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, CheckCampaignPermission, arg.EntityID, arg.Operation, arg.ObjectID)
	var has_permission bool
	err := row.Scan(&has_permission)
	return has_permission, err
}

const CheckCasePermission = `-- name: CheckCasePermission :one
SELECT COUNT(*) > 0 as has_permission FROM acls a
INNER JOIN acl_entity_roles aer ON a.entity_id = aer.acl_role_id
WHERE aer.entity_table = 'users' 
AND aer.entity_id = $1 
AND a.entity_table = 'acl_roles'
AND a.operation = $2
AND a.object_table = 'cases'
AND (a.object_id = $3 OR a.object_id IS NULL)
AND a.deny = false
AND a.is_active = true
AND aer.is_active = true
ORDER BY a.priority ASC
LIMIT 1
`

type CheckCasePermissionParams struct {
	EntityID  uuid.UUID     `json:"entity_id"`
	Operation string        `json:"operation"`
	ObjectID  uuid.NullUUID `json:"object_id"`
}

func (q *Queries) CheckCasePermission(ctx context.Context, arg CheckCasePermissionParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, CheckCasePermission, arg.EntityID, arg.Operation, arg.ObjectID)
	var has_permission bool
	err := row.Scan(&has_permission)
	return has_permission, err
}

const CheckContactPermission = `-- name: CheckContactPermission :one
SELECT COUNT(*) > 0 as has_permission FROM acls a
INNER JOIN acl_entity_roles aer ON a.entity_id = aer.acl_role_id
WHERE aer.entity_table = 'users' 
AND aer.entity_id = $1 
AND a.entity_table = 'acl_roles'
AND a.operation = $2
AND a.object_table = 'contacts'
AND (a.object_id = $3 OR a.object_id IS NULL)
AND a.deny = false
AND a.is_active = true
AND aer.is_active = true
ORDER BY a.priority ASC
LIMIT 1
`

type CheckContactPermissionParams struct {
	EntityID  uuid.UUID     `json:"entity_id"`
	Operation string        `json:"operation"`
	ObjectID  uuid.NullUUID `json:"object_id"`
}

func (q *Queries) CheckContactPermission(ctx context.Context, arg CheckContactPermissionParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, CheckContactPermission, arg.EntityID, arg.Operation, arg.ObjectID)
	var has_permission bool
	err := row.Scan(&has_permission)
	return has_permission, err
}

const CheckContributionPermission = `-- name: CheckContributionPermission :one
SELECT COUNT(*) > 0 as has_permission FROM acls a
INNER JOIN acl_entity_roles aer ON a.entity_id = aer.acl_role_id
WHERE aer.entity_table = 'users' 
AND aer.entity_id = $1 
AND a.entity_table = 'acl_roles'
AND a.operation = $2
AND a.object_table = 'contributions'
AND (a.object_id = $3 OR a.object_id IS NULL)
AND a.deny = false
AND a.is_active = true
AND aer.is_active = true
ORDER BY a.priority ASC
LIMIT 1
`

type CheckContributionPermissionParams struct {
	EntityID  uuid.UUID     `json:"entity_id"`
	Operation string        `json:"operation"`
	ObjectID  uuid.NullUUID `json:"object_id"`
}

func (q *Queries) CheckContributionPermission(ctx context.Context, arg CheckContributionPermissionParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, CheckContributionPermission, arg.EntityID, arg.Operation, arg.ObjectID)
	var has_permission bool
	err := row.Scan(&has_permission)
	return has_permission, err
}

const CheckEventPermission = `-- name: CheckEventPermission :one
SELECT COUNT(*) > 0 as has_permission FROM acls a
INNER JOIN acl_entity_roles aer ON a.entity_id = aer.acl_role_id
WHERE aer.entity_table = 'users' 
AND aer.entity_id = $1 
AND a.entity_table = 'acl_roles'
AND a.operation = $2
AND a.object_table = 'events'
AND (a.object_id = $3 OR a.object_id IS NULL)
AND a.deny = false
AND a.is_active = true
AND aer.is_active = true
ORDER BY a.priority ASC
LIMIT 1
`

type CheckEventPermissionParams struct {
	EntityID  uuid.UUID     `json:"entity_id"`
	Operation string        `json:"operation"`
	ObjectID  uuid.NullUUID `json:"object_id"`
}

func (q *Queries) CheckEventPermission(ctx context.Context, arg CheckEventPermissionParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, CheckEventPermission, arg.EntityID, arg.Operation, arg.ObjectID)
	var has_permission bool
	err := row.Scan(&has_permission)
	return has_permission, err
}

const CheckGroupPermission = `-- name: CheckGroupPermission :one
SELECT COUNT(*) > 0 as has_permission FROM acls a
INNER JOIN acl_entity_roles aer ON a.entity_id = aer.acl_role_id
WHERE aer.entity_table = 'users' 
AND aer.entity_id = $1 
AND a.entity_table = 'acl_roles'
AND a.operation = $2
AND a.object_table = 'groups'
AND (a.object_id = $3 OR a.object_id IS NULL)
AND a.deny = false
AND a.is_active = true
AND aer.is_active = true
ORDER BY a.priority ASC
LIMIT 1
`

type CheckGroupPermissionParams struct {
	EntityID  uuid.UUID     `json:"entity_id"`
	Operation string        `json:"operation"`
	ObjectID  uuid.NullUUID `json:"object_id"`
}

func (q *Queries) CheckGroupPermission(ctx context.Context, arg CheckGroupPermissionParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, CheckGroupPermission, arg.EntityID, arg.Operation, arg.ObjectID)
	var has_permission bool
	err := row.Scan(&has_permission)
	return has_permission, err
}

const CheckMembershipPermission = `-- name: CheckMembershipPermission :one
SELECT COUNT(*) > 0 as has_permission FROM acls a
INNER JOIN acl_entity_roles aer ON a.entity_id = aer.acl_role_id
WHERE aer.entity_table = 'users' 
AND aer.entity_id = $1 
AND a.entity_table = 'acl_roles'
AND a.operation = $2
AND a.object_table = 'memberships'
AND (a.object_id = $3 OR a.object_id IS NULL)
AND a.deny = false
AND a.is_active = true
AND aer.is_active = true
ORDER BY a.priority ASC
LIMIT 1
`

type CheckMembershipPermissionParams struct {
	EntityID  uuid.UUID     `json:"entity_id"`
	Operation string        `json:"operation"`
	ObjectID  uuid.NullUUID `json:"object_id"`
}

func (q *Queries) CheckMembershipPermission(ctx context.Context, arg CheckMembershipPermissionParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, CheckMembershipPermission, arg.EntityID, arg.Operation, arg.ObjectID)
	var has_permission bool
	err := row.Scan(&has_permission)
	return has_permission, err
}

const CountUserAccessibleCampaigns = `-- name: CountUserAccessibleCampaigns :one
SELECT COUNT(DISTINCT cam.id) FROM campaigns cam
INNER JOIN acl_contact_cache acc ON cam.id = acc.contact_id
WHERE acc.user_id = $1 
AND acc.operation = $2
AND cam.is_active = true
`

type CountUserAccessibleCampaignsParams struct {
	UserID    uuid.NullUUID `json:"user_id"`
	Operation string        `json:"operation"`
}

func (q *Queries) CountUserAccessibleCampaigns(ctx context.Context, arg CountUserAccessibleCampaignsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountUserAccessibleCampaigns, arg.UserID, arg.Operation)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountUserAccessibleCases = `-- name: CountUserAccessibleCases :one
SELECT COUNT(DISTINCT cas.id) FROM cases cas
INNER JOIN acl_contact_cache acc ON cas.id = acc.contact_id
WHERE acc.user_id = $1 
AND acc.operation = $2
AND cas.is_deleted = false
`

type CountUserAccessibleCasesParams struct {
	UserID    uuid.NullUUID `json:"user_id"`
	Operation string        `json:"operation"`
}

func (q *Queries) CountUserAccessibleCases(ctx context.Context, arg CountUserAccessibleCasesParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountUserAccessibleCases, arg.UserID, arg.Operation)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountUserAccessibleContacts = `-- name: CountUserAccessibleContacts :one
SELECT COUNT(DISTINCT c.id) FROM contacts c
INNER JOIN acl_contact_cache acc ON c.id = acc.contact_id
WHERE acc.user_id = $1 
AND acc.operation = $2
AND c.is_active = true
`

type CountUserAccessibleContactsParams struct {
	UserID    uuid.NullUUID `json:"user_id"`
	Operation string        `json:"operation"`
}

func (q *Queries) CountUserAccessibleContacts(ctx context.Context, arg CountUserAccessibleContactsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountUserAccessibleContacts, arg.UserID, arg.Operation)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountUserAccessibleContributions = `-- name: CountUserAccessibleContributions :one
SELECT COUNT(DISTINCT cont.id) FROM contributions cont
INNER JOIN acl_contact_cache acc ON cont.id = acc.contact_id
WHERE acc.user_id = $1 
AND acc.operation = $2
AND cont.status != 'Cancelled'
`

type CountUserAccessibleContributionsParams struct {
	UserID    uuid.NullUUID `json:"user_id"`
	Operation string        `json:"operation"`
}

func (q *Queries) CountUserAccessibleContributions(ctx context.Context, arg CountUserAccessibleContributionsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountUserAccessibleContributions, arg.UserID, arg.Operation)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountUserAccessibleEvents = `-- name: CountUserAccessibleEvents :one
SELECT COUNT(DISTINCT e.id) FROM events e
INNER JOIN acl_contact_cache acc ON e.id = acc.contact_id
WHERE acc.user_id = $1 
AND acc.operation = $2
AND e.is_active = true
`

type CountUserAccessibleEventsParams struct {
	UserID    uuid.NullUUID `json:"user_id"`
	Operation string        `json:"operation"`
}

func (q *Queries) CountUserAccessibleEvents(ctx context.Context, arg CountUserAccessibleEventsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountUserAccessibleEvents, arg.UserID, arg.Operation)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountUserAccessibleGroups = `-- name: CountUserAccessibleGroups :one
SELECT COUNT(DISTINCT g.id) FROM groups g
INNER JOIN acl_contact_cache acc ON g.id = acc.contact_id
WHERE acc.user_id = $1 
AND acc.operation = $2
AND g.is_active = true
`

type CountUserAccessibleGroupsParams struct {
	UserID    uuid.NullUUID `json:"user_id"`
	Operation string        `json:"operation"`
}

func (q *Queries) CountUserAccessibleGroups(ctx context.Context, arg CountUserAccessibleGroupsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountUserAccessibleGroups, arg.UserID, arg.Operation)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountUserAccessibleMemberships = `-- name: CountUserAccessibleMemberships :one
SELECT COUNT(DISTINCT m.id) FROM memberships m
INNER JOIN acl_contact_cache acc ON m.id = acc.contact_id
WHERE acc.user_id = $1 
AND acc.operation = $2
`

type CountUserAccessibleMembershipsParams struct {
	UserID    uuid.NullUUID `json:"user_id"`
	Operation string        `json:"operation"`
}

func (q *Queries) CountUserAccessibleMemberships(ctx context.Context, arg CountUserAccessibleMembershipsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountUserAccessibleMemberships, arg.UserID, arg.Operation)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const GetRolePermissionMatrix = `-- name: GetRolePermissionMatrix :many
SELECT 
    a.operation,
    a.object_table,
    a.object_id,
    a.deny,
    a.priority
FROM acls a
WHERE a.entity_table = 'acl_roles' 
AND a.entity_id = $1 
AND a.is_active = true
ORDER BY a.priority ASC, a.operation, a.object_table
`

type GetRolePermissionMatrixRow struct {
	Operation   string         `json:"operation"`
	ObjectTable sql.NullString `json:"object_table"`
	ObjectID    uuid.NullUUID  `json:"object_id"`
	Deny        bool           `json:"deny"`
	Priority    sql.NullInt32  `json:"priority"`
}

func (q *Queries) GetRolePermissionMatrix(ctx context.Context, entityID uuid.NullUUID) ([]GetRolePermissionMatrixRow, error) {
	rows, err := q.db.QueryContext(ctx, GetRolePermissionMatrix, entityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRolePermissionMatrixRow{}
	for rows.Next() {
		var i GetRolePermissionMatrixRow
		if err := rows.Scan(
			&i.Operation,
			&i.ObjectTable,
			&i.ObjectID,
			&i.Deny,
			&i.Priority,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUserAccessibleCampaigns = `-- name: GetUserAccessibleCampaigns :many
SELECT DISTINCT cam.id, cam.name, cam.title, cam.description, cam.campaign_type_id, cam.status_id, cam.parent_id, cam.is_active, cam.start_date, cam.end_date, cam.goal_revenue, cam.goal_contacts, cam.actual_revenue, cam.actual_contacts, cam.external_identifier, cam.created_date, cam.modified_date, cam.created_at, cam.updated_at FROM campaigns cam
INNER JOIN acl_contact_cache acc ON cam.id = acc.contact_id
WHERE acc.user_id = $1 
AND acc.operation = $2
AND cam.is_active = true
ORDER BY cam.name
LIMIT $3 OFFSET $4
`

type GetUserAccessibleCampaignsParams struct {
	UserID    uuid.NullUUID `json:"user_id"`
	Operation string        `json:"operation"`
	Limit     int32         `json:"limit"`
	Offset    int32         `json:"offset"`
}

func (q *Queries) GetUserAccessibleCampaigns(ctx context.Context, arg GetUserAccessibleCampaignsParams) ([]Campaign, error) {
	rows, err := q.db.QueryContext(ctx, GetUserAccessibleCampaigns,
		arg.UserID,
		arg.Operation,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Campaign{}
	for rows.Next() {
		var i Campaign
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Title,
			&i.Description,
			&i.CampaignTypeID,
			&i.StatusID,
			&i.ParentID,
			&i.IsActive,
			&i.StartDate,
			&i.EndDate,
			&i.GoalRevenue,
			&i.GoalContacts,
			&i.ActualRevenue,
			&i.ActualContacts,
			&i.ExternalIdentifier,
			&i.CreatedDate,
			&i.ModifiedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUserAccessibleCases = `-- name: GetUserAccessibleCases :many
SELECT DISTINCT cas.id, cas.case_type_id, cas.subject, cas.status_id, cas.start_date, cas.end_date, cas.details, cas.is_deleted, cas.created_date, cas.modified_date, cas.created_at, cas.updated_at FROM cases cas
INNER JOIN acl_contact_cache acc ON cas.id = acc.contact_id
WHERE acc.user_id = $1 
AND acc.operation = $2
AND cas.is_deleted = false
ORDER BY cas.created_date DESC
LIMIT $3 OFFSET $4
`

type GetUserAccessibleCasesParams struct {
	UserID    uuid.NullUUID `json:"user_id"`
	Operation string        `json:"operation"`
	Limit     int32         `json:"limit"`
	Offset    int32         `json:"offset"`
}

func (q *Queries) GetUserAccessibleCases(ctx context.Context, arg GetUserAccessibleCasesParams) ([]Case, error) {
	rows, err := q.db.QueryContext(ctx, GetUserAccessibleCases,
		arg.UserID,
		arg.Operation,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Case{}
	for rows.Next() {
		var i Case
		if err := rows.Scan(
			&i.ID,
			&i.CaseTypeID,
			&i.Subject,
			&i.StatusID,
			&i.StartDate,
			&i.EndDate,
			&i.Details,
			&i.IsDeleted,
			&i.CreatedDate,
			&i.ModifiedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUserAccessibleContacts = `-- name: GetUserAccessibleContacts :many
SELECT DISTINCT c.id, c.contact_type, c.first_name, c.last_name, c.organization_name, c.email, c.phone, c.address_line_1, c.address_line_2, c.city, c.state_province, c.postal_code, c.country, c.created_at, c.updated_at FROM contacts c
INNER JOIN acl_contact_cache acc ON c.id = acc.contact_id
WHERE acc.user_id = $1 
AND acc.operation = $2
AND c.is_active = true
ORDER BY c.last_name, c.first_name
LIMIT $3 OFFSET $4
`

type GetUserAccessibleContactsParams struct {
	UserID    uuid.NullUUID `json:"user_id"`
	Operation string        `json:"operation"`
	Limit     int32         `json:"limit"`
	Offset    int32         `json:"offset"`
}

func (q *Queries) GetUserAccessibleContacts(ctx context.Context, arg GetUserAccessibleContactsParams) ([]Contact, error) {
	rows, err := q.db.QueryContext(ctx, GetUserAccessibleContacts,
		arg.UserID,
		arg.Operation,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Contact{}
	for rows.Next() {
		var i Contact
		if err := rows.Scan(
			&i.ID,
			&i.ContactType,
			&i.FirstName,
			&i.LastName,
			&i.OrganizationName,
			&i.Email,
			&i.Phone,
			&i.AddressLine1,
			&i.AddressLine2,
			&i.City,
			&i.StateProvince,
			&i.PostalCode,
			&i.Country,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUserAccessibleContributions = `-- name: GetUserAccessibleContributions :many
SELECT DISTINCT cont.id, cont.contact_id, cont.amount, cont.currency, cont.contribution_type, cont.status, cont.received_date, cont.created_at, cont.updated_at FROM contributions cont
INNER JOIN acl_contact_cache acc ON cont.id = acc.contact_id
WHERE acc.user_id = $1 
AND acc.operation = $2
AND cont.status != 'Cancelled'
ORDER BY cont.received_date DESC
LIMIT $3 OFFSET $4
`

type GetUserAccessibleContributionsParams struct {
	UserID    uuid.NullUUID `json:"user_id"`
	Operation string        `json:"operation"`
	Limit     int32         `json:"limit"`
	Offset    int32         `json:"offset"`
}

func (q *Queries) GetUserAccessibleContributions(ctx context.Context, arg GetUserAccessibleContributionsParams) ([]Contribution, error) {
	rows, err := q.db.QueryContext(ctx, GetUserAccessibleContributions,
		arg.UserID,
		arg.Operation,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Contribution{}
	for rows.Next() {
		var i Contribution
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.Amount,
			&i.Currency,
			&i.ContributionType,
			&i.Status,
			&i.ReceivedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUserAccessibleEvents = `-- name: GetUserAccessibleEvents :many
SELECT DISTINCT e.id, e.title, e.description, e.start_date, e.end_date, e.location, e.max_participants, e.created_at, e.updated_at FROM events e
INNER JOIN acl_contact_cache acc ON e.id = acc.contact_id
WHERE acc.user_id = $1 
AND acc.operation = $2
AND e.is_active = true
ORDER BY e.start_date
LIMIT $3 OFFSET $4
`

type GetUserAccessibleEventsParams struct {
	UserID    uuid.NullUUID `json:"user_id"`
	Operation string        `json:"operation"`
	Limit     int32         `json:"limit"`
	Offset    int32         `json:"offset"`
}

func (q *Queries) GetUserAccessibleEvents(ctx context.Context, arg GetUserAccessibleEventsParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, GetUserAccessibleEvents,
		arg.UserID,
		arg.Operation,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.StartDate,
			&i.EndDate,
			&i.Location,
			&i.MaxParticipants,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUserAccessibleGroups = `-- name: GetUserAccessibleGroups :many
SELECT DISTINCT g.id, g.name, g.title, g.description, g.source, g.saved_search_id, g.is_active, g.visibility, g.where_clause, g.select_tables, g.where_tables, g.group_type, g.cache_date, g.refresh_date, g.parents, g.children, g.is_hidden, g.is_reserved, g.created_at, g.updated_at FROM groups g
INNER JOIN acl_contact_cache acc ON g.id = acc.contact_id
WHERE acc.user_id = $1 
AND acc.operation = $2
AND g.is_active = true
ORDER BY g.name
LIMIT $3 OFFSET $4
`

type GetUserAccessibleGroupsParams struct {
	UserID    uuid.NullUUID `json:"user_id"`
	Operation string        `json:"operation"`
	Limit     int32         `json:"limit"`
	Offset    int32         `json:"offset"`
}

func (q *Queries) GetUserAccessibleGroups(ctx context.Context, arg GetUserAccessibleGroupsParams) ([]Group, error) {
	rows, err := q.db.QueryContext(ctx, GetUserAccessibleGroups,
		arg.UserID,
		arg.Operation,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Group{}
	for rows.Next() {
		var i Group
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Title,
			&i.Description,
			&i.Source,
			&i.SavedSearchID,
			&i.IsActive,
			&i.Visibility,
			&i.WhereClause,
			&i.SelectTables,
			&i.WhereTables,
			&i.GroupType,
			&i.CacheDate,
			&i.RefreshDate,
			&i.Parents,
			&i.Children,
			&i.IsHidden,
			&i.IsReserved,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUserAccessibleMemberships = `-- name: GetUserAccessibleMemberships :many
SELECT DISTINCT m.id, m.contact_id, m.membership_type_id, m.status_id, m.join_date, m.start_date, m.end_date, m.source, m.is_override, m.status_override_end_date, m.is_pay_later, m.contribution_id, m.campaign_id, m.is_test, m.num_terms, m.max_related_contacts, m.created_at, m.updated_at FROM memberships m
INNER JOIN acl_contact_cache acc ON m.id = acc.contact_id
WHERE acc.user_id = $1 
AND acc.operation = $2
ORDER BY m.start_date DESC
LIMIT $3 OFFSET $4
`

type GetUserAccessibleMembershipsParams struct {
	UserID    uuid.NullUUID `json:"user_id"`
	Operation string        `json:"operation"`
	Limit     int32         `json:"limit"`
	Offset    int32         `json:"offset"`
}

func (q *Queries) GetUserAccessibleMemberships(ctx context.Context, arg GetUserAccessibleMembershipsParams) ([]Membership, error) {
	rows, err := q.db.QueryContext(ctx, GetUserAccessibleMemberships,
		arg.UserID,
		arg.Operation,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Membership{}
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.MembershipTypeID,
			&i.StatusID,
			&i.JoinDate,
			&i.StartDate,
			&i.EndDate,
			&i.Source,
			&i.IsOverride,
			&i.StatusOverrideEndDate,
			&i.IsPayLater,
			&i.ContributionID,
			&i.CampaignID,
			&i.IsTest,
			&i.NumTerms,
			&i.MaxRelatedContacts,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUserPermissionMatrix = `-- name: GetUserPermissionMatrix :many
SELECT 
    a.operation,
    a.object_table,
    a.object_id,
    a.deny,
    a.priority,
    ar.name as role_name
FROM acls a
INNER JOIN acl_entity_roles aer ON a.entity_id = aer.acl_role_id
INNER JOIN acl_roles ar ON aer.acl_role_id = ar.id
WHERE aer.entity_table = 'users' 
AND aer.entity_id = $1 
AND a.entity_table = 'acl_roles'
AND a.is_active = true
AND aer.is_active = true
ORDER BY a.priority ASC, a.operation, a.object_table
`

type GetUserPermissionMatrixRow struct {
	Operation   string         `json:"operation"`
	ObjectTable sql.NullString `json:"object_table"`
	ObjectID    uuid.NullUUID  `json:"object_id"`
	Deny        bool           `json:"deny"`
	Priority    sql.NullInt32  `json:"priority"`
	RoleName    string         `json:"role_name"`
}

func (q *Queries) GetUserPermissionMatrix(ctx context.Context, entityID uuid.UUID) ([]GetUserPermissionMatrixRow, error) {
	rows, err := q.db.QueryContext(ctx, GetUserPermissionMatrix, entityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserPermissionMatrixRow{}
	for rows.Next() {
		var i GetUserPermissionMatrixRow
		if err := rows.Scan(
			&i.Operation,
			&i.ObjectTable,
			&i.ObjectID,
			&i.Deny,
			&i.Priority,
			&i.RoleName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUserPermissionSummaryByType = `-- name: GetUserPermissionSummaryByType :many
SELECT 
    a.object_table,
    a.operation,
    COUNT(DISTINCT a.object_id) as object_count,
    a.deny,
    MAX(a.priority) as max_priority
FROM acls a
INNER JOIN acl_entity_roles aer ON a.entity_id = aer.acl_role_id
WHERE aer.entity_table = 'users' 
AND aer.entity_id = $1 
AND a.entity_table = 'acl_roles'
AND a.is_active = true
AND aer.is_active = true
GROUP BY a.object_table, a.operation, a.deny
ORDER BY a.object_table, a.operation
`

type GetUserPermissionSummaryByTypeRow struct {
	ObjectTable sql.NullString `json:"object_table"`
	Operation   string         `json:"operation"`
	ObjectCount int64          `json:"object_count"`
	Deny        bool           `json:"deny"`
	MaxPriority interface{}    `json:"max_priority"`
}

func (q *Queries) GetUserPermissionSummaryByType(ctx context.Context, entityID uuid.UUID) ([]GetUserPermissionSummaryByTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, GetUserPermissionSummaryByType, entityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserPermissionSummaryByTypeRow{}
	for rows.Next() {
		var i GetUserPermissionSummaryByTypeRow
		if err := rows.Scan(
			&i.ObjectTable,
			&i.Operation,
			&i.ObjectCount,
			&i.Deny,
			&i.MaxPriority,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchUserAccessibleContacts = `-- name: SearchUserAccessibleContacts :many
SELECT DISTINCT c.id, c.contact_type, c.first_name, c.last_name, c.organization_name, c.email, c.phone, c.address_line_1, c.address_line_2, c.city, c.state_province, c.postal_code, c.country, c.created_at, c.updated_at FROM contacts c
INNER JOIN acl_contact_cache acc ON c.id = acc.contact_id
WHERE acc.user_id = $1 
AND acc.operation = $2
AND c.is_active = true
AND (
    c.first_name ILIKE '%' || $3 || '%' OR
    c.last_name ILIKE '%' || $3 || '%' OR
    c.email ILIKE '%' || $3 || '%'
)
ORDER BY c.last_name, c.first_name
LIMIT $4 OFFSET $5
`

type SearchUserAccessibleContactsParams struct {
	UserID    uuid.NullUUID  `json:"user_id"`
	Operation string         `json:"operation"`
	Column3   sql.NullString `json:"column_3"`
	Limit     int32          `json:"limit"`
	Offset    int32          `json:"offset"`
}

func (q *Queries) SearchUserAccessibleContacts(ctx context.Context, arg SearchUserAccessibleContactsParams) ([]Contact, error) {
	rows, err := q.db.QueryContext(ctx, SearchUserAccessibleContacts,
		arg.UserID,
		arg.Operation,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Contact{}
	for rows.Next() {
		var i Contact
		if err := rows.Scan(
			&i.ID,
			&i.ContactType,
			&i.FirstName,
			&i.LastName,
			&i.OrganizationName,
			&i.Email,
			&i.Phone,
			&i.AddressLine1,
			&i.AddressLine2,
			&i.City,
			&i.StateProvince,
			&i.PostalCode,
			&i.Country,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchUserAccessibleEvents = `-- name: SearchUserAccessibleEvents :many
SELECT DISTINCT e.id, e.title, e.description, e.start_date, e.end_date, e.location, e.max_participants, e.created_at, e.updated_at FROM events e
INNER JOIN acl_contact_cache acc ON e.id = acc.contact_id
WHERE acc.user_id = $1 
AND acc.operation = $2
AND e.is_active = true
AND e.title ILIKE '%' || $3 || '%'
ORDER BY e.start_date
LIMIT $4 OFFSET $5
`

type SearchUserAccessibleEventsParams struct {
	UserID    uuid.NullUUID  `json:"user_id"`
	Operation string         `json:"operation"`
	Column3   sql.NullString `json:"column_3"`
	Limit     int32          `json:"limit"`
	Offset    int32          `json:"offset"`
}

func (q *Queries) SearchUserAccessibleEvents(ctx context.Context, arg SearchUserAccessibleEventsParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, SearchUserAccessibleEvents,
		arg.UserID,
		arg.Operation,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.StartDate,
			&i.EndDate,
			&i.Location,
			&i.MaxParticipants,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchUserAccessibleGroups = `-- name: SearchUserAccessibleGroups :many
SELECT DISTINCT g.id, g.name, g.title, g.description, g.source, g.saved_search_id, g.is_active, g.visibility, g.where_clause, g.select_tables, g.where_tables, g.group_type, g.cache_date, g.refresh_date, g.parents, g.children, g.is_hidden, g.is_reserved, g.created_at, g.updated_at FROM groups g
INNER JOIN acl_contact_cache acc ON g.id = acc.contact_id
WHERE acc.user_id = $1 
AND acc.operation = $2
AND g.is_active = true
AND g.name ILIKE '%' || $3 || '%'
ORDER BY g.name
LIMIT $4 OFFSET $5
`

type SearchUserAccessibleGroupsParams struct {
	UserID    uuid.NullUUID  `json:"user_id"`
	Operation string         `json:"operation"`
	Column3   sql.NullString `json:"column_3"`
	Limit     int32          `json:"limit"`
	Offset    int32          `json:"offset"`
}

func (q *Queries) SearchUserAccessibleGroups(ctx context.Context, arg SearchUserAccessibleGroupsParams) ([]Group, error) {
	rows, err := q.db.QueryContext(ctx, SearchUserAccessibleGroups,
		arg.UserID,
		arg.Operation,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Group{}
	for rows.Next() {
		var i Group
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Title,
			&i.Description,
			&i.Source,
			&i.SavedSearchID,
			&i.IsActive,
			&i.Visibility,
			&i.WhereClause,
			&i.SelectTables,
			&i.WhereTables,
			&i.GroupType,
			&i.CacheDate,
			&i.RefreshDate,
			&i.Parents,
			&i.Children,
			&i.IsHidden,
			&i.IsReserved,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
