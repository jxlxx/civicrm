// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: domains.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const CountActiveDomains = `-- name: CountActiveDomains :one
SELECT COUNT(*) FROM domains WHERE is_active = TRUE
`

func (q *Queries) CountActiveDomains(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountActiveDomains)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountDomains = `-- name: CountDomains :one
SELECT COUNT(*) FROM domains
`

func (q *Queries) CountDomains(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountDomains)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateDomain = `-- name: CreateDomain :one
INSERT INTO domains (
    name, description, is_active
) VALUES (
    $1, $2, $3
) RETURNING id, name, description, is_active, created_at, updated_at
`

type CreateDomainParams struct {
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	IsActive    sql.NullBool   `json:"is_active"`
}

func (q *Queries) CreateDomain(ctx context.Context, arg CreateDomainParams) (Domain, error) {
	row := q.db.QueryRowContext(ctx, CreateDomain, arg.Name, arg.Description, arg.IsActive)
	var i Domain
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const DeleteDomain = `-- name: DeleteDomain :exec
DELETE FROM domains WHERE id = $1
`

func (q *Queries) DeleteDomain(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteDomain, id)
	return err
}

const GetDomain = `-- name: GetDomain :one
SELECT id, name, description, is_active, created_at, updated_at FROM domains WHERE id = $1
`

func (q *Queries) GetDomain(ctx context.Context, id uuid.UUID) (Domain, error) {
	row := q.db.QueryRowContext(ctx, GetDomain, id)
	var i Domain
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetDomainByName = `-- name: GetDomainByName :one
SELECT id, name, description, is_active, created_at, updated_at FROM domains WHERE name = $1
`

func (q *Queries) GetDomainByName(ctx context.Context, name string) (Domain, error) {
	row := q.db.QueryRowContext(ctx, GetDomainByName, name)
	var i Domain
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetDomainNavigation = `-- name: GetDomainNavigation :many
SELECT n.id, n.domain_id, n.parent_id, n.name, n.label, n.url, n.icon, n.permission, n.weight, n.is_active, n.is_visible, n.created_at, n.updated_at FROM navigation n
INNER JOIN domains d ON n.domain_id = d.id
WHERE d.id = $1 AND n.parent_id IS NULL
ORDER BY n.weight ASC, n.name ASC
`

func (q *Queries) GetDomainNavigation(ctx context.Context, id uuid.UUID) ([]Navigation, error) {
	rows, err := q.db.QueryContext(ctx, GetDomainNavigation, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Navigation{}
	for rows.Next() {
		var i Navigation
		if err := rows.Scan(
			&i.ID,
			&i.DomainID,
			&i.ParentID,
			&i.Name,
			&i.Label,
			&i.Url,
			&i.Icon,
			&i.Permission,
			&i.Weight,
			&i.IsActive,
			&i.IsVisible,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetDomainSettings = `-- name: GetDomainSettings :many
SELECT s.id, s.domain_id, s.name, s.value, s.description, s.is_system, s.is_public, s.created_at, s.updated_at FROM settings s
INNER JOIN domains d ON s.domain_id = d.id
WHERE d.id = $1
ORDER BY s.name ASC
`

func (q *Queries) GetDomainSettings(ctx context.Context, id uuid.UUID) ([]Setting, error) {
	rows, err := q.db.QueryContext(ctx, GetDomainSettings, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Setting{}
	for rows.Next() {
		var i Setting
		if err := rows.Scan(
			&i.ID,
			&i.DomainID,
			&i.Name,
			&i.Value,
			&i.Description,
			&i.IsSystem,
			&i.IsPublic,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetDomainUsers = `-- name: GetDomainUsers :many
SELECT u.id, u.username, u.email, u.hashed_password, u.is_active, u.is_admin, u.last_login, u.created_at, u.updated_at FROM users u
INNER JOIN domains d ON u.domain_id = d.id
WHERE d.id = $1
ORDER BY u.username ASC
`

func (q *Queries) GetDomainUsers(ctx context.Context, id uuid.UUID) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, GetDomainUsers, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.HashedPassword,
			&i.IsActive,
			&i.IsAdmin,
			&i.LastLogin,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListActiveDomains = `-- name: ListActiveDomains :many
SELECT id, name, description, is_active, created_at, updated_at FROM domains 
WHERE is_active = TRUE 
ORDER BY name ASC
`

func (q *Queries) ListActiveDomains(ctx context.Context) ([]Domain, error) {
	rows, err := q.db.QueryContext(ctx, ListActiveDomains)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Domain{}
	for rows.Next() {
		var i Domain
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListDomains = `-- name: ListDomains :many
SELECT id, name, description, is_active, created_at, updated_at FROM domains 
ORDER BY name ASC
`

func (q *Queries) ListDomains(ctx context.Context) ([]Domain, error) {
	rows, err := q.db.QueryContext(ctx, ListDomains)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Domain{}
	for rows.Next() {
		var i Domain
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateDomain = `-- name: UpdateDomain :one
UPDATE domains 
SET 
    name = $2,
    description = $3,
    is_active = $4,
    updated_at = NOW()
WHERE id = $1 
RETURNING id, name, description, is_active, created_at, updated_at
`

type UpdateDomainParams struct {
	ID          uuid.UUID      `json:"id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	IsActive    sql.NullBool   `json:"is_active"`
}

func (q *Queries) UpdateDomain(ctx context.Context, arg UpdateDomainParams) (Domain, error) {
	row := q.db.QueryRowContext(ctx, UpdateDomain,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.IsActive,
	)
	var i Domain
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
