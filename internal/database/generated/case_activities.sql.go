// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: case_activities.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const CreateCaseActivity = `-- name: CreateCaseActivity :one
INSERT INTO case_activities (
    case_id, activity_id, is_deleted
) VALUES (
    $1, $2, $3
) RETURNING id, case_id, activity_id, is_deleted, created_at, updated_at
`

type CreateCaseActivityParams struct {
	CaseID     uuid.UUID    `json:"case_id"`
	ActivityID uuid.UUID    `json:"activity_id"`
	IsDeleted  sql.NullBool `json:"is_deleted"`
}

func (q *Queries) CreateCaseActivity(ctx context.Context, arg CreateCaseActivityParams) (CaseActivity, error) {
	row := q.db.QueryRowContext(ctx, CreateCaseActivity, arg.CaseID, arg.ActivityID, arg.IsDeleted)
	var i CaseActivity
	err := row.Scan(
		&i.ID,
		&i.CaseID,
		&i.ActivityID,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const DeleteCaseActivity = `-- name: DeleteCaseActivity :exec
UPDATE case_activities SET is_deleted = TRUE, updated_at = NOW() WHERE id = $1
`

func (q *Queries) DeleteCaseActivity(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteCaseActivity, id)
	return err
}

const GetCaseActivitiesByActivity = `-- name: GetCaseActivitiesByActivity :one
SELECT id, case_id, activity_id, is_deleted, created_at, updated_at FROM case_activities WHERE activity_id = $1 AND is_deleted = FALSE
`

func (q *Queries) GetCaseActivitiesByActivity(ctx context.Context, activityID uuid.UUID) (CaseActivity, error) {
	row := q.db.QueryRowContext(ctx, GetCaseActivitiesByActivity, activityID)
	var i CaseActivity
	err := row.Scan(
		&i.ID,
		&i.CaseID,
		&i.ActivityID,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetCaseActivitiesByCase = `-- name: GetCaseActivitiesByCase :many
SELECT id, case_id, activity_id, is_deleted, created_at, updated_at FROM case_activities 
WHERE case_id = $1 AND is_deleted = FALSE 
ORDER BY id DESC
`

func (q *Queries) GetCaseActivitiesByCase(ctx context.Context, caseID uuid.UUID) ([]CaseActivity, error) {
	rows, err := q.db.QueryContext(ctx, GetCaseActivitiesByCase, caseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CaseActivity{}
	for rows.Next() {
		var i CaseActivity
		if err := rows.Scan(
			&i.ID,
			&i.CaseID,
			&i.ActivityID,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetCaseActivitiesWithDetails = `-- name: GetCaseActivitiesWithDetails :many
SELECT 
    ca.id, ca.case_id, ca.activity_id, ca.is_deleted, ca.created_at, ca.updated_at,
    a.activity_type_id,
    a.subject,
    a.activity_date_time,
    a.duration,
    a.location,
    a.details,
    at.name as activity_type_name
FROM case_activities ca
JOIN activities a ON ca.activity_id = a.id
JOIN activity_types at ON a.activity_type_id = at.id
WHERE ca.case_id = $1 AND ca.is_deleted = FALSE 
ORDER BY a.activity_date_time DESC
`

type GetCaseActivitiesWithDetailsRow struct {
	ID               uuid.UUID      `json:"id"`
	CaseID           uuid.UUID      `json:"case_id"`
	ActivityID       uuid.UUID      `json:"activity_id"`
	IsDeleted        sql.NullBool   `json:"is_deleted"`
	CreatedAt        sql.NullTime   `json:"created_at"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
	ActivityTypeID   uuid.UUID      `json:"activity_type_id"`
	Subject          sql.NullString `json:"subject"`
	ActivityDateTime time.Time      `json:"activity_date_time"`
	Duration         sql.NullInt32  `json:"duration"`
	Location         sql.NullString `json:"location"`
	Details          sql.NullString `json:"details"`
	ActivityTypeName string         `json:"activity_type_name"`
}

func (q *Queries) GetCaseActivitiesWithDetails(ctx context.Context, caseID uuid.UUID) ([]GetCaseActivitiesWithDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetCaseActivitiesWithDetails, caseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCaseActivitiesWithDetailsRow{}
	for rows.Next() {
		var i GetCaseActivitiesWithDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.CaseID,
			&i.ActivityID,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ActivityTypeID,
			&i.Subject,
			&i.ActivityDateTime,
			&i.Duration,
			&i.Location,
			&i.Details,
			&i.ActivityTypeName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetCaseActivity = `-- name: GetCaseActivity :one
SELECT id, case_id, activity_id, is_deleted, created_at, updated_at FROM case_activities WHERE id = $1 AND is_deleted = FALSE
`

func (q *Queries) GetCaseActivity(ctx context.Context, id uuid.UUID) (CaseActivity, error) {
	row := q.db.QueryRowContext(ctx, GetCaseActivity, id)
	var i CaseActivity
	err := row.Scan(
		&i.ID,
		&i.CaseID,
		&i.ActivityID,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetCaseActivityCount = `-- name: GetCaseActivityCount :one
SELECT COUNT(*) FROM case_activities WHERE case_id = $1 AND is_deleted = FALSE
`

func (q *Queries) GetCaseActivityCount(ctx context.Context, caseID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, GetCaseActivityCount, caseID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const GetCaseActivityStats = `-- name: GetCaseActivityStats :many
SELECT 
    at.name as activity_type,
    COUNT(ca.id) as activity_count
FROM case_activities ca
JOIN activities a ON ca.activity_id = a.id
JOIN activity_types at ON a.activity_type_id = at.id
WHERE ca.case_id = $1 AND ca.is_deleted = FALSE
GROUP BY at.name
ORDER BY at.name
`

type GetCaseActivityStatsRow struct {
	ActivityType  string `json:"activity_type"`
	ActivityCount int64  `json:"activity_count"`
}

func (q *Queries) GetCaseActivityStats(ctx context.Context, caseID uuid.UUID) ([]GetCaseActivityStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetCaseActivityStats, caseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCaseActivityStatsRow{}
	for rows.Next() {
		var i GetCaseActivityStatsRow
		if err := rows.Scan(&i.ActivityType, &i.ActivityCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetCaseTimeline = `-- name: GetCaseTimeline :many
SELECT 
    ca.id as case_activity_id,
    a.activity_date_time,
    a.subject,
    a.details,
    at.name as activity_type,
    c.first_name, c.last_name
FROM case_activities ca
JOIN activities a ON ca.activity_id = a.id
JOIN activity_types at ON a.activity_type_id = at.id
LEFT JOIN activity_contacts ac ON a.id = ac.activity_id AND ac.record_type = 'Activity'
LEFT JOIN contacts c ON ac.contact_id = c.id
WHERE ca.case_id = $1 AND ca.is_deleted = FALSE
ORDER BY a.activity_date_time DESC
`

type GetCaseTimelineRow struct {
	CaseActivityID   uuid.UUID      `json:"case_activity_id"`
	ActivityDateTime time.Time      `json:"activity_date_time"`
	Subject          sql.NullString `json:"subject"`
	Details          sql.NullString `json:"details"`
	ActivityType     string         `json:"activity_type"`
	FirstName        sql.NullString `json:"first_name"`
	LastName         sql.NullString `json:"last_name"`
}

func (q *Queries) GetCaseTimeline(ctx context.Context, caseID uuid.UUID) ([]GetCaseTimelineRow, error) {
	rows, err := q.db.QueryContext(ctx, GetCaseTimeline, caseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCaseTimelineRow{}
	for rows.Next() {
		var i GetCaseTimelineRow
		if err := rows.Scan(
			&i.CaseActivityID,
			&i.ActivityDateTime,
			&i.Subject,
			&i.Details,
			&i.ActivityType,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const HardDeleteCaseActivity = `-- name: HardDeleteCaseActivity :exec
DELETE FROM case_activities WHERE id = $1
`

func (q *Queries) HardDeleteCaseActivity(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, HardDeleteCaseActivity, id)
	return err
}

const ListCaseActivities = `-- name: ListCaseActivities :many
SELECT id, case_id, activity_id, is_deleted, created_at, updated_at FROM case_activities 
WHERE is_deleted = FALSE 
ORDER BY id DESC
`

func (q *Queries) ListCaseActivities(ctx context.Context) ([]CaseActivity, error) {
	rows, err := q.db.QueryContext(ctx, ListCaseActivities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CaseActivity{}
	for rows.Next() {
		var i CaseActivity
		if err := rows.Scan(
			&i.ID,
			&i.CaseID,
			&i.ActivityID,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListCaseActivitiesByDateRange = `-- name: ListCaseActivitiesByDateRange :many
SELECT ca.id, ca.case_id, ca.activity_id, ca.is_deleted, ca.created_at, ca.updated_at FROM case_activities ca
JOIN activities a ON ca.activity_id = a.id
WHERE a.activity_date_time >= $1 AND a.activity_date_time <= $2 
AND ca.is_deleted = FALSE 
ORDER BY a.activity_date_time DESC
`

type ListCaseActivitiesByDateRangeParams struct {
	ActivityDateTime   time.Time `json:"activity_date_time"`
	ActivityDateTime_2 time.Time `json:"activity_date_time_2"`
}

func (q *Queries) ListCaseActivitiesByDateRange(ctx context.Context, arg ListCaseActivitiesByDateRangeParams) ([]CaseActivity, error) {
	rows, err := q.db.QueryContext(ctx, ListCaseActivitiesByDateRange, arg.ActivityDateTime, arg.ActivityDateTime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CaseActivity{}
	for rows.Next() {
		var i CaseActivity
		if err := rows.Scan(
			&i.ID,
			&i.CaseID,
			&i.ActivityID,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListCaseActivitiesByType = `-- name: ListCaseActivitiesByType :many
SELECT ca.id, ca.case_id, ca.activity_id, ca.is_deleted, ca.created_at, ca.updated_at FROM case_activities ca
JOIN activities a ON ca.activity_id = a.id
WHERE a.activity_type_id = $1 AND ca.is_deleted = FALSE 
ORDER BY a.activity_date_time DESC
`

func (q *Queries) ListCaseActivitiesByType(ctx context.Context, activityTypeID uuid.UUID) ([]CaseActivity, error) {
	rows, err := q.db.QueryContext(ctx, ListCaseActivitiesByType, activityTypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CaseActivity{}
	for rows.Next() {
		var i CaseActivity
		if err := rows.Scan(
			&i.ID,
			&i.CaseID,
			&i.ActivityID,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchCaseActivities = `-- name: SearchCaseActivities :many
SELECT ca.id, ca.case_id, ca.activity_id, ca.is_deleted, ca.created_at, ca.updated_at FROM case_activities ca
JOIN activities a ON ca.activity_id = a.id
WHERE (a.subject ILIKE $1 OR a.details ILIKE $1) 
AND ca.is_deleted = FALSE 
ORDER BY a.activity_date_time DESC
`

func (q *Queries) SearchCaseActivities(ctx context.Context, subject sql.NullString) ([]CaseActivity, error) {
	rows, err := q.db.QueryContext(ctx, SearchCaseActivities, subject)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CaseActivity{}
	for rows.Next() {
		var i CaseActivity
		if err := rows.Scan(
			&i.ID,
			&i.CaseID,
			&i.ActivityID,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateCaseActivity = `-- name: UpdateCaseActivity :one
UPDATE case_activities SET
    case_id = $2, activity_id = $3, is_deleted = $4, updated_at = NOW()
WHERE id = $1 RETURNING id, case_id, activity_id, is_deleted, created_at, updated_at
`

type UpdateCaseActivityParams struct {
	ID         uuid.UUID    `json:"id"`
	CaseID     uuid.UUID    `json:"case_id"`
	ActivityID uuid.UUID    `json:"activity_id"`
	IsDeleted  sql.NullBool `json:"is_deleted"`
}

func (q *Queries) UpdateCaseActivity(ctx context.Context, arg UpdateCaseActivityParams) (CaseActivity, error) {
	row := q.db.QueryRowContext(ctx, UpdateCaseActivity,
		arg.ID,
		arg.CaseID,
		arg.ActivityID,
		arg.IsDeleted,
	)
	var i CaseActivity
	err := row.Scan(
		&i.ID,
		&i.CaseID,
		&i.ActivityID,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
