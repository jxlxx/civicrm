// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: case_contacts.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const ActivateCaseContact = `-- name: ActivateCaseContact :exec
UPDATE case_contacts SET is_active = TRUE, updated_at = NOW() WHERE id = $1
`

func (q *Queries) ActivateCaseContact(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, ActivateCaseContact, id)
	return err
}

const CreateCaseContact = `-- name: CreateCaseContact :one
INSERT INTO case_contacts (
    case_id, contact_id, role, start_date, end_date, is_active
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, case_id, contact_id, role, start_date, end_date, is_active, created_at, updated_at
`

type CreateCaseContactParams struct {
	CaseID    uuid.UUID    `json:"case_id"`
	ContactID uuid.UUID    `json:"contact_id"`
	Role      string       `json:"role"`
	StartDate sql.NullTime `json:"start_date"`
	EndDate   sql.NullTime `json:"end_date"`
	IsActive  sql.NullBool `json:"is_active"`
}

func (q *Queries) CreateCaseContact(ctx context.Context, arg CreateCaseContactParams) (CaseContact, error) {
	row := q.db.QueryRowContext(ctx, CreateCaseContact,
		arg.CaseID,
		arg.ContactID,
		arg.Role,
		arg.StartDate,
		arg.EndDate,
		arg.IsActive,
	)
	var i CaseContact
	err := row.Scan(
		&i.ID,
		&i.CaseID,
		&i.ContactID,
		&i.Role,
		&i.StartDate,
		&i.EndDate,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const DeactivateCaseContact = `-- name: DeactivateCaseContact :exec
UPDATE case_contacts SET is_active = FALSE, end_date = NOW(), updated_at = NOW() WHERE id = $1
`

func (q *Queries) DeactivateCaseContact(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeactivateCaseContact, id)
	return err
}

const DeleteCaseContact = `-- name: DeleteCaseContact :exec
DELETE FROM case_contacts WHERE id = $1
`

func (q *Queries) DeleteCaseContact(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteCaseContact, id)
	return err
}

const GetActiveCaseContacts = `-- name: GetActiveCaseContacts :many
SELECT id, case_id, contact_id, role, start_date, end_date, is_active, created_at, updated_at FROM case_contacts 
WHERE case_id = $1 AND is_active = TRUE 
ORDER BY start_date DESC
`

func (q *Queries) GetActiveCaseContacts(ctx context.Context, caseID uuid.UUID) ([]CaseContact, error) {
	rows, err := q.db.QueryContext(ctx, GetActiveCaseContacts, caseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CaseContact{}
	for rows.Next() {
		var i CaseContact
		if err := rows.Scan(
			&i.ID,
			&i.CaseID,
			&i.ContactID,
			&i.Role,
			&i.StartDate,
			&i.EndDate,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetCaseContact = `-- name: GetCaseContact :one
SELECT id, case_id, contact_id, role, start_date, end_date, is_active, created_at, updated_at FROM case_contacts WHERE id = $1
`

func (q *Queries) GetCaseContact(ctx context.Context, id uuid.UUID) (CaseContact, error) {
	row := q.db.QueryRowContext(ctx, GetCaseContact, id)
	var i CaseContact
	err := row.Scan(
		&i.ID,
		&i.CaseID,
		&i.ContactID,
		&i.Role,
		&i.StartDate,
		&i.EndDate,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetCaseContactByCaseAndContact = `-- name: GetCaseContactByCaseAndContact :one
SELECT id, case_id, contact_id, role, start_date, end_date, is_active, created_at, updated_at FROM case_contacts 
WHERE case_id = $1 AND contact_id = $2 
ORDER BY start_date DESC LIMIT 1
`

type GetCaseContactByCaseAndContactParams struct {
	CaseID    uuid.UUID `json:"case_id"`
	ContactID uuid.UUID `json:"contact_id"`
}

func (q *Queries) GetCaseContactByCaseAndContact(ctx context.Context, arg GetCaseContactByCaseAndContactParams) (CaseContact, error) {
	row := q.db.QueryRowContext(ctx, GetCaseContactByCaseAndContact, arg.CaseID, arg.ContactID)
	var i CaseContact
	err := row.Scan(
		&i.ID,
		&i.CaseID,
		&i.ContactID,
		&i.Role,
		&i.StartDate,
		&i.EndDate,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetCaseContactStats = `-- name: GetCaseContactStats :many
SELECT 
    cc.role,
    COUNT(*) as contact_count
FROM case_contacts cc
WHERE cc.is_active = $1
GROUP BY cc.role
ORDER BY cc.role
`

type GetCaseContactStatsRow struct {
	Role         string `json:"role"`
	ContactCount int64  `json:"contact_count"`
}

func (q *Queries) GetCaseContactStats(ctx context.Context, isActive sql.NullBool) ([]GetCaseContactStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetCaseContactStats, isActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCaseContactStatsRow{}
	for rows.Next() {
		var i GetCaseContactStatsRow
		if err := rows.Scan(&i.Role, &i.ContactCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetCaseContactsByCase = `-- name: GetCaseContactsByCase :many
SELECT id, case_id, contact_id, role, start_date, end_date, is_active, created_at, updated_at FROM case_contacts 
WHERE case_id = $1 
ORDER BY start_date DESC
`

func (q *Queries) GetCaseContactsByCase(ctx context.Context, caseID uuid.UUID) ([]CaseContact, error) {
	rows, err := q.db.QueryContext(ctx, GetCaseContactsByCase, caseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CaseContact{}
	for rows.Next() {
		var i CaseContact
		if err := rows.Scan(
			&i.ID,
			&i.CaseID,
			&i.ContactID,
			&i.Role,
			&i.StartDate,
			&i.EndDate,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetCaseContactsByContact = `-- name: GetCaseContactsByContact :many
SELECT id, case_id, contact_id, role, start_date, end_date, is_active, created_at, updated_at FROM case_contacts 
WHERE contact_id = $1 
ORDER BY start_date DESC
`

func (q *Queries) GetCaseContactsByContact(ctx context.Context, contactID uuid.UUID) ([]CaseContact, error) {
	rows, err := q.db.QueryContext(ctx, GetCaseContactsByContact, contactID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CaseContact{}
	for rows.Next() {
		var i CaseContact
		if err := rows.Scan(
			&i.ID,
			&i.CaseID,
			&i.ContactID,
			&i.Role,
			&i.StartDate,
			&i.EndDate,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetCaseContactsByRole = `-- name: GetCaseContactsByRole :many
SELECT id, case_id, contact_id, role, start_date, end_date, is_active, created_at, updated_at FROM case_contacts 
WHERE case_id = $1 AND role = $2 
ORDER BY start_date DESC
`

type GetCaseContactsByRoleParams struct {
	CaseID uuid.UUID `json:"case_id"`
	Role   string    `json:"role"`
}

func (q *Queries) GetCaseContactsByRole(ctx context.Context, arg GetCaseContactsByRoleParams) ([]CaseContact, error) {
	rows, err := q.db.QueryContext(ctx, GetCaseContactsByRole, arg.CaseID, arg.Role)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CaseContact{}
	for rows.Next() {
		var i CaseContact
		if err := rows.Scan(
			&i.ID,
			&i.CaseID,
			&i.ContactID,
			&i.Role,
			&i.StartDate,
			&i.EndDate,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetCaseParticipantSummary = `-- name: GetCaseParticipantSummary :many
SELECT 
    c.id as case_id,
    c.subject as case_subject,
    COUNT(cc.id) as participant_count,
    STRING_AGG(cc.role, ', ') as roles
FROM cases c
LEFT JOIN case_contacts cc ON c.id = cc.case_id AND cc.is_active = TRUE
WHERE c.is_deleted = FALSE
GROUP BY c.id, c.subject
ORDER BY c.start_date DESC
`

type GetCaseParticipantSummaryRow struct {
	CaseID           uuid.UUID `json:"case_id"`
	CaseSubject      string    `json:"case_subject"`
	ParticipantCount int64     `json:"participant_count"`
	Roles            []byte    `json:"roles"`
}

func (q *Queries) GetCaseParticipantSummary(ctx context.Context) ([]GetCaseParticipantSummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, GetCaseParticipantSummary)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCaseParticipantSummaryRow{}
	for rows.Next() {
		var i GetCaseParticipantSummaryRow
		if err := rows.Scan(
			&i.CaseID,
			&i.CaseSubject,
			&i.ParticipantCount,
			&i.Roles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListActiveCaseContacts = `-- name: ListActiveCaseContacts :many
SELECT id, case_id, contact_id, role, start_date, end_date, is_active, created_at, updated_at FROM case_contacts 
WHERE is_active = TRUE 
ORDER BY start_date DESC
`

func (q *Queries) ListActiveCaseContacts(ctx context.Context) ([]CaseContact, error) {
	rows, err := q.db.QueryContext(ctx, ListActiveCaseContacts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CaseContact{}
	for rows.Next() {
		var i CaseContact
		if err := rows.Scan(
			&i.ID,
			&i.CaseID,
			&i.ContactID,
			&i.Role,
			&i.StartDate,
			&i.EndDate,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListCaseContacts = `-- name: ListCaseContacts :many
SELECT id, case_id, contact_id, role, start_date, end_date, is_active, created_at, updated_at FROM case_contacts 
ORDER BY start_date DESC
`

func (q *Queries) ListCaseContacts(ctx context.Context) ([]CaseContact, error) {
	rows, err := q.db.QueryContext(ctx, ListCaseContacts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CaseContact{}
	for rows.Next() {
		var i CaseContact
		if err := rows.Scan(
			&i.ID,
			&i.CaseID,
			&i.ContactID,
			&i.Role,
			&i.StartDate,
			&i.EndDate,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListCaseContactsByDateRange = `-- name: ListCaseContactsByDateRange :many
SELECT id, case_id, contact_id, role, start_date, end_date, is_active, created_at, updated_at FROM case_contacts 
WHERE start_date >= $1 AND start_date <= $2 
ORDER BY start_date DESC
`

type ListCaseContactsByDateRangeParams struct {
	StartDate   sql.NullTime `json:"start_date"`
	StartDate_2 sql.NullTime `json:"start_date_2"`
}

func (q *Queries) ListCaseContactsByDateRange(ctx context.Context, arg ListCaseContactsByDateRangeParams) ([]CaseContact, error) {
	rows, err := q.db.QueryContext(ctx, ListCaseContactsByDateRange, arg.StartDate, arg.StartDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CaseContact{}
	for rows.Next() {
		var i CaseContact
		if err := rows.Scan(
			&i.ID,
			&i.CaseID,
			&i.ContactID,
			&i.Role,
			&i.StartDate,
			&i.EndDate,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListCaseContactsByRole = `-- name: ListCaseContactsByRole :many
SELECT id, case_id, contact_id, role, start_date, end_date, is_active, created_at, updated_at FROM case_contacts 
WHERE role = $1 
ORDER BY start_date DESC
`

func (q *Queries) ListCaseContactsByRole(ctx context.Context, role string) ([]CaseContact, error) {
	rows, err := q.db.QueryContext(ctx, ListCaseContactsByRole, role)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CaseContact{}
	for rows.Next() {
		var i CaseContact
		if err := rows.Scan(
			&i.ID,
			&i.CaseID,
			&i.ContactID,
			&i.Role,
			&i.StartDate,
			&i.EndDate,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchCaseContacts = `-- name: SearchCaseContacts :many
SELECT cc.id, cc.case_id, cc.contact_id, cc.role, cc.start_date, cc.end_date, cc.is_active, cc.created_at, cc.updated_at FROM case_contacts cc
JOIN contacts c ON cc.contact_id = c.id
WHERE (c.first_name ILIKE $1 OR c.last_name ILIKE $1 OR c.organization_name ILIKE $1)
ORDER BY cc.start_date DESC
`

func (q *Queries) SearchCaseContacts(ctx context.Context, firstName sql.NullString) ([]CaseContact, error) {
	rows, err := q.db.QueryContext(ctx, SearchCaseContacts, firstName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CaseContact{}
	for rows.Next() {
		var i CaseContact
		if err := rows.Scan(
			&i.ID,
			&i.CaseID,
			&i.ContactID,
			&i.Role,
			&i.StartDate,
			&i.EndDate,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateCaseContact = `-- name: UpdateCaseContact :one
UPDATE case_contacts SET
    case_id = $2, contact_id = $3, role = $4, start_date = $5,
    end_date = $6, is_active = $7, updated_at = NOW()
WHERE id = $1 RETURNING id, case_id, contact_id, role, start_date, end_date, is_active, created_at, updated_at
`

type UpdateCaseContactParams struct {
	ID        uuid.UUID    `json:"id"`
	CaseID    uuid.UUID    `json:"case_id"`
	ContactID uuid.UUID    `json:"contact_id"`
	Role      string       `json:"role"`
	StartDate sql.NullTime `json:"start_date"`
	EndDate   sql.NullTime `json:"end_date"`
	IsActive  sql.NullBool `json:"is_active"`
}

func (q *Queries) UpdateCaseContact(ctx context.Context, arg UpdateCaseContactParams) (CaseContact, error) {
	row := q.db.QueryRowContext(ctx, UpdateCaseContact,
		arg.ID,
		arg.CaseID,
		arg.ContactID,
		arg.Role,
		arg.StartDate,
		arg.EndDate,
		arg.IsActive,
	)
	var i CaseContact
	err := row.Scan(
		&i.ID,
		&i.CaseID,
		&i.ContactID,
		&i.Role,
		&i.StartDate,
		&i.EndDate,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateCaseContactRole = `-- name: UpdateCaseContactRole :exec
UPDATE case_contacts SET role = $2, updated_at = NOW() WHERE id = $1
`

type UpdateCaseContactRoleParams struct {
	ID   uuid.UUID `json:"id"`
	Role string    `json:"role"`
}

func (q *Queries) UpdateCaseContactRole(ctx context.Context, arg UpdateCaseContactRoleParams) error {
	_, err := q.db.ExecContext(ctx, UpdateCaseContactRole, arg.ID, arg.Role)
	return err
}
