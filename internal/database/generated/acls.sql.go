// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: acls.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const CheckUserPermission = `-- name: CheckUserPermission :one
SELECT COUNT(*) > 0 as has_permission FROM acls a
INNER JOIN acl_entity_roles aer ON a.entity_id = aer.acl_role_id
WHERE aer.entity_table = 'users' 
AND aer.entity_id = $1 
AND a.entity_table = 'acl_roles'
AND a.operation = $2
AND a.object_table = $3
AND (a.object_id = $4 OR a.object_id IS NULL)
AND a.deny = false
AND a.is_active = true
AND aer.is_active = true
ORDER BY a.priority ASC
LIMIT 1
`

type CheckUserPermissionParams struct {
	EntityID    uuid.UUID      `json:"entity_id"`
	Operation   string         `json:"operation"`
	ObjectTable sql.NullString `json:"object_table"`
	ObjectID    uuid.NullUUID  `json:"object_id"`
}

func (q *Queries) CheckUserPermission(ctx context.Context, arg CheckUserPermissionParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, CheckUserPermission,
		arg.EntityID,
		arg.Operation,
		arg.ObjectTable,
		arg.ObjectID,
	)
	var has_permission bool
	err := row.Scan(&has_permission)
	return has_permission, err
}

const CreateACL = `-- name: CreateACL :one
INSERT INTO acls (
    name, deny, entity_table, entity_id, operation, object_table, object_id, acl_table, acl_id, is_active, priority
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, name, deny, entity_table, entity_id, operation, object_table, object_id, acl_table, acl_id, is_active, priority, created_at, updated_at
`

type CreateACLParams struct {
	Name        string         `json:"name"`
	Deny        bool           `json:"deny"`
	EntityTable string         `json:"entity_table"`
	EntityID    uuid.NullUUID  `json:"entity_id"`
	Operation   string         `json:"operation"`
	ObjectTable sql.NullString `json:"object_table"`
	ObjectID    uuid.NullUUID  `json:"object_id"`
	AclTable    sql.NullString `json:"acl_table"`
	AclID       uuid.NullUUID  `json:"acl_id"`
	IsActive    sql.NullBool   `json:"is_active"`
	Priority    sql.NullInt32  `json:"priority"`
}

func (q *Queries) CreateACL(ctx context.Context, arg CreateACLParams) (Acl, error) {
	row := q.db.QueryRowContext(ctx, CreateACL,
		arg.Name,
		arg.Deny,
		arg.EntityTable,
		arg.EntityID,
		arg.Operation,
		arg.ObjectTable,
		arg.ObjectID,
		arg.AclTable,
		arg.AclID,
		arg.IsActive,
		arg.Priority,
	)
	var i Acl
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Deny,
		&i.EntityTable,
		&i.EntityID,
		&i.Operation,
		&i.ObjectTable,
		&i.ObjectID,
		&i.AclTable,
		&i.AclID,
		&i.IsActive,
		&i.Priority,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const CreateACLCache = `-- name: CreateACLCache :one
INSERT INTO acl_cache (
    contact_id, acl_id
) VALUES (
    $1, $2
) RETURNING id, contact_id, acl_id, modified_date
`

type CreateACLCacheParams struct {
	ContactID uuid.NullUUID `json:"contact_id"`
	AclID     uuid.UUID     `json:"acl_id"`
}

func (q *Queries) CreateACLCache(ctx context.Context, arg CreateACLCacheParams) (AclCache, error) {
	row := q.db.QueryRowContext(ctx, CreateACLCache, arg.ContactID, arg.AclID)
	var i AclCache
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.AclID,
		&i.ModifiedDate,
	)
	return i, err
}

const CreateACLContactCache = `-- name: CreateACLContactCache :one
INSERT INTO acl_contact_cache (
    user_id, contact_id, operation, domain_id
) VALUES (
    $1, $2, $3, $4
) RETURNING id, user_id, contact_id, operation, domain_id, created_at
`

type CreateACLContactCacheParams struct {
	UserID    uuid.NullUUID `json:"user_id"`
	ContactID uuid.UUID     `json:"contact_id"`
	Operation string        `json:"operation"`
	DomainID  uuid.UUID     `json:"domain_id"`
}

func (q *Queries) CreateACLContactCache(ctx context.Context, arg CreateACLContactCacheParams) (AclContactCache, error) {
	row := q.db.QueryRowContext(ctx, CreateACLContactCache,
		arg.UserID,
		arg.ContactID,
		arg.Operation,
		arg.DomainID,
	)
	var i AclContactCache
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ContactID,
		&i.Operation,
		&i.DomainID,
		&i.CreatedAt,
	)
	return i, err
}

const CreateACLEntityRole = `-- name: CreateACLEntityRole :one
INSERT INTO acl_entity_roles (
    acl_role_id, entity_table, entity_id, is_active
) VALUES (
    $1, $2, $3, $4
) RETURNING id, acl_role_id, entity_table, entity_id, is_active, created_at, updated_at
`

type CreateACLEntityRoleParams struct {
	AclRoleID   uuid.UUID    `json:"acl_role_id"`
	EntityTable string       `json:"entity_table"`
	EntityID    uuid.UUID    `json:"entity_id"`
	IsActive    sql.NullBool `json:"is_active"`
}

func (q *Queries) CreateACLEntityRole(ctx context.Context, arg CreateACLEntityRoleParams) (AclEntityRole, error) {
	row := q.db.QueryRowContext(ctx, CreateACLEntityRole,
		arg.AclRoleID,
		arg.EntityTable,
		arg.EntityID,
		arg.IsActive,
	)
	var i AclEntityRole
	err := row.Scan(
		&i.ID,
		&i.AclRoleID,
		&i.EntityTable,
		&i.EntityID,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const CreateACLRole = `-- name: CreateACLRole :one
INSERT INTO acl_roles (
    name, label, description, is_active
) VALUES (
    $1, $2, $3, $4
) RETURNING id, name, label, description, is_active, created_at, updated_at
`

type CreateACLRoleParams struct {
	Name        string         `json:"name"`
	Label       string         `json:"label"`
	Description sql.NullString `json:"description"`
	IsActive    sql.NullBool   `json:"is_active"`
}

func (q *Queries) CreateACLRole(ctx context.Context, arg CreateACLRoleParams) (AclRole, error) {
	row := q.db.QueryRowContext(ctx, CreateACLRole,
		arg.Name,
		arg.Label,
		arg.Description,
		arg.IsActive,
	)
	var i AclRole
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Label,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const DeleteACL = `-- name: DeleteACL :exec
UPDATE acls
SET is_active = false, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteACL(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteACL, id)
	return err
}

const DeleteACLCache = `-- name: DeleteACLCache :exec
DELETE FROM acl_cache
WHERE contact_id = $1
`

func (q *Queries) DeleteACLCache(ctx context.Context, contactID uuid.NullUUID) error {
	_, err := q.db.ExecContext(ctx, DeleteACLCache, contactID)
	return err
}

const DeleteACLContactCache = `-- name: DeleteACLContactCache :exec
DELETE FROM acl_contact_cache
WHERE user_id = $1 AND operation = $2
`

type DeleteACLContactCacheParams struct {
	UserID    uuid.NullUUID `json:"user_id"`
	Operation string        `json:"operation"`
}

func (q *Queries) DeleteACLContactCache(ctx context.Context, arg DeleteACLContactCacheParams) error {
	_, err := q.db.ExecContext(ctx, DeleteACLContactCache, arg.UserID, arg.Operation)
	return err
}

const DeleteACLContactCacheByContact = `-- name: DeleteACLContactCacheByContact :exec
DELETE FROM acl_contact_cache
WHERE contact_id = $1 AND operation = $2
`

type DeleteACLContactCacheByContactParams struct {
	ContactID uuid.UUID `json:"contact_id"`
	Operation string    `json:"operation"`
}

func (q *Queries) DeleteACLContactCacheByContact(ctx context.Context, arg DeleteACLContactCacheByContactParams) error {
	_, err := q.db.ExecContext(ctx, DeleteACLContactCacheByContact, arg.ContactID, arg.Operation)
	return err
}

const DeleteACLEntityRole = `-- name: DeleteACLEntityRole :exec
UPDATE acl_entity_roles
SET is_active = false, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteACLEntityRole(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteACLEntityRole, id)
	return err
}

const DeleteACLRole = `-- name: DeleteACLRole :exec
UPDATE acl_roles
SET is_active = false, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteACLRole(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteACLRole, id)
	return err
}

const GetACL = `-- name: GetACL :one
SELECT id, name, deny, entity_table, entity_id, operation, object_table, object_id, acl_table, acl_id, is_active, priority, created_at, updated_at FROM acls
WHERE id = $1 AND is_active = true
`

func (q *Queries) GetACL(ctx context.Context, id uuid.UUID) (Acl, error) {
	row := q.db.QueryRowContext(ctx, GetACL, id)
	var i Acl
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Deny,
		&i.EntityTable,
		&i.EntityID,
		&i.Operation,
		&i.ObjectTable,
		&i.ObjectID,
		&i.AclTable,
		&i.AclID,
		&i.IsActive,
		&i.Priority,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetACLCache = `-- name: GetACLCache :many
SELECT id, contact_id, acl_id, modified_date FROM acl_cache
WHERE contact_id = $1
`

func (q *Queries) GetACLCache(ctx context.Context, contactID uuid.NullUUID) ([]AclCache, error) {
	rows, err := q.db.QueryContext(ctx, GetACLCache, contactID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AclCache{}
	for rows.Next() {
		var i AclCache
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.AclID,
			&i.ModifiedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetACLContactCache = `-- name: GetACLContactCache :many
SELECT id, user_id, contact_id, operation, domain_id, created_at FROM acl_contact_cache
WHERE user_id = $1 AND operation = $2
`

type GetACLContactCacheParams struct {
	UserID    uuid.NullUUID `json:"user_id"`
	Operation string        `json:"operation"`
}

func (q *Queries) GetACLContactCache(ctx context.Context, arg GetACLContactCacheParams) ([]AclContactCache, error) {
	rows, err := q.db.QueryContext(ctx, GetACLContactCache, arg.UserID, arg.Operation)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AclContactCache{}
	for rows.Next() {
		var i AclContactCache
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ContactID,
			&i.Operation,
			&i.DomainID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetACLContactCacheByContact = `-- name: GetACLContactCacheByContact :many
SELECT id, user_id, contact_id, operation, domain_id, created_at FROM acl_contact_cache
WHERE contact_id = $1 AND operation = $2
`

type GetACLContactCacheByContactParams struct {
	ContactID uuid.UUID `json:"contact_id"`
	Operation string    `json:"operation"`
}

func (q *Queries) GetACLContactCacheByContact(ctx context.Context, arg GetACLContactCacheByContactParams) ([]AclContactCache, error) {
	rows, err := q.db.QueryContext(ctx, GetACLContactCacheByContact, arg.ContactID, arg.Operation)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AclContactCache{}
	for rows.Next() {
		var i AclContactCache
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ContactID,
			&i.Operation,
			&i.DomainID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetACLEntityRole = `-- name: GetACLEntityRole :one
SELECT id, acl_role_id, entity_table, entity_id, is_active, created_at, updated_at FROM acl_entity_roles
WHERE id = $1 AND is_active = true
`

func (q *Queries) GetACLEntityRole(ctx context.Context, id uuid.UUID) (AclEntityRole, error) {
	row := q.db.QueryRowContext(ctx, GetACLEntityRole, id)
	var i AclEntityRole
	err := row.Scan(
		&i.ID,
		&i.AclRoleID,
		&i.EntityTable,
		&i.EntityID,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetACLRole = `-- name: GetACLRole :one
SELECT id, name, label, description, is_active, created_at, updated_at FROM acl_roles
WHERE id = $1 AND is_active = true
`

func (q *Queries) GetACLRole(ctx context.Context, id uuid.UUID) (AclRole, error) {
	row := q.db.QueryRowContext(ctx, GetACLRole, id)
	var i AclRole
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Label,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetACLRoleByName = `-- name: GetACLRoleByName :one
SELECT id, name, label, description, is_active, created_at, updated_at FROM acl_roles
WHERE name = $1 AND is_active = true
`

func (q *Queries) GetACLRoleByName(ctx context.Context, name string) (AclRole, error) {
	row := q.db.QueryRowContext(ctx, GetACLRoleByName, name)
	var i AclRole
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Label,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetACLStats = `-- name: GetACLStats :one
SELECT 
    COUNT(*) as total_acls,
    COUNT(CASE WHEN deny = true THEN 1 END) as deny_rules,
    COUNT(CASE WHEN deny = false THEN 1 END) as allow_rules,
    COUNT(DISTINCT entity_id) as unique_entities,
    COUNT(DISTINCT operation) as unique_operations
FROM acls
WHERE is_active = true
`

type GetACLStatsRow struct {
	TotalAcls        int64 `json:"total_acls"`
	DenyRules        int64 `json:"deny_rules"`
	AllowRules       int64 `json:"allow_rules"`
	UniqueEntities   int64 `json:"unique_entities"`
	UniqueOperations int64 `json:"unique_operations"`
}

func (q *Queries) GetACLStats(ctx context.Context) (GetACLStatsRow, error) {
	row := q.db.QueryRowContext(ctx, GetACLStats)
	var i GetACLStatsRow
	err := row.Scan(
		&i.TotalAcls,
		&i.DenyRules,
		&i.AllowRules,
		&i.UniqueEntities,
		&i.UniqueOperations,
	)
	return i, err
}

const GetContactsForUser = `-- name: GetContactsForUser :many
SELECT DISTINCT c.id, c.contact_type, c.first_name, c.last_name, c.organization_name, c.email, c.phone, c.address_line_1, c.address_line_2, c.city, c.state_province, c.postal_code, c.country, c.created_at, c.updated_at FROM contacts c
INNER JOIN acl_contact_cache acc ON c.id = acc.contact_id
WHERE acc.user_id = $1 
AND acc.operation = $2
AND c.is_active = true
ORDER BY c.last_name, c.first_name
`

type GetContactsForUserParams struct {
	UserID    uuid.NullUUID `json:"user_id"`
	Operation string        `json:"operation"`
}

func (q *Queries) GetContactsForUser(ctx context.Context, arg GetContactsForUserParams) ([]Contact, error) {
	rows, err := q.db.QueryContext(ctx, GetContactsForUser, arg.UserID, arg.Operation)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Contact{}
	for rows.Next() {
		var i Contact
		if err := rows.Scan(
			&i.ID,
			&i.ContactType,
			&i.FirstName,
			&i.LastName,
			&i.OrganizationName,
			&i.Email,
			&i.Phone,
			&i.AddressLine1,
			&i.AddressLine2,
			&i.City,
			&i.StateProvince,
			&i.PostalCode,
			&i.Country,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetEventsForUser = `-- name: GetEventsForUser :many
SELECT DISTINCT e.id, e.title, e.description, e.start_date, e.end_date, e.location, e.max_participants, e.created_at, e.updated_at FROM events e
INNER JOIN acl_contact_cache acc ON e.id = acc.contact_id
WHERE acc.user_id = $1 
AND acc.operation = $2
AND e.is_active = true
ORDER BY e.start_date
`

type GetEventsForUserParams struct {
	UserID    uuid.NullUUID `json:"user_id"`
	Operation string        `json:"operation"`
}

func (q *Queries) GetEventsForUser(ctx context.Context, arg GetEventsForUserParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, GetEventsForUser, arg.UserID, arg.Operation)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.StartDate,
			&i.EndDate,
			&i.Location,
			&i.MaxParticipants,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetGroupsForUser = `-- name: GetGroupsForUser :many
SELECT DISTINCT g.id, g.name, g.title, g.description, g.source, g.saved_search_id, g.is_active, g.visibility, g.where_clause, g.select_tables, g.where_tables, g.group_type, g.cache_date, g.refresh_date, g.parents, g.children, g.is_hidden, g.is_reserved, g.created_at, g.updated_at FROM groups g
INNER JOIN acl_contact_cache acc ON g.id = acc.contact_id
WHERE acc.user_id = $1 
AND acc.operation = $2
AND g.is_active = true
ORDER BY g.name
`

type GetGroupsForUserParams struct {
	UserID    uuid.NullUUID `json:"user_id"`
	Operation string        `json:"operation"`
}

func (q *Queries) GetGroupsForUser(ctx context.Context, arg GetGroupsForUserParams) ([]Group, error) {
	rows, err := q.db.QueryContext(ctx, GetGroupsForUser, arg.UserID, arg.Operation)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Group{}
	for rows.Next() {
		var i Group
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Title,
			&i.Description,
			&i.Source,
			&i.SavedSearchID,
			&i.IsActive,
			&i.Visibility,
			&i.WhereClause,
			&i.SelectTables,
			&i.WhereTables,
			&i.GroupType,
			&i.CacheDate,
			&i.RefreshDate,
			&i.Parents,
			&i.Children,
			&i.IsHidden,
			&i.IsReserved,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetRolePermissionSummary = `-- name: GetRolePermissionSummary :many
SELECT 
    a.operation,
    a.object_table,
    COUNT(DISTINCT a.object_id) as object_count,
    a.deny
FROM acls a
WHERE a.entity_table = 'acl_roles' 
AND a.entity_id = $1 
AND a.is_active = true
GROUP BY a.operation, a.object_table, a.deny
ORDER BY a.operation, a.object_table
`

type GetRolePermissionSummaryRow struct {
	Operation   string         `json:"operation"`
	ObjectTable sql.NullString `json:"object_table"`
	ObjectCount int64          `json:"object_count"`
	Deny        bool           `json:"deny"`
}

func (q *Queries) GetRolePermissionSummary(ctx context.Context, entityID uuid.NullUUID) ([]GetRolePermissionSummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, GetRolePermissionSummary, entityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRolePermissionSummaryRow{}
	for rows.Next() {
		var i GetRolePermissionSummaryRow
		if err := rows.Scan(
			&i.Operation,
			&i.ObjectTable,
			&i.ObjectCount,
			&i.Deny,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUserPermissionSummary = `-- name: GetUserPermissionSummary :many
SELECT 
    a.operation,
    a.object_table,
    COUNT(DISTINCT a.object_id) as object_count,
    a.deny
FROM acls a
INNER JOIN acl_entity_roles aer ON a.entity_id = aer.acl_role_id
WHERE aer.entity_table = 'users' 
AND aer.entity_id = $1 
AND a.entity_table = 'acl_roles'
AND a.is_active = true
AND aer.is_active = true
GROUP BY a.operation, a.object_table, a.deny
ORDER BY a.operation, a.object_table
`

type GetUserPermissionSummaryRow struct {
	Operation   string         `json:"operation"`
	ObjectTable sql.NullString `json:"object_table"`
	ObjectCount int64          `json:"object_count"`
	Deny        bool           `json:"deny"`
}

func (q *Queries) GetUserPermissionSummary(ctx context.Context, entityID uuid.UUID) ([]GetUserPermissionSummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, GetUserPermissionSummary, entityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserPermissionSummaryRow{}
	for rows.Next() {
		var i GetUserPermissionSummaryRow
		if err := rows.Scan(
			&i.Operation,
			&i.ObjectTable,
			&i.ObjectCount,
			&i.Deny,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUserPermissions = `-- name: GetUserPermissions :many
SELECT DISTINCT a.id, a.name, a.deny, a.entity_table, a.entity_id, a.operation, a.object_table, a.object_id, a.acl_table, a.acl_id, a.is_active, a.priority, a.created_at, a.updated_at FROM acls a
INNER JOIN acl_entity_roles aer ON a.entity_id = aer.acl_role_id
WHERE aer.entity_table = 'users' 
AND aer.entity_id = $1 
AND a.entity_table = 'acl_roles'
AND a.is_active = true
AND aer.is_active = true
ORDER BY a.priority ASC, a.name
`

func (q *Queries) GetUserPermissions(ctx context.Context, entityID uuid.UUID) ([]Acl, error) {
	rows, err := q.db.QueryContext(ctx, GetUserPermissions, entityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Acl{}
	for rows.Next() {
		var i Acl
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Deny,
			&i.EntityTable,
			&i.EntityID,
			&i.Operation,
			&i.ObjectTable,
			&i.ObjectID,
			&i.AclTable,
			&i.AclID,
			&i.IsActive,
			&i.Priority,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUserRoles = `-- name: GetUserRoles :many
SELECT ar.id, ar.name, ar.label, ar.description, ar.is_active, ar.created_at, ar.updated_at FROM acl_roles ar
INNER JOIN acl_entity_roles aer ON ar.id = aer.acl_role_id
WHERE aer.entity_table = 'users' 
AND aer.entity_id = $1 
AND ar.is_active = true
AND aer.is_active = true
`

func (q *Queries) GetUserRoles(ctx context.Context, entityID uuid.UUID) ([]AclRole, error) {
	rows, err := q.db.QueryContext(ctx, GetUserRoles, entityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AclRole{}
	for rows.Next() {
		var i AclRole
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Label,
			&i.Description,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListACLEntityRolesByEntity = `-- name: ListACLEntityRolesByEntity :many
SELECT id, acl_role_id, entity_table, entity_id, is_active, created_at, updated_at FROM acl_entity_roles
WHERE entity_table = $1 AND entity_id = $2 AND is_active = true
`

type ListACLEntityRolesByEntityParams struct {
	EntityTable string    `json:"entity_table"`
	EntityID    uuid.UUID `json:"entity_id"`
}

func (q *Queries) ListACLEntityRolesByEntity(ctx context.Context, arg ListACLEntityRolesByEntityParams) ([]AclEntityRole, error) {
	rows, err := q.db.QueryContext(ctx, ListACLEntityRolesByEntity, arg.EntityTable, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AclEntityRole{}
	for rows.Next() {
		var i AclEntityRole
		if err := rows.Scan(
			&i.ID,
			&i.AclRoleID,
			&i.EntityTable,
			&i.EntityID,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListACLEntityRolesByRole = `-- name: ListACLEntityRolesByRole :many
SELECT id, acl_role_id, entity_table, entity_id, is_active, created_at, updated_at FROM acl_entity_roles
WHERE acl_role_id = $1 AND is_active = true
`

func (q *Queries) ListACLEntityRolesByRole(ctx context.Context, aclRoleID uuid.UUID) ([]AclEntityRole, error) {
	rows, err := q.db.QueryContext(ctx, ListACLEntityRolesByRole, aclRoleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AclEntityRole{}
	for rows.Next() {
		var i AclEntityRole
		if err := rows.Scan(
			&i.ID,
			&i.AclRoleID,
			&i.EntityTable,
			&i.EntityID,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListACLRoles = `-- name: ListACLRoles :many
SELECT id, name, label, description, is_active, created_at, updated_at FROM acl_roles
WHERE is_active = true
ORDER BY name
`

func (q *Queries) ListACLRoles(ctx context.Context) ([]AclRole, error) {
	rows, err := q.db.QueryContext(ctx, ListACLRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AclRole{}
	for rows.Next() {
		var i AclRole
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Label,
			&i.Description,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListACLsByEntity = `-- name: ListACLsByEntity :many
SELECT id, name, deny, entity_table, entity_id, operation, object_table, object_id, acl_table, acl_id, is_active, priority, created_at, updated_at FROM acls
WHERE entity_table = $1 
AND entity_id = $2 
AND is_active = true
ORDER BY priority ASC, name
`

type ListACLsByEntityParams struct {
	EntityTable string        `json:"entity_table"`
	EntityID    uuid.NullUUID `json:"entity_id"`
}

func (q *Queries) ListACLsByEntity(ctx context.Context, arg ListACLsByEntityParams) ([]Acl, error) {
	rows, err := q.db.QueryContext(ctx, ListACLsByEntity, arg.EntityTable, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Acl{}
	for rows.Next() {
		var i Acl
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Deny,
			&i.EntityTable,
			&i.EntityID,
			&i.Operation,
			&i.ObjectTable,
			&i.ObjectID,
			&i.AclTable,
			&i.AclID,
			&i.IsActive,
			&i.Priority,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListACLsByOperation = `-- name: ListACLsByOperation :many
SELECT id, name, deny, entity_table, entity_id, operation, object_table, object_id, acl_table, acl_id, is_active, priority, created_at, updated_at FROM acls
WHERE operation = $1 
AND is_active = true
ORDER BY priority ASC, name
`

func (q *Queries) ListACLsByOperation(ctx context.Context, operation string) ([]Acl, error) {
	rows, err := q.db.QueryContext(ctx, ListACLsByOperation, operation)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Acl{}
	for rows.Next() {
		var i Acl
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Deny,
			&i.EntityTable,
			&i.EntityID,
			&i.Operation,
			&i.ObjectTable,
			&i.ObjectID,
			&i.AclTable,
			&i.AclID,
			&i.IsActive,
			&i.Priority,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListACLsByRole = `-- name: ListACLsByRole :many
SELECT id, name, deny, entity_table, entity_id, operation, object_table, object_id, acl_table, acl_id, is_active, priority, created_at, updated_at FROM acls
WHERE entity_table = 'acl_roles' 
AND entity_id = $1 
AND is_active = true
ORDER BY priority ASC, name
`

func (q *Queries) ListACLsByRole(ctx context.Context, entityID uuid.NullUUID) ([]Acl, error) {
	rows, err := q.db.QueryContext(ctx, ListACLsByRole, entityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Acl{}
	for rows.Next() {
		var i Acl
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Deny,
			&i.EntityTable,
			&i.EntityID,
			&i.Operation,
			&i.ObjectTable,
			&i.ObjectID,
			&i.AclTable,
			&i.AclID,
			&i.IsActive,
			&i.Priority,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchACLs = `-- name: SearchACLs :many
SELECT id, name, deny, entity_table, entity_id, operation, object_table, object_id, acl_table, acl_id, is_active, priority, created_at, updated_at FROM acls
WHERE is_active = true
AND (
    name ILIKE '%' || $1 || '%' OR
    operation ILIKE '%' || $1 || '%' OR
    object_table ILIKE '%' || $1 || '%'
)
ORDER BY priority ASC, name
LIMIT $2 OFFSET $3
`

type SearchACLsParams struct {
	Column1 sql.NullString `json:"column_1"`
	Limit   int32          `json:"limit"`
	Offset  int32          `json:"offset"`
}

func (q *Queries) SearchACLs(ctx context.Context, arg SearchACLsParams) ([]Acl, error) {
	rows, err := q.db.QueryContext(ctx, SearchACLs, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Acl{}
	for rows.Next() {
		var i Acl
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Deny,
			&i.EntityTable,
			&i.EntityID,
			&i.Operation,
			&i.ObjectTable,
			&i.ObjectID,
			&i.AclTable,
			&i.AclID,
			&i.IsActive,
			&i.Priority,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateACL = `-- name: UpdateACL :one
UPDATE acls
SET name = $2, deny = $3, operation = $4, object_table = $5, object_id = $6, 
    acl_table = $7, acl_id = $8, is_active = $9, priority = $10, updated_at = NOW()
WHERE id = $1
RETURNING id, name, deny, entity_table, entity_id, operation, object_table, object_id, acl_table, acl_id, is_active, priority, created_at, updated_at
`

type UpdateACLParams struct {
	ID          uuid.UUID      `json:"id"`
	Name        string         `json:"name"`
	Deny        bool           `json:"deny"`
	Operation   string         `json:"operation"`
	ObjectTable sql.NullString `json:"object_table"`
	ObjectID    uuid.NullUUID  `json:"object_id"`
	AclTable    sql.NullString `json:"acl_table"`
	AclID       uuid.NullUUID  `json:"acl_id"`
	IsActive    sql.NullBool   `json:"is_active"`
	Priority    sql.NullInt32  `json:"priority"`
}

func (q *Queries) UpdateACL(ctx context.Context, arg UpdateACLParams) (Acl, error) {
	row := q.db.QueryRowContext(ctx, UpdateACL,
		arg.ID,
		arg.Name,
		arg.Deny,
		arg.Operation,
		arg.ObjectTable,
		arg.ObjectID,
		arg.AclTable,
		arg.AclID,
		arg.IsActive,
		arg.Priority,
	)
	var i Acl
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Deny,
		&i.EntityTable,
		&i.EntityID,
		&i.Operation,
		&i.ObjectTable,
		&i.ObjectID,
		&i.AclTable,
		&i.AclID,
		&i.IsActive,
		&i.Priority,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateACLEntityRole = `-- name: UpdateACLEntityRole :one
UPDATE acl_entity_roles
SET is_active = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, acl_role_id, entity_table, entity_id, is_active, created_at, updated_at
`

type UpdateACLEntityRoleParams struct {
	ID       uuid.UUID    `json:"id"`
	IsActive sql.NullBool `json:"is_active"`
}

func (q *Queries) UpdateACLEntityRole(ctx context.Context, arg UpdateACLEntityRoleParams) (AclEntityRole, error) {
	row := q.db.QueryRowContext(ctx, UpdateACLEntityRole, arg.ID, arg.IsActive)
	var i AclEntityRole
	err := row.Scan(
		&i.ID,
		&i.AclRoleID,
		&i.EntityTable,
		&i.EntityID,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateACLRole = `-- name: UpdateACLRole :one
UPDATE acl_roles
SET label = $2, description = $3, is_active = $4, updated_at = NOW()
WHERE id = $1
RETURNING id, name, label, description, is_active, created_at, updated_at
`

type UpdateACLRoleParams struct {
	ID          uuid.UUID      `json:"id"`
	Label       string         `json:"label"`
	Description sql.NullString `json:"description"`
	IsActive    sql.NullBool   `json:"is_active"`
}

func (q *Queries) UpdateACLRole(ctx context.Context, arg UpdateACLRoleParams) (AclRole, error) {
	row := q.db.QueryRowContext(ctx, UpdateACLRole,
		arg.ID,
		arg.Label,
		arg.Description,
		arg.IsActive,
	)
	var i AclRole
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Label,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
