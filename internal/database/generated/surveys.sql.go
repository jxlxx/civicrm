// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: surveys.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const ActivateSurvey = `-- name: ActivateSurvey :exec
UPDATE surveys SET is_active = TRUE, updated_at = NOW() WHERE id = $1
`

func (q *Queries) ActivateSurvey(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, ActivateSurvey, id)
	return err
}

const CreateSurvey = `-- name: CreateSurvey :one
INSERT INTO surveys (
    title, description, instructions, thank_you_text, is_active, is_default
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, title, description, instructions, thank_you_text, is_active, is_default, created_date, modified_date, created_at, updated_at
`

type CreateSurveyParams struct {
	Title        string         `json:"title"`
	Description  sql.NullString `json:"description"`
	Instructions sql.NullString `json:"instructions"`
	ThankYouText sql.NullString `json:"thank_you_text"`
	IsActive     sql.NullBool   `json:"is_active"`
	IsDefault    sql.NullBool   `json:"is_default"`
}

func (q *Queries) CreateSurvey(ctx context.Context, arg CreateSurveyParams) (Survey, error) {
	row := q.db.QueryRowContext(ctx, CreateSurvey,
		arg.Title,
		arg.Description,
		arg.Instructions,
		arg.ThankYouText,
		arg.IsActive,
		arg.IsDefault,
	)
	var i Survey
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Instructions,
		&i.ThankYouText,
		&i.IsActive,
		&i.IsDefault,
		&i.CreatedDate,
		&i.ModifiedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const DeactivateSurvey = `-- name: DeactivateSurvey :exec
UPDATE surveys SET is_active = FALSE, updated_at = NOW() WHERE id = $1
`

func (q *Queries) DeactivateSurvey(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeactivateSurvey, id)
	return err
}

const DeleteSurvey = `-- name: DeleteSurvey :exec
DELETE FROM surveys WHERE id = $1
`

func (q *Queries) DeleteSurvey(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteSurvey, id)
	return err
}

const GetDefaultSurvey = `-- name: GetDefaultSurvey :one
SELECT id, title, description, instructions, thank_you_text, is_active, is_default, created_date, modified_date, created_at, updated_at FROM surveys WHERE is_default = TRUE AND is_active = TRUE LIMIT 1
`

func (q *Queries) GetDefaultSurvey(ctx context.Context) (Survey, error) {
	row := q.db.QueryRowContext(ctx, GetDefaultSurvey)
	var i Survey
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Instructions,
		&i.ThankYouText,
		&i.IsActive,
		&i.IsDefault,
		&i.CreatedDate,
		&i.ModifiedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetSurvey = `-- name: GetSurvey :one
SELECT id, title, description, instructions, thank_you_text, is_active, is_default, created_date, modified_date, created_at, updated_at FROM surveys WHERE id = $1
`

func (q *Queries) GetSurvey(ctx context.Context, id uuid.UUID) (Survey, error) {
	row := q.db.QueryRowContext(ctx, GetSurvey, id)
	var i Survey
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Instructions,
		&i.ThankYouText,
		&i.IsActive,
		&i.IsDefault,
		&i.CreatedDate,
		&i.ModifiedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetSurveyByTitle = `-- name: GetSurveyByTitle :one
SELECT id, title, description, instructions, thank_you_text, is_active, is_default, created_date, modified_date, created_at, updated_at FROM surveys WHERE title = $1
`

func (q *Queries) GetSurveyByTitle(ctx context.Context, title string) (Survey, error) {
	row := q.db.QueryRowContext(ctx, GetSurveyByTitle, title)
	var i Survey
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Instructions,
		&i.ThankYouText,
		&i.IsActive,
		&i.IsDefault,
		&i.CreatedDate,
		&i.ModifiedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetSurveyResponseRate = `-- name: GetSurveyResponseRate :many
SELECT 
    s.title as survey_title,
    COUNT(sr.id) as total_responses,
    COUNT(CASE WHEN sr.status = 'Completed' THEN 1 END) as completed_responses,
    ROUND(
        (COUNT(CASE WHEN sr.status = 'Completed' THEN 1 END)::DECIMAL / 
         NULLIF(COUNT(sr.id), 0)::DECIMAL) * 100, 2
    ) as completion_rate
FROM surveys s
LEFT JOIN survey_responses sr ON s.id = sr.survey_id
WHERE s.is_active = $1
GROUP BY s.id, s.title
ORDER BY completion_rate DESC
`

type GetSurveyResponseRateRow struct {
	SurveyTitle        string `json:"survey_title"`
	TotalResponses     int64  `json:"total_responses"`
	CompletedResponses int64  `json:"completed_responses"`
	CompletionRate     string `json:"completion_rate"`
}

func (q *Queries) GetSurveyResponseRate(ctx context.Context, isActive sql.NullBool) ([]GetSurveyResponseRateRow, error) {
	rows, err := q.db.QueryContext(ctx, GetSurveyResponseRate, isActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSurveyResponseRateRow{}
	for rows.Next() {
		var i GetSurveyResponseRateRow
		if err := rows.Scan(
			&i.SurveyTitle,
			&i.TotalResponses,
			&i.CompletedResponses,
			&i.CompletionRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSurveyStats = `-- name: GetSurveyStats :many
SELECT 
    s.title as survey_title,
    COUNT(sr.id) as response_count,
    COUNT(CASE WHEN sr.status = 'Completed' THEN 1 END) as completed_count,
    COUNT(CASE WHEN sr.status = 'Partial' THEN 1 END) as partial_count,
    COUNT(CASE WHEN sr.status = 'Abandoned' THEN 1 END) as abandoned_count
FROM surveys s
LEFT JOIN survey_responses sr ON s.id = sr.survey_id
WHERE s.is_active = $1
GROUP BY s.id, s.title, s.created_date
ORDER BY s.created_date DESC
`

type GetSurveyStatsRow struct {
	SurveyTitle    string `json:"survey_title"`
	ResponseCount  int64  `json:"response_count"`
	CompletedCount int64  `json:"completed_count"`
	PartialCount   int64  `json:"partial_count"`
	AbandonedCount int64  `json:"abandoned_count"`
}

func (q *Queries) GetSurveyStats(ctx context.Context, isActive sql.NullBool) ([]GetSurveyStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetSurveyStats, isActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSurveyStatsRow{}
	for rows.Next() {
		var i GetSurveyStatsRow
		if err := rows.Scan(
			&i.SurveyTitle,
			&i.ResponseCount,
			&i.CompletedCount,
			&i.PartialCount,
			&i.AbandonedCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListActiveSurveys = `-- name: ListActiveSurveys :many
SELECT id, title, description, instructions, thank_you_text, is_active, is_default, created_date, modified_date, created_at, updated_at FROM surveys 
WHERE is_active = TRUE 
ORDER BY created_date DESC
`

func (q *Queries) ListActiveSurveys(ctx context.Context) ([]Survey, error) {
	rows, err := q.db.QueryContext(ctx, ListActiveSurveys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Survey{}
	for rows.Next() {
		var i Survey
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Instructions,
			&i.ThankYouText,
			&i.IsActive,
			&i.IsDefault,
			&i.CreatedDate,
			&i.ModifiedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListSurveys = `-- name: ListSurveys :many
SELECT id, title, description, instructions, thank_you_text, is_active, is_default, created_date, modified_date, created_at, updated_at FROM surveys 
ORDER BY created_date DESC
`

func (q *Queries) ListSurveys(ctx context.Context) ([]Survey, error) {
	rows, err := q.db.QueryContext(ctx, ListSurveys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Survey{}
	for rows.Next() {
		var i Survey
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Instructions,
			&i.ThankYouText,
			&i.IsActive,
			&i.IsDefault,
			&i.CreatedDate,
			&i.ModifiedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListSurveysByDateRange = `-- name: ListSurveysByDateRange :many
SELECT id, title, description, instructions, thank_you_text, is_active, is_default, created_date, modified_date, created_at, updated_at FROM surveys 
WHERE created_date >= $1 AND created_date <= $2 
ORDER BY created_date DESC
`

type ListSurveysByDateRangeParams struct {
	CreatedDate   sql.NullTime `json:"created_date"`
	CreatedDate_2 sql.NullTime `json:"created_date_2"`
}

func (q *Queries) ListSurveysByDateRange(ctx context.Context, arg ListSurveysByDateRangeParams) ([]Survey, error) {
	rows, err := q.db.QueryContext(ctx, ListSurveysByDateRange, arg.CreatedDate, arg.CreatedDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Survey{}
	for rows.Next() {
		var i Survey
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Instructions,
			&i.ThankYouText,
			&i.IsActive,
			&i.IsDefault,
			&i.CreatedDate,
			&i.ModifiedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchSurveys = `-- name: SearchSurveys :many
SELECT id, title, description, instructions, thank_you_text, is_active, is_default, created_date, modified_date, created_at, updated_at FROM surveys 
WHERE (title ILIKE $1 OR description ILIKE $1 OR instructions ILIKE $1) 
ORDER BY created_date DESC
`

func (q *Queries) SearchSurveys(ctx context.Context, title string) ([]Survey, error) {
	rows, err := q.db.QueryContext(ctx, SearchSurveys, title)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Survey{}
	for rows.Next() {
		var i Survey
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Instructions,
			&i.ThankYouText,
			&i.IsActive,
			&i.IsDefault,
			&i.CreatedDate,
			&i.ModifiedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SetDefaultSurvey = `-- name: SetDefaultSurvey :exec
UPDATE surveys SET is_default = FALSE, updated_at = NOW()
`

func (q *Queries) SetDefaultSurvey(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, SetDefaultSurvey)
	return err
}

const UpdateSurvey = `-- name: UpdateSurvey :one
UPDATE surveys SET
    title = $2, description = $3, instructions = $4, thank_you_text = $5,
    is_active = $6, is_default = $7, modified_date = NOW(), updated_at = NOW()
WHERE id = $1 RETURNING id, title, description, instructions, thank_you_text, is_active, is_default, created_date, modified_date, created_at, updated_at
`

type UpdateSurveyParams struct {
	ID           uuid.UUID      `json:"id"`
	Title        string         `json:"title"`
	Description  sql.NullString `json:"description"`
	Instructions sql.NullString `json:"instructions"`
	ThankYouText sql.NullString `json:"thank_you_text"`
	IsActive     sql.NullBool   `json:"is_active"`
	IsDefault    sql.NullBool   `json:"is_default"`
}

func (q *Queries) UpdateSurvey(ctx context.Context, arg UpdateSurveyParams) (Survey, error) {
	row := q.db.QueryRowContext(ctx, UpdateSurvey,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Instructions,
		arg.ThankYouText,
		arg.IsActive,
		arg.IsDefault,
	)
	var i Survey
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Instructions,
		&i.ThankYouText,
		&i.IsActive,
		&i.IsDefault,
		&i.CreatedDate,
		&i.ModifiedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
