// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: entity_tags.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const CreateEntityTag = `-- name: CreateEntityTag :one
INSERT INTO entity_tags (
    entity_table, entity_id, tag_id
) VALUES (
    $1, $2, $3
) RETURNING id, entity_table, entity_id, tag_id, created_at, updated_at
`

type CreateEntityTagParams struct {
	EntityTable string    `json:"entity_table"`
	EntityID    uuid.UUID `json:"entity_id"`
	TagID       uuid.UUID `json:"tag_id"`
}

func (q *Queries) CreateEntityTag(ctx context.Context, arg CreateEntityTagParams) (EntityTag, error) {
	row := q.db.QueryRowContext(ctx, CreateEntityTag, arg.EntityTable, arg.EntityID, arg.TagID)
	var i EntityTag
	err := row.Scan(
		&i.ID,
		&i.EntityTable,
		&i.EntityID,
		&i.TagID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const DeleteEntityTag = `-- name: DeleteEntityTag :exec
DELETE FROM entity_tags WHERE id = $1
`

func (q *Queries) DeleteEntityTag(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteEntityTag, id)
	return err
}

const DeleteEntityTagsByEntity = `-- name: DeleteEntityTagsByEntity :exec
DELETE FROM entity_tags WHERE entity_table = $1 AND entity_id = $2
`

type DeleteEntityTagsByEntityParams struct {
	EntityTable string    `json:"entity_table"`
	EntityID    uuid.UUID `json:"entity_id"`
}

func (q *Queries) DeleteEntityTagsByEntity(ctx context.Context, arg DeleteEntityTagsByEntityParams) error {
	_, err := q.db.ExecContext(ctx, DeleteEntityTagsByEntity, arg.EntityTable, arg.EntityID)
	return err
}

const DeleteEntityTagsByTag = `-- name: DeleteEntityTagsByTag :exec
DELETE FROM entity_tags WHERE tag_id = $1
`

func (q *Queries) DeleteEntityTagsByTag(ctx context.Context, tagID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteEntityTagsByTag, tagID)
	return err
}

const GetEntityTag = `-- name: GetEntityTag :one
SELECT id, entity_table, entity_id, tag_id, created_at, updated_at FROM entity_tags WHERE id = $1
`

func (q *Queries) GetEntityTag(ctx context.Context, id uuid.UUID) (EntityTag, error) {
	row := q.db.QueryRowContext(ctx, GetEntityTag, id)
	var i EntityTag
	err := row.Scan(
		&i.ID,
		&i.EntityTable,
		&i.EntityID,
		&i.TagID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetEntityTagCount = `-- name: GetEntityTagCount :one
SELECT COUNT(*) FROM entity_tags WHERE entity_table = $1 AND entity_id = $2
`

type GetEntityTagCountParams struct {
	EntityTable string    `json:"entity_table"`
	EntityID    uuid.UUID `json:"entity_id"`
}

func (q *Queries) GetEntityTagCount(ctx context.Context, arg GetEntityTagCountParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, GetEntityTagCount, arg.EntityTable, arg.EntityID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const GetEntityTagStats = `-- name: GetEntityTagStats :many
SELECT 
    et.entity_table,
    COUNT(et.id) as tag_count
FROM entity_tags et
GROUP BY et.entity_table
ORDER BY et.entity_table
`

type GetEntityTagStatsRow struct {
	EntityTable string `json:"entity_table"`
	TagCount    int64  `json:"tag_count"`
}

func (q *Queries) GetEntityTagStats(ctx context.Context) ([]GetEntityTagStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetEntityTagStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEntityTagStatsRow{}
	for rows.Next() {
		var i GetEntityTagStatsRow
		if err := rows.Scan(&i.EntityTable, &i.TagCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetEntityTagsByEntity = `-- name: GetEntityTagsByEntity :many
SELECT id, entity_table, entity_id, tag_id, created_at, updated_at FROM entity_tags 
WHERE entity_table = $1 AND entity_id = $2 
ORDER BY id
`

type GetEntityTagsByEntityParams struct {
	EntityTable string    `json:"entity_table"`
	EntityID    uuid.UUID `json:"entity_id"`
}

func (q *Queries) GetEntityTagsByEntity(ctx context.Context, arg GetEntityTagsByEntityParams) ([]EntityTag, error) {
	rows, err := q.db.QueryContext(ctx, GetEntityTagsByEntity, arg.EntityTable, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EntityTag{}
	for rows.Next() {
		var i EntityTag
		if err := rows.Scan(
			&i.ID,
			&i.EntityTable,
			&i.EntityID,
			&i.TagID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetEntityTagsByTable = `-- name: GetEntityTagsByTable :many
SELECT id, entity_table, entity_id, tag_id, created_at, updated_at FROM entity_tags 
WHERE entity_table = $1 
ORDER BY id
`

func (q *Queries) GetEntityTagsByTable(ctx context.Context, entityTable string) ([]EntityTag, error) {
	rows, err := q.db.QueryContext(ctx, GetEntityTagsByTable, entityTable)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EntityTag{}
	for rows.Next() {
		var i EntityTag
		if err := rows.Scan(
			&i.ID,
			&i.EntityTable,
			&i.EntityID,
			&i.TagID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetEntityTagsByTag = `-- name: GetEntityTagsByTag :many
SELECT id, entity_table, entity_id, tag_id, created_at, updated_at FROM entity_tags 
WHERE tag_id = $1 
ORDER BY id
`

func (q *Queries) GetEntityTagsByTag(ctx context.Context, tagID uuid.UUID) ([]EntityTag, error) {
	rows, err := q.db.QueryContext(ctx, GetEntityTagsByTag, tagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EntityTag{}
	for rows.Next() {
		var i EntityTag
		if err := rows.Scan(
			&i.ID,
			&i.EntityTable,
			&i.EntityID,
			&i.TagID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetEntityTagsWithDetails = `-- name: GetEntityTagsWithDetails :many
SELECT 
    et.id, et.entity_table, et.entity_id, et.tag_id, et.created_at, et.updated_at,
    t.name as tag_name,
    t.description as tag_description,
    t.color as tag_color,
    t.icon as tag_icon,
    ts.name as tag_set_name,
    ts.entity_table as tag_set_entity_table
FROM entity_tags et
JOIN tags t ON et.tag_id = t.id
JOIN tag_sets ts ON t.tag_set_id = ts.id
WHERE et.entity_table = $1 AND et.entity_id = $2 
ORDER BY t.weight, t.name
`

type GetEntityTagsWithDetailsParams struct {
	EntityTable string    `json:"entity_table"`
	EntityID    uuid.UUID `json:"entity_id"`
}

type GetEntityTagsWithDetailsRow struct {
	ID                uuid.UUID      `json:"id"`
	EntityTable       string         `json:"entity_table"`
	EntityID          uuid.UUID      `json:"entity_id"`
	TagID             uuid.UUID      `json:"tag_id"`
	CreatedAt         sql.NullTime   `json:"created_at"`
	UpdatedAt         sql.NullTime   `json:"updated_at"`
	TagName           string         `json:"tag_name"`
	TagDescription    sql.NullString `json:"tag_description"`
	TagColor          sql.NullString `json:"tag_color"`
	TagIcon           sql.NullString `json:"tag_icon"`
	TagSetName        string         `json:"tag_set_name"`
	TagSetEntityTable string         `json:"tag_set_entity_table"`
}

func (q *Queries) GetEntityTagsWithDetails(ctx context.Context, arg GetEntityTagsWithDetailsParams) ([]GetEntityTagsWithDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetEntityTagsWithDetails, arg.EntityTable, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEntityTagsWithDetailsRow{}
	for rows.Next() {
		var i GetEntityTagsWithDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.EntityTable,
			&i.EntityID,
			&i.TagID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TagName,
			&i.TagDescription,
			&i.TagColor,
			&i.TagIcon,
			&i.TagSetName,
			&i.TagSetEntityTable,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetPopularTags = `-- name: GetPopularTags :many
SELECT 
    t.name as tag_name,
    t.color as tag_color,
    COUNT(et.id) as usage_count
FROM tags t
JOIN entity_tags et ON t.id = et.tag_id
WHERE t.is_active = $1
GROUP BY t.name, t.color, t.weight
ORDER BY usage_count DESC, t.weight, t.name
LIMIT $2
`

type GetPopularTagsParams struct {
	IsActive sql.NullBool `json:"is_active"`
	Limit    int32        `json:"limit"`
}

type GetPopularTagsRow struct {
	TagName    string         `json:"tag_name"`
	TagColor   sql.NullString `json:"tag_color"`
	UsageCount int64          `json:"usage_count"`
}

func (q *Queries) GetPopularTags(ctx context.Context, arg GetPopularTagsParams) ([]GetPopularTagsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetPopularTags, arg.IsActive, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPopularTagsRow{}
	for rows.Next() {
		var i GetPopularTagsRow
		if err := rows.Scan(&i.TagName, &i.TagColor, &i.UsageCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetTaggedEntities = `-- name: GetTaggedEntities :many
SELECT 
    et.entity_table,
    et.entity_id,
    STRING_AGG(t.name, ', ') as tag_names,
    STRING_AGG(t.color, ', ') as tag_colors
FROM entity_tags et
JOIN tags t ON et.tag_id = t.id
WHERE et.entity_table = $1
GROUP BY et.entity_table, et.entity_id
ORDER BY et.entity_id
`

type GetTaggedEntitiesRow struct {
	EntityTable string    `json:"entity_table"`
	EntityID    uuid.UUID `json:"entity_id"`
	TagNames    []byte    `json:"tag_names"`
	TagColors   []byte    `json:"tag_colors"`
}

func (q *Queries) GetTaggedEntities(ctx context.Context, entityTable string) ([]GetTaggedEntitiesRow, error) {
	rows, err := q.db.QueryContext(ctx, GetTaggedEntities, entityTable)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTaggedEntitiesRow{}
	for rows.Next() {
		var i GetTaggedEntitiesRow
		if err := rows.Scan(
			&i.EntityTable,
			&i.EntityID,
			&i.TagNames,
			&i.TagColors,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListEntityTags = `-- name: ListEntityTags :many
SELECT id, entity_table, entity_id, tag_id, created_at, updated_at FROM entity_tags 
ORDER BY id
`

func (q *Queries) ListEntityTags(ctx context.Context) ([]EntityTag, error) {
	rows, err := q.db.QueryContext(ctx, ListEntityTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EntityTag{}
	for rows.Next() {
		var i EntityTag
		if err := rows.Scan(
			&i.ID,
			&i.EntityTable,
			&i.EntityID,
			&i.TagID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListEntityTagsByTable = `-- name: ListEntityTagsByTable :many
SELECT id, entity_table, entity_id, tag_id, created_at, updated_at FROM entity_tags 
WHERE entity_table = $1 
ORDER BY id
`

func (q *Queries) ListEntityTagsByTable(ctx context.Context, entityTable string) ([]EntityTag, error) {
	rows, err := q.db.QueryContext(ctx, ListEntityTagsByTable, entityTable)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EntityTag{}
	for rows.Next() {
		var i EntityTag
		if err := rows.Scan(
			&i.ID,
			&i.EntityTable,
			&i.EntityID,
			&i.TagID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListEntityTagsByTagSet = `-- name: ListEntityTagsByTagSet :many
SELECT et.id, et.entity_table, et.entity_id, et.tag_id, et.created_at, et.updated_at FROM entity_tags et
JOIN tags t ON et.tag_id = t.id
WHERE t.tag_set_id = $1 
ORDER BY et.id
`

func (q *Queries) ListEntityTagsByTagSet(ctx context.Context, tagSetID uuid.NullUUID) ([]EntityTag, error) {
	rows, err := q.db.QueryContext(ctx, ListEntityTagsByTagSet, tagSetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EntityTag{}
	for rows.Next() {
		var i EntityTag
		if err := rows.Scan(
			&i.ID,
			&i.EntityTable,
			&i.EntityID,
			&i.TagID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchEntityTags = `-- name: SearchEntityTags :many
SELECT et.id, et.entity_table, et.entity_id, et.tag_id, et.created_at, et.updated_at FROM entity_tags et
JOIN tags t ON et.tag_id = t.id
WHERE t.name ILIKE $1 
ORDER BY et.id
`

func (q *Queries) SearchEntityTags(ctx context.Context, name string) ([]EntityTag, error) {
	rows, err := q.db.QueryContext(ctx, SearchEntityTags, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EntityTag{}
	for rows.Next() {
		var i EntityTag
		if err := rows.Scan(
			&i.ID,
			&i.EntityTable,
			&i.EntityID,
			&i.TagID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateEntityTag = `-- name: UpdateEntityTag :one
UPDATE entity_tags SET
    entity_table = $2, entity_id = $3, tag_id = $4, updated_at = NOW()
WHERE id = $1 RETURNING id, entity_table, entity_id, tag_id, created_at, updated_at
`

type UpdateEntityTagParams struct {
	ID          uuid.UUID `json:"id"`
	EntityTable string    `json:"entity_table"`
	EntityID    uuid.UUID `json:"entity_id"`
	TagID       uuid.UUID `json:"tag_id"`
}

func (q *Queries) UpdateEntityTag(ctx context.Context, arg UpdateEntityTagParams) (EntityTag, error) {
	row := q.db.QueryRowContext(ctx, UpdateEntityTag,
		arg.ID,
		arg.EntityTable,
		arg.EntityID,
		arg.TagID,
	)
	var i EntityTag
	err := row.Scan(
		&i.ID,
		&i.EntityTable,
		&i.EntityID,
		&i.TagID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
