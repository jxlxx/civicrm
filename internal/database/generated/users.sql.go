// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: users.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const AssignUserToRole = `-- name: AssignUserToRole :one
INSERT INTO acl_entity_roles (
    acl_role_id, entity_table, entity_id, is_active
) VALUES (
    (SELECT id FROM acl_roles WHERE name = $1), 'users', $2, true
) RETURNING id, acl_role_id, entity_table, entity_id, is_active, created_at, updated_at
`

type AssignUserToRoleParams struct {
	Name     string    `json:"name"`
	EntityID uuid.UUID `json:"entity_id"`
}

func (q *Queries) AssignUserToRole(ctx context.Context, arg AssignUserToRoleParams) (AclEntityRole, error) {
	row := q.db.QueryRowContext(ctx, AssignUserToRole, arg.Name, arg.EntityID)
	var i AclEntityRole
	err := row.Scan(
		&i.ID,
		&i.AclRoleID,
		&i.EntityTable,
		&i.EntityID,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const CreateUFMatch = `-- name: CreateUFMatch :one
INSERT INTO uf_match (
    domain_id, uf_id, uf_name, contact_id, language
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, domain_id, uf_id, uf_name, contact_id, language, created_at, updated_at
`

type CreateUFMatchParams struct {
	DomainID  uuid.UUID      `json:"domain_id"`
	UfID      uuid.UUID      `json:"uf_id"`
	UfName    sql.NullString `json:"uf_name"`
	ContactID uuid.NullUUID  `json:"contact_id"`
	Language  sql.NullString `json:"language"`
}

func (q *Queries) CreateUFMatch(ctx context.Context, arg CreateUFMatchParams) (UfMatch, error) {
	row := q.db.QueryRowContext(ctx, CreateUFMatch,
		arg.DomainID,
		arg.UfID,
		arg.UfName,
		arg.ContactID,
		arg.Language,
	)
	var i UfMatch
	err := row.Scan(
		&i.ID,
		&i.DomainID,
		&i.UfID,
		&i.UfName,
		&i.ContactID,
		&i.Language,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const CreateUser = `-- name: CreateUser :one
INSERT INTO users (
    username, email, hashed_password, is_active, is_admin
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, username, email, hashed_password, is_active, is_admin, last_login, created_at, updated_at
`

type CreateUserParams struct {
	Username       string       `json:"username"`
	Email          string       `json:"email"`
	HashedPassword string       `json:"hashed_password"`
	IsActive       sql.NullBool `json:"is_active"`
	IsAdmin        sql.NullBool `json:"is_admin"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, CreateUser,
		arg.Username,
		arg.Email,
		arg.HashedPassword,
		arg.IsActive,
		arg.IsAdmin,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.IsActive,
		&i.IsAdmin,
		&i.LastLogin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const DeleteUFMatch = `-- name: DeleteUFMatch :exec
DELETE FROM uf_match
WHERE id = $1
`

func (q *Queries) DeleteUFMatch(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteUFMatch, id)
	return err
}

const DeleteUser = `-- name: DeleteUser :exec
UPDATE users
SET is_active = false, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteUser, id)
	return err
}

const GetUFMatch = `-- name: GetUFMatch :one
SELECT id, domain_id, uf_id, uf_name, contact_id, language, created_at, updated_at FROM uf_match
WHERE id = $1
`

func (q *Queries) GetUFMatch(ctx context.Context, id uuid.UUID) (UfMatch, error) {
	row := q.db.QueryRowContext(ctx, GetUFMatch, id)
	var i UfMatch
	err := row.Scan(
		&i.ID,
		&i.DomainID,
		&i.UfID,
		&i.UfName,
		&i.ContactID,
		&i.Language,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetUFMatchByContactID = `-- name: GetUFMatchByContactID :one
SELECT id, domain_id, uf_id, uf_name, contact_id, language, created_at, updated_at FROM uf_match
WHERE contact_id = $1
`

func (q *Queries) GetUFMatchByContactID(ctx context.Context, contactID uuid.NullUUID) (UfMatch, error) {
	row := q.db.QueryRowContext(ctx, GetUFMatchByContactID, contactID)
	var i UfMatch
	err := row.Scan(
		&i.ID,
		&i.DomainID,
		&i.UfID,
		&i.UfName,
		&i.ContactID,
		&i.Language,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetUFMatchByUserID = `-- name: GetUFMatchByUserID :one
SELECT id, domain_id, uf_id, uf_name, contact_id, language, created_at, updated_at FROM uf_match
WHERE uf_id = $1
`

func (q *Queries) GetUFMatchByUserID(ctx context.Context, ufID uuid.UUID) (UfMatch, error) {
	row := q.db.QueryRowContext(ctx, GetUFMatchByUserID, ufID)
	var i UfMatch
	err := row.Scan(
		&i.ID,
		&i.DomainID,
		&i.UfID,
		&i.UfName,
		&i.ContactID,
		&i.Language,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetUFMatchByUsername = `-- name: GetUFMatchByUsername :one
SELECT id, domain_id, uf_id, uf_name, contact_id, language, created_at, updated_at FROM uf_match
WHERE uf_name = $1
`

func (q *Queries) GetUFMatchByUsername(ctx context.Context, ufName sql.NullString) (UfMatch, error) {
	row := q.db.QueryRowContext(ctx, GetUFMatchByUsername, ufName)
	var i UfMatch
	err := row.Scan(
		&i.ID,
		&i.DomainID,
		&i.UfID,
		&i.UfName,
		&i.ContactID,
		&i.Language,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetUser = `-- name: GetUser :one
SELECT id, username, email, hashed_password, is_active, is_admin, last_login, created_at, updated_at FROM users
WHERE id = $1 AND is_active = true
`

func (q *Queries) GetUser(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, GetUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.IsActive,
		&i.IsAdmin,
		&i.LastLogin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetUserByEmail = `-- name: GetUserByEmail :one
SELECT id, username, email, hashed_password, is_active, is_admin, last_login, created_at, updated_at FROM users
WHERE email = $1 AND is_active = true
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, GetUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.IsActive,
		&i.IsAdmin,
		&i.LastLogin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetUserByEmailWithContact = `-- name: GetUserByEmailWithContact :one
SELECT 
    u.id, u.username, u.email, u.hashed_password, u.is_active, u.is_admin, u.last_login, u.created_at, u.updated_at,
    c.id as contact_id,
    c.first_name,
    c.last_name,
    c.email as contact_email,
    c.contact_type
FROM users u
LEFT JOIN uf_match ufm ON u.id = ufm.uf_id
LEFT JOIN contacts c ON ufm.contact_id = c.id
WHERE u.email = $1 AND u.is_active = true
`

type GetUserByEmailWithContactRow struct {
	ID             uuid.UUID      `json:"id"`
	Username       string         `json:"username"`
	Email          string         `json:"email"`
	HashedPassword string         `json:"hashed_password"`
	IsActive       sql.NullBool   `json:"is_active"`
	IsAdmin        sql.NullBool   `json:"is_admin"`
	LastLogin      sql.NullTime   `json:"last_login"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	UpdatedAt      sql.NullTime   `json:"updated_at"`
	ContactID      uuid.NullUUID  `json:"contact_id"`
	FirstName      sql.NullString `json:"first_name"`
	LastName       sql.NullString `json:"last_name"`
	ContactEmail   sql.NullString `json:"contact_email"`
	ContactType    sql.NullString `json:"contact_type"`
}

func (q *Queries) GetUserByEmailWithContact(ctx context.Context, email string) (GetUserByEmailWithContactRow, error) {
	row := q.db.QueryRowContext(ctx, GetUserByEmailWithContact, email)
	var i GetUserByEmailWithContactRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.IsActive,
		&i.IsAdmin,
		&i.LastLogin,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ContactID,
		&i.FirstName,
		&i.LastName,
		&i.ContactEmail,
		&i.ContactType,
	)
	return i, err
}

const GetUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, email, hashed_password, is_active, is_admin, last_login, created_at, updated_at FROM users
WHERE username = $1 AND is_active = true
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRowContext(ctx, GetUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.IsActive,
		&i.IsAdmin,
		&i.LastLogin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetUserByUsernameWithContact = `-- name: GetUserByUsernameWithContact :one
SELECT 
    u.id, u.username, u.email, u.hashed_password, u.is_active, u.is_admin, u.last_login, u.created_at, u.updated_at,
    c.id as contact_id,
    c.first_name,
    c.last_name,
    c.email as contact_email,
    c.contact_type
FROM users u
LEFT JOIN uf_match ufm ON u.id = ufm.uf_id
LEFT JOIN contacts c ON ufm.contact_id = c.id
WHERE u.username = $1 AND u.is_active = true
`

type GetUserByUsernameWithContactRow struct {
	ID             uuid.UUID      `json:"id"`
	Username       string         `json:"username"`
	Email          string         `json:"email"`
	HashedPassword string         `json:"hashed_password"`
	IsActive       sql.NullBool   `json:"is_active"`
	IsAdmin        sql.NullBool   `json:"is_admin"`
	LastLogin      sql.NullTime   `json:"last_login"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	UpdatedAt      sql.NullTime   `json:"updated_at"`
	ContactID      uuid.NullUUID  `json:"contact_id"`
	FirstName      sql.NullString `json:"first_name"`
	LastName       sql.NullString `json:"last_name"`
	ContactEmail   sql.NullString `json:"contact_email"`
	ContactType    sql.NullString `json:"contact_type"`
}

func (q *Queries) GetUserByUsernameWithContact(ctx context.Context, username string) (GetUserByUsernameWithContactRow, error) {
	row := q.db.QueryRowContext(ctx, GetUserByUsernameWithContact, username)
	var i GetUserByUsernameWithContactRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.IsActive,
		&i.IsAdmin,
		&i.LastLogin,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ContactID,
		&i.FirstName,
		&i.LastName,
		&i.ContactEmail,
		&i.ContactType,
	)
	return i, err
}

const GetUserStats = `-- name: GetUserStats :one
SELECT 
    COUNT(*) as total_users,
    COUNT(CASE WHEN is_admin = true THEN 1 END) as admin_users,
    COUNT(CASE WHEN is_active = true THEN 1 END) as active_users,
    COUNT(CASE WHEN last_login IS NOT NULL THEN 1 END) as users_with_logins
FROM users
`

type GetUserStatsRow struct {
	TotalUsers      int64 `json:"total_users"`
	AdminUsers      int64 `json:"admin_users"`
	ActiveUsers     int64 `json:"active_users"`
	UsersWithLogins int64 `json:"users_with_logins"`
}

func (q *Queries) GetUserStats(ctx context.Context) (GetUserStatsRow, error) {
	row := q.db.QueryRowContext(ctx, GetUserStats)
	var i GetUserStatsRow
	err := row.Scan(
		&i.TotalUsers,
		&i.AdminUsers,
		&i.ActiveUsers,
		&i.UsersWithLogins,
	)
	return i, err
}

const GetUserWithContact = `-- name: GetUserWithContact :one
SELECT 
    u.id, u.username, u.email, u.hashed_password, u.is_active, u.is_admin, u.last_login, u.created_at, u.updated_at,
    c.id as contact_id,
    c.first_name,
    c.last_name,
    c.email as contact_email,
    c.contact_type
FROM users u
LEFT JOIN uf_match ufm ON u.id = ufm.uf_id
LEFT JOIN contacts c ON ufm.contact_id = c.id
WHERE u.id = $1 AND u.is_active = true
`

type GetUserWithContactRow struct {
	ID             uuid.UUID      `json:"id"`
	Username       string         `json:"username"`
	Email          string         `json:"email"`
	HashedPassword string         `json:"hashed_password"`
	IsActive       sql.NullBool   `json:"is_active"`
	IsAdmin        sql.NullBool   `json:"is_admin"`
	LastLogin      sql.NullTime   `json:"last_login"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	UpdatedAt      sql.NullTime   `json:"updated_at"`
	ContactID      uuid.NullUUID  `json:"contact_id"`
	FirstName      sql.NullString `json:"first_name"`
	LastName       sql.NullString `json:"last_name"`
	ContactEmail   sql.NullString `json:"contact_email"`
	ContactType    sql.NullString `json:"contact_type"`
}

func (q *Queries) GetUserWithContact(ctx context.Context, id uuid.UUID) (GetUserWithContactRow, error) {
	row := q.db.QueryRowContext(ctx, GetUserWithContact, id)
	var i GetUserWithContactRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.IsActive,
		&i.IsAdmin,
		&i.LastLogin,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ContactID,
		&i.FirstName,
		&i.LastName,
		&i.ContactEmail,
		&i.ContactType,
	)
	return i, err
}

const GetUsersByPermission = `-- name: GetUsersByPermission :many
SELECT DISTINCT u.id, u.username, u.email, u.hashed_password, u.is_active, u.is_admin, u.last_login, u.created_at, u.updated_at FROM users u
INNER JOIN acl_entity_roles aer ON u.id = aer.entity_id
INNER JOIN acls a ON a.entity_id = aer.acl_role_id
WHERE aer.entity_table = 'users' 
AND a.entity_table = 'acl_roles'
AND a.operation = $1
AND a.object_table = $2
AND (a.object_id = $3 OR a.object_id IS NULL)
AND a.deny = false
AND a.is_active = true
AND aer.is_active = true
AND u.is_active = true
ORDER BY u.username
`

type GetUsersByPermissionParams struct {
	Operation   string         `json:"operation"`
	ObjectTable sql.NullString `json:"object_table"`
	ObjectID    uuid.NullUUID  `json:"object_id"`
}

func (q *Queries) GetUsersByPermission(ctx context.Context, arg GetUsersByPermissionParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, GetUsersByPermission, arg.Operation, arg.ObjectTable, arg.ObjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.HashedPassword,
			&i.IsActive,
			&i.IsAdmin,
			&i.LastLogin,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUsersByRoleWithContacts = `-- name: GetUsersByRoleWithContacts :many
SELECT 
    u.id, u.username, u.email, u.hashed_password, u.is_active, u.is_admin, u.last_login, u.created_at, u.updated_at,
    c.id as contact_id,
    c.first_name,
    c.last_name,
    c.email as contact_email,
    c.contact_type
FROM users u
INNER JOIN acl_entity_roles aer ON u.id = aer.entity_id
INNER JOIN acl_roles ar ON aer.acl_role_id = ar.id
LEFT JOIN uf_match ufm ON u.id = ufm.uf_id
LEFT JOIN contacts c ON ufm.contact_id = c.id
WHERE aer.entity_table = 'users' 
AND ar.name = $1 
AND u.is_active = true
AND aer.is_active = true
ORDER BY u.username
`

type GetUsersByRoleWithContactsRow struct {
	ID             uuid.UUID      `json:"id"`
	Username       string         `json:"username"`
	Email          string         `json:"email"`
	HashedPassword string         `json:"hashed_password"`
	IsActive       sql.NullBool   `json:"is_active"`
	IsAdmin        sql.NullBool   `json:"is_admin"`
	LastLogin      sql.NullTime   `json:"last_login"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	UpdatedAt      sql.NullTime   `json:"updated_at"`
	ContactID      uuid.NullUUID  `json:"contact_id"`
	FirstName      sql.NullString `json:"first_name"`
	LastName       sql.NullString `json:"last_name"`
	ContactEmail   sql.NullString `json:"contact_email"`
	ContactType    sql.NullString `json:"contact_type"`
}

func (q *Queries) GetUsersByRoleWithContacts(ctx context.Context, name string) ([]GetUsersByRoleWithContactsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetUsersByRoleWithContacts, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsersByRoleWithContactsRow{}
	for rows.Next() {
		var i GetUsersByRoleWithContactsRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.HashedPassword,
			&i.IsActive,
			&i.IsAdmin,
			&i.LastLogin,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ContactID,
			&i.FirstName,
			&i.LastName,
			&i.ContactEmail,
			&i.ContactType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUsersWithContacts = `-- name: GetUsersWithContacts :many
SELECT 
    u.id, u.username, u.email, u.hashed_password, u.is_active, u.is_admin, u.last_login, u.created_at, u.updated_at,
    c.id as contact_id,
    c.first_name,
    c.last_name,
    c.email as contact_email,
    c.contact_type
FROM users u
LEFT JOIN uf_match ufm ON u.id = ufm.uf_id
LEFT JOIN contacts c ON ufm.contact_id = c.id
WHERE u.is_active = true
ORDER BY u.username
`

type GetUsersWithContactsRow struct {
	ID             uuid.UUID      `json:"id"`
	Username       string         `json:"username"`
	Email          string         `json:"email"`
	HashedPassword string         `json:"hashed_password"`
	IsActive       sql.NullBool   `json:"is_active"`
	IsAdmin        sql.NullBool   `json:"is_admin"`
	LastLogin      sql.NullTime   `json:"last_login"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	UpdatedAt      sql.NullTime   `json:"updated_at"`
	ContactID      uuid.NullUUID  `json:"contact_id"`
	FirstName      sql.NullString `json:"first_name"`
	LastName       sql.NullString `json:"last_name"`
	ContactEmail   sql.NullString `json:"contact_email"`
	ContactType    sql.NullString `json:"contact_type"`
}

func (q *Queries) GetUsersWithContacts(ctx context.Context) ([]GetUsersWithContactsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetUsersWithContacts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsersWithContactsRow{}
	for rows.Next() {
		var i GetUsersWithContactsRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.HashedPassword,
			&i.IsActive,
			&i.IsAdmin,
			&i.LastLogin,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ContactID,
			&i.FirstName,
			&i.LastName,
			&i.ContactEmail,
			&i.ContactType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListUFMatches = `-- name: ListUFMatches :many
SELECT id, domain_id, uf_id, uf_name, contact_id, language, created_at, updated_at FROM uf_match
ORDER BY uf_name
`

func (q *Queries) ListUFMatches(ctx context.Context) ([]UfMatch, error) {
	rows, err := q.db.QueryContext(ctx, ListUFMatches)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UfMatch{}
	for rows.Next() {
		var i UfMatch
		if err := rows.Scan(
			&i.ID,
			&i.DomainID,
			&i.UfID,
			&i.UfName,
			&i.ContactID,
			&i.Language,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListUsers = `-- name: ListUsers :many
SELECT id, username, email, hashed_password, is_active, is_admin, last_login, created_at, updated_at FROM users
WHERE is_active = true
ORDER BY username
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, ListUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.HashedPassword,
			&i.IsActive,
			&i.IsAdmin,
			&i.LastLogin,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListUsersByRole = `-- name: ListUsersByRole :many
SELECT u.id, u.username, u.email, u.hashed_password, u.is_active, u.is_admin, u.last_login, u.created_at, u.updated_at FROM users u
INNER JOIN acl_entity_roles aer ON u.id = aer.entity_id
INNER JOIN acl_roles ar ON aer.acl_role_id = ar.id
WHERE aer.entity_table = 'users' 
AND ar.name = $1 
AND u.is_active = true
AND aer.is_active = true
ORDER BY u.username
`

func (q *Queries) ListUsersByRole(ctx context.Context, name string) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, ListUsersByRole, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.HashedPassword,
			&i.IsActive,
			&i.IsAdmin,
			&i.LastLogin,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const RemoveUserFromRole = `-- name: RemoveUserFromRole :exec
UPDATE acl_entity_roles
SET is_active = false, updated_at = NOW()
WHERE entity_table = 'users' 
AND entity_id = $2
AND acl_role_id = (SELECT id FROM acl_roles WHERE name = $1)
`

type RemoveUserFromRoleParams struct {
	Name     string    `json:"name"`
	EntityID uuid.UUID `json:"entity_id"`
}

func (q *Queries) RemoveUserFromRole(ctx context.Context, arg RemoveUserFromRoleParams) error {
	_, err := q.db.ExecContext(ctx, RemoveUserFromRole, arg.Name, arg.EntityID)
	return err
}

const SearchUsers = `-- name: SearchUsers :many
SELECT id, username, email, hashed_password, is_active, is_admin, last_login, created_at, updated_at FROM users
WHERE is_active = true
AND (
    username ILIKE '%' || $1 || '%' OR
    email ILIKE '%' || $1 || '%'
)
ORDER BY username
LIMIT $2 OFFSET $3
`

type SearchUsersParams struct {
	Column1 sql.NullString `json:"column_1"`
	Limit   int32          `json:"limit"`
	Offset  int32          `json:"offset"`
}

func (q *Queries) SearchUsers(ctx context.Context, arg SearchUsersParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, SearchUsers, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.HashedPassword,
			&i.IsActive,
			&i.IsAdmin,
			&i.LastLogin,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateUFMatch = `-- name: UpdateUFMatch :one
UPDATE uf_match
SET domain_id = $2, uf_name = $3, contact_id = $4, language = $5, updated_at = NOW()
WHERE id = $1
RETURNING id, domain_id, uf_id, uf_name, contact_id, language, created_at, updated_at
`

type UpdateUFMatchParams struct {
	ID        uuid.UUID      `json:"id"`
	DomainID  uuid.UUID      `json:"domain_id"`
	UfName    sql.NullString `json:"uf_name"`
	ContactID uuid.NullUUID  `json:"contact_id"`
	Language  sql.NullString `json:"language"`
}

func (q *Queries) UpdateUFMatch(ctx context.Context, arg UpdateUFMatchParams) (UfMatch, error) {
	row := q.db.QueryRowContext(ctx, UpdateUFMatch,
		arg.ID,
		arg.DomainID,
		arg.UfName,
		arg.ContactID,
		arg.Language,
	)
	var i UfMatch
	err := row.Scan(
		&i.ID,
		&i.DomainID,
		&i.UfID,
		&i.UfName,
		&i.ContactID,
		&i.Language,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateUser = `-- name: UpdateUser :one
UPDATE users
SET username = $2, email = $3, is_active = $4, is_admin = $5, updated_at = NOW()
WHERE id = $1
RETURNING id, username, email, hashed_password, is_active, is_admin, last_login, created_at, updated_at
`

type UpdateUserParams struct {
	ID       uuid.UUID    `json:"id"`
	Username string       `json:"username"`
	Email    string       `json:"email"`
	IsActive sql.NullBool `json:"is_active"`
	IsAdmin  sql.NullBool `json:"is_admin"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, UpdateUser,
		arg.ID,
		arg.Username,
		arg.Email,
		arg.IsActive,
		arg.IsAdmin,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.IsActive,
		&i.IsAdmin,
		&i.LastLogin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateUserLastLogin = `-- name: UpdateUserLastLogin :one
UPDATE users
SET last_login = NOW(), updated_at = NOW()
WHERE id = $1
RETURNING id, username, email, hashed_password, is_active, is_admin, last_login, created_at, updated_at
`

func (q *Queries) UpdateUserLastLogin(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, UpdateUserLastLogin, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.IsActive,
		&i.IsAdmin,
		&i.LastLogin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateUserPassword = `-- name: UpdateUserPassword :one
UPDATE users
SET hashed_password = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, username, email, hashed_password, is_active, is_admin, last_login, created_at, updated_at
`

type UpdateUserPasswordParams struct {
	ID             uuid.UUID `json:"id"`
	HashedPassword string    `json:"hashed_password"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) (User, error) {
	row := q.db.QueryRowContext(ctx, UpdateUserPassword, arg.ID, arg.HashedPassword)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.IsActive,
		&i.IsAdmin,
		&i.LastLogin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
