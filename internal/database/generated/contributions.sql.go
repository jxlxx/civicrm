// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: contributions.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const CountContributions = `-- name: CountContributions :one
SELECT COUNT(*) FROM contributions
`

func (q *Queries) CountContributions(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountContributions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountContributionsByContact = `-- name: CountContributionsByContact :one
SELECT COUNT(*) FROM contributions WHERE contact_id = $1
`

func (q *Queries) CountContributionsByContact(ctx context.Context, contactID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountContributionsByContact, contactID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountContributionsByStatus = `-- name: CountContributionsByStatus :one
SELECT COUNT(*) FROM contributions WHERE status = $1
`

func (q *Queries) CountContributionsByStatus(ctx context.Context, status sql.NullString) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountContributionsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountContributionsByType = `-- name: CountContributionsByType :one
SELECT COUNT(*) FROM contributions WHERE contribution_type = $1
`

func (q *Queries) CountContributionsByType(ctx context.Context, contributionType sql.NullString) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountContributionsByType, contributionType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateContribution = `-- name: CreateContribution :one
INSERT INTO contributions (
    contact_id, amount, currency, contribution_type, status
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, contact_id, amount, currency, contribution_type, status, received_date, created_at, updated_at
`

type CreateContributionParams struct {
	ContactID        uuid.UUID      `json:"contact_id"`
	Amount           string         `json:"amount"`
	Currency         sql.NullString `json:"currency"`
	ContributionType sql.NullString `json:"contribution_type"`
	Status           sql.NullString `json:"status"`
}

func (q *Queries) CreateContribution(ctx context.Context, arg CreateContributionParams) (Contribution, error) {
	row := q.db.QueryRowContext(ctx, CreateContribution,
		arg.ContactID,
		arg.Amount,
		arg.Currency,
		arg.ContributionType,
		arg.Status,
	)
	var i Contribution
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.Amount,
		&i.Currency,
		&i.ContributionType,
		&i.Status,
		&i.ReceivedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const DeleteContribution = `-- name: DeleteContribution :exec
DELETE FROM contributions WHERE id = $1
`

func (q *Queries) DeleteContribution(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteContribution, id)
	return err
}

const GetContribution = `-- name: GetContribution :one
SELECT id, contact_id, amount, currency, contribution_type, status, received_date, created_at, updated_at FROM contributions WHERE id = $1
`

func (q *Queries) GetContribution(ctx context.Context, id uuid.UUID) (Contribution, error) {
	row := q.db.QueryRowContext(ctx, GetContribution, id)
	var i Contribution
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.Amount,
		&i.Currency,
		&i.ContributionType,
		&i.Status,
		&i.ReceivedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetContributionsByContact = `-- name: GetContributionsByContact :many
SELECT id, contact_id, amount, currency, contribution_type, status, received_date, created_at, updated_at FROM contributions 
WHERE contact_id = $1 
ORDER BY received_date DESC
`

func (q *Queries) GetContributionsByContact(ctx context.Context, contactID uuid.UUID) ([]Contribution, error) {
	rows, err := q.db.QueryContext(ctx, GetContributionsByContact, contactID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Contribution{}
	for rows.Next() {
		var i Contribution
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.Amount,
			&i.Currency,
			&i.ContributionType,
			&i.Status,
			&i.ReceivedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetContributionsByDateRange = `-- name: GetContributionsByDateRange :many
SELECT 
    c.id, c.contact_id, c.amount, c.currency, c.contribution_type, c.status, c.received_date, c.created_at, c.updated_at,
    co.contact_type,
    co.first_name,
    co.last_name,
    co.organization_name,
    co.email
FROM contributions c
JOIN contacts co ON c.contact_id = co.id
WHERE c.received_date >= $1 AND c.received_date <= $2
ORDER BY c.received_date DESC
`

type GetContributionsByDateRangeParams struct {
	ReceivedDate   sql.NullTime `json:"received_date"`
	ReceivedDate_2 sql.NullTime `json:"received_date_2"`
}

type GetContributionsByDateRangeRow struct {
	ID               uuid.UUID      `json:"id"`
	ContactID        uuid.UUID      `json:"contact_id"`
	Amount           string         `json:"amount"`
	Currency         sql.NullString `json:"currency"`
	ContributionType sql.NullString `json:"contribution_type"`
	Status           sql.NullString `json:"status"`
	ReceivedDate     sql.NullTime   `json:"received_date"`
	CreatedAt        sql.NullTime   `json:"created_at"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
	ContactType      string         `json:"contact_type"`
	FirstName        sql.NullString `json:"first_name"`
	LastName         sql.NullString `json:"last_name"`
	OrganizationName sql.NullString `json:"organization_name"`
	Email            sql.NullString `json:"email"`
}

func (q *Queries) GetContributionsByDateRange(ctx context.Context, arg GetContributionsByDateRangeParams) ([]GetContributionsByDateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, GetContributionsByDateRange, arg.ReceivedDate, arg.ReceivedDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetContributionsByDateRangeRow{}
	for rows.Next() {
		var i GetContributionsByDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.Amount,
			&i.Currency,
			&i.ContributionType,
			&i.Status,
			&i.ReceivedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ContactType,
			&i.FirstName,
			&i.LastName,
			&i.OrganizationName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetTotalContributions = `-- name: GetTotalContributions :one
SELECT SUM(amount) FROM contributions WHERE status = 'Completed'
`

func (q *Queries) GetTotalContributions(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, GetTotalContributions)
	var sum int64
	err := row.Scan(&sum)
	return sum, err
}

const GetTotalContributionsByContact = `-- name: GetTotalContributionsByContact :one
SELECT SUM(amount) FROM contributions WHERE contact_id = $1 AND status = 'Completed'
`

func (q *Queries) GetTotalContributionsByContact(ctx context.Context, contactID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, GetTotalContributionsByContact, contactID)
	var sum int64
	err := row.Scan(&sum)
	return sum, err
}

const ListContributions = `-- name: ListContributions :many
SELECT 
    c.id, c.contact_id, c.amount, c.currency, c.contribution_type, c.status, c.received_date, c.created_at, c.updated_at,
    co.contact_type,
    co.first_name,
    co.last_name,
    co.organization_name,
    co.email
FROM contributions c
JOIN contacts co ON c.contact_id = co.id
ORDER BY c.received_date DESC 
LIMIT $1 OFFSET $2
`

type ListContributionsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListContributionsRow struct {
	ID               uuid.UUID      `json:"id"`
	ContactID        uuid.UUID      `json:"contact_id"`
	Amount           string         `json:"amount"`
	Currency         sql.NullString `json:"currency"`
	ContributionType sql.NullString `json:"contribution_type"`
	Status           sql.NullString `json:"status"`
	ReceivedDate     sql.NullTime   `json:"received_date"`
	CreatedAt        sql.NullTime   `json:"created_at"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
	ContactType      string         `json:"contact_type"`
	FirstName        sql.NullString `json:"first_name"`
	LastName         sql.NullString `json:"last_name"`
	OrganizationName sql.NullString `json:"organization_name"`
	Email            sql.NullString `json:"email"`
}

func (q *Queries) ListContributions(ctx context.Context, arg ListContributionsParams) ([]ListContributionsRow, error) {
	rows, err := q.db.QueryContext(ctx, ListContributions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListContributionsRow{}
	for rows.Next() {
		var i ListContributionsRow
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.Amount,
			&i.Currency,
			&i.ContributionType,
			&i.Status,
			&i.ReceivedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ContactType,
			&i.FirstName,
			&i.LastName,
			&i.OrganizationName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListContributionsByStatus = `-- name: ListContributionsByStatus :many
SELECT 
    c.id, c.contact_id, c.amount, c.currency, c.contribution_type, c.status, c.received_date, c.created_at, c.updated_at,
    co.contact_type,
    co.first_name,
    co.last_name,
    co.organization_name,
    co.email
FROM contributions c
JOIN contacts co ON c.contact_id = co.id
WHERE c.status = $1
ORDER BY c.received_date DESC 
LIMIT $2 OFFSET $3
`

type ListContributionsByStatusParams struct {
	Status sql.NullString `json:"status"`
	Limit  int32          `json:"limit"`
	Offset int32          `json:"offset"`
}

type ListContributionsByStatusRow struct {
	ID               uuid.UUID      `json:"id"`
	ContactID        uuid.UUID      `json:"contact_id"`
	Amount           string         `json:"amount"`
	Currency         sql.NullString `json:"currency"`
	ContributionType sql.NullString `json:"contribution_type"`
	Status           sql.NullString `json:"status"`
	ReceivedDate     sql.NullTime   `json:"received_date"`
	CreatedAt        sql.NullTime   `json:"created_at"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
	ContactType      string         `json:"contact_type"`
	FirstName        sql.NullString `json:"first_name"`
	LastName         sql.NullString `json:"last_name"`
	OrganizationName sql.NullString `json:"organization_name"`
	Email            sql.NullString `json:"email"`
}

func (q *Queries) ListContributionsByStatus(ctx context.Context, arg ListContributionsByStatusParams) ([]ListContributionsByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, ListContributionsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListContributionsByStatusRow{}
	for rows.Next() {
		var i ListContributionsByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.Amount,
			&i.Currency,
			&i.ContributionType,
			&i.Status,
			&i.ReceivedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ContactType,
			&i.FirstName,
			&i.LastName,
			&i.OrganizationName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListContributionsByType = `-- name: ListContributionsByType :many
SELECT 
    c.id, c.contact_id, c.amount, c.currency, c.contribution_type, c.status, c.received_date, c.created_at, c.updated_at,
    co.contact_type,
    co.first_name,
    co.last_name,
    co.organization_name,
    co.email
FROM contributions c
JOIN contacts co ON c.contact_id = co.id
WHERE c.contribution_type = $1
ORDER BY c.received_date DESC 
LIMIT $2 OFFSET $3
`

type ListContributionsByTypeParams struct {
	ContributionType sql.NullString `json:"contribution_type"`
	Limit            int32          `json:"limit"`
	Offset           int32          `json:"offset"`
}

type ListContributionsByTypeRow struct {
	ID               uuid.UUID      `json:"id"`
	ContactID        uuid.UUID      `json:"contact_id"`
	Amount           string         `json:"amount"`
	Currency         sql.NullString `json:"currency"`
	ContributionType sql.NullString `json:"contribution_type"`
	Status           sql.NullString `json:"status"`
	ReceivedDate     sql.NullTime   `json:"received_date"`
	CreatedAt        sql.NullTime   `json:"created_at"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
	ContactType      string         `json:"contact_type"`
	FirstName        sql.NullString `json:"first_name"`
	LastName         sql.NullString `json:"last_name"`
	OrganizationName sql.NullString `json:"organization_name"`
	Email            sql.NullString `json:"email"`
}

func (q *Queries) ListContributionsByType(ctx context.Context, arg ListContributionsByTypeParams) ([]ListContributionsByTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, ListContributionsByType, arg.ContributionType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListContributionsByTypeRow{}
	for rows.Next() {
		var i ListContributionsByTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.Amount,
			&i.Currency,
			&i.ContributionType,
			&i.Status,
			&i.ReceivedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ContactType,
			&i.FirstName,
			&i.LastName,
			&i.OrganizationName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchContributions = `-- name: SearchContributions :many
SELECT 
    c.id, c.contact_id, c.amount, c.currency, c.contribution_type, c.status, c.received_date, c.created_at, c.updated_at,
    co.contact_type,
    co.first_name,
    co.last_name,
    co.organization_name,
    co.email
FROM contributions c
JOIN contacts co ON c.contact_id = co.id
WHERE (
    co.first_name ILIKE $1 OR 
    co.last_name ILIKE $1 OR 
    co.organization_name ILIKE $1 OR
    co.email ILIKE $1
)
ORDER BY c.received_date DESC 
LIMIT $2 OFFSET $3
`

type SearchContributionsParams struct {
	FirstName sql.NullString `json:"first_name"`
	Limit     int32          `json:"limit"`
	Offset    int32          `json:"offset"`
}

type SearchContributionsRow struct {
	ID               uuid.UUID      `json:"id"`
	ContactID        uuid.UUID      `json:"contact_id"`
	Amount           string         `json:"amount"`
	Currency         sql.NullString `json:"currency"`
	ContributionType sql.NullString `json:"contribution_type"`
	Status           sql.NullString `json:"status"`
	ReceivedDate     sql.NullTime   `json:"received_date"`
	CreatedAt        sql.NullTime   `json:"created_at"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
	ContactType      string         `json:"contact_type"`
	FirstName        sql.NullString `json:"first_name"`
	LastName         sql.NullString `json:"last_name"`
	OrganizationName sql.NullString `json:"organization_name"`
	Email            sql.NullString `json:"email"`
}

func (q *Queries) SearchContributions(ctx context.Context, arg SearchContributionsParams) ([]SearchContributionsRow, error) {
	rows, err := q.db.QueryContext(ctx, SearchContributions, arg.FirstName, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchContributionsRow{}
	for rows.Next() {
		var i SearchContributionsRow
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.Amount,
			&i.Currency,
			&i.ContributionType,
			&i.Status,
			&i.ReceivedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ContactType,
			&i.FirstName,
			&i.LastName,
			&i.OrganizationName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateContribution = `-- name: UpdateContribution :one
UPDATE contributions 
SET 
    amount = $2,
    currency = $3,
    contribution_type = $4,
    status = $5,
    updated_at = NOW()
WHERE id = $1 
RETURNING id, contact_id, amount, currency, contribution_type, status, received_date, created_at, updated_at
`

type UpdateContributionParams struct {
	ID               uuid.UUID      `json:"id"`
	Amount           string         `json:"amount"`
	Currency         sql.NullString `json:"currency"`
	ContributionType sql.NullString `json:"contribution_type"`
	Status           sql.NullString `json:"status"`
}

func (q *Queries) UpdateContribution(ctx context.Context, arg UpdateContributionParams) (Contribution, error) {
	row := q.db.QueryRowContext(ctx, UpdateContribution,
		arg.ID,
		arg.Amount,
		arg.Currency,
		arg.ContributionType,
		arg.Status,
	)
	var i Contribution
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.Amount,
		&i.Currency,
		&i.ContributionType,
		&i.Status,
		&i.ReceivedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
