// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: uf_groups.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const CountActiveUFGroupsByDomain = `-- name: CountActiveUFGroupsByDomain :one
SELECT COUNT(*) FROM uf_groups WHERE domain_id = $1 AND is_active = TRUE
`

func (q *Queries) CountActiveUFGroupsByDomain(ctx context.Context, domainID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountActiveUFGroupsByDomain, domainID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountUFGroupsByDomain = `-- name: CountUFGroupsByDomain :one
SELECT COUNT(*) FROM uf_groups WHERE domain_id = $1
`

func (q *Queries) CountUFGroupsByDomain(ctx context.Context, domainID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountUFGroupsByDomain, domainID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateUFGroup = `-- name: CreateUFGroup :one
INSERT INTO uf_groups (
    domain_id, name, title, description, is_active, is_reserved
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, domain_id, name, title, description, is_active, is_reserved, created_at, updated_at
`

type CreateUFGroupParams struct {
	DomainID    uuid.UUID      `json:"domain_id"`
	Name        string         `json:"name"`
	Title       string         `json:"title"`
	Description sql.NullString `json:"description"`
	IsActive    sql.NullBool   `json:"is_active"`
	IsReserved  sql.NullBool   `json:"is_reserved"`
}

func (q *Queries) CreateUFGroup(ctx context.Context, arg CreateUFGroupParams) (UfGroup, error) {
	row := q.db.QueryRowContext(ctx, CreateUFGroup,
		arg.DomainID,
		arg.Name,
		arg.Title,
		arg.Description,
		arg.IsActive,
		arg.IsReserved,
	)
	var i UfGroup
	err := row.Scan(
		&i.ID,
		&i.DomainID,
		&i.Name,
		&i.Title,
		&i.Description,
		&i.IsActive,
		&i.IsReserved,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const DeleteUFGroup = `-- name: DeleteUFGroup :exec
DELETE FROM uf_groups WHERE id = $1 AND domain_id = $2
`

type DeleteUFGroupParams struct {
	ID       uuid.UUID `json:"id"`
	DomainID uuid.UUID `json:"domain_id"`
}

func (q *Queries) DeleteUFGroup(ctx context.Context, arg DeleteUFGroupParams) error {
	_, err := q.db.ExecContext(ctx, DeleteUFGroup, arg.ID, arg.DomainID)
	return err
}

const DeleteUFGroupsByDomain = `-- name: DeleteUFGroupsByDomain :exec
DELETE FROM uf_groups WHERE domain_id = $1
`

func (q *Queries) DeleteUFGroupsByDomain(ctx context.Context, domainID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteUFGroupsByDomain, domainID)
	return err
}

const GetUFGroup = `-- name: GetUFGroup :one
SELECT id, domain_id, name, title, description, is_active, is_reserved, created_at, updated_at FROM uf_groups WHERE id = $1
`

func (q *Queries) GetUFGroup(ctx context.Context, id uuid.UUID) (UfGroup, error) {
	row := q.db.QueryRowContext(ctx, GetUFGroup, id)
	var i UfGroup
	err := row.Scan(
		&i.ID,
		&i.DomainID,
		&i.Name,
		&i.Title,
		&i.Description,
		&i.IsActive,
		&i.IsReserved,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetUFGroupByName = `-- name: GetUFGroupByName :one
SELECT id, domain_id, name, title, description, is_active, is_reserved, created_at, updated_at FROM uf_groups WHERE domain_id = $1 AND name = $2
`

type GetUFGroupByNameParams struct {
	DomainID uuid.UUID `json:"domain_id"`
	Name     string    `json:"name"`
}

func (q *Queries) GetUFGroupByName(ctx context.Context, arg GetUFGroupByNameParams) (UfGroup, error) {
	row := q.db.QueryRowContext(ctx, GetUFGroupByName, arg.DomainID, arg.Name)
	var i UfGroup
	err := row.Scan(
		&i.ID,
		&i.DomainID,
		&i.Name,
		&i.Title,
		&i.Description,
		&i.IsActive,
		&i.IsReserved,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetUFGroupByTitle = `-- name: GetUFGroupByTitle :one
SELECT id, domain_id, name, title, description, is_active, is_reserved, created_at, updated_at FROM uf_groups WHERE domain_id = $1 AND title = $2
`

type GetUFGroupByTitleParams struct {
	DomainID uuid.UUID `json:"domain_id"`
	Title    string    `json:"title"`
}

func (q *Queries) GetUFGroupByTitle(ctx context.Context, arg GetUFGroupByTitleParams) (UfGroup, error) {
	row := q.db.QueryRowContext(ctx, GetUFGroupByTitle, arg.DomainID, arg.Title)
	var i UfGroup
	err := row.Scan(
		&i.ID,
		&i.DomainID,
		&i.Name,
		&i.Title,
		&i.Description,
		&i.IsActive,
		&i.IsReserved,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetUFGroupWithFields = `-- name: GetUFGroupWithFields :many
SELECT ufg.id, ufg.domain_id, ufg.name, ufg.title, ufg.description, ufg.is_active, ufg.is_reserved, ufg.created_at, ufg.updated_at, uff.id, uff.uf_group_id, uff.name, uff.label, uff.field_type, uff.is_required, uff.is_active, uff.weight, uff.help_pre, uff.help_post, uff.options, uff.validation_rules, uff.created_at, uff.updated_at FROM uf_groups ufg
LEFT JOIN uf_fields uff ON ufg.id = uff.uf_group_id
WHERE ufg.id = $1
ORDER BY uff.weight ASC, uff.name ASC
`

type GetUFGroupWithFieldsRow struct {
	ID              uuid.UUID      `json:"id"`
	DomainID        uuid.UUID      `json:"domain_id"`
	Name            string         `json:"name"`
	Title           string         `json:"title"`
	Description     sql.NullString `json:"description"`
	IsActive        sql.NullBool   `json:"is_active"`
	IsReserved      sql.NullBool   `json:"is_reserved"`
	CreatedAt       sql.NullTime   `json:"created_at"`
	UpdatedAt       sql.NullTime   `json:"updated_at"`
	ID_2            uuid.NullUUID  `json:"id_2"`
	UfGroupID       uuid.NullUUID  `json:"uf_group_id"`
	Name_2          sql.NullString `json:"name_2"`
	Label           sql.NullString `json:"label"`
	FieldType       sql.NullString `json:"field_type"`
	IsRequired      sql.NullBool   `json:"is_required"`
	IsActive_2      sql.NullBool   `json:"is_active_2"`
	Weight          sql.NullInt32  `json:"weight"`
	HelpPre         sql.NullString `json:"help_pre"`
	HelpPost        sql.NullString `json:"help_post"`
	Options         sql.NullString `json:"options"`
	ValidationRules sql.NullString `json:"validation_rules"`
	CreatedAt_2     sql.NullTime   `json:"created_at_2"`
	UpdatedAt_2     sql.NullTime   `json:"updated_at_2"`
}

func (q *Queries) GetUFGroupWithFields(ctx context.Context, id uuid.UUID) ([]GetUFGroupWithFieldsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetUFGroupWithFields, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUFGroupWithFieldsRow{}
	for rows.Next() {
		var i GetUFGroupWithFieldsRow
		if err := rows.Scan(
			&i.ID,
			&i.DomainID,
			&i.Name,
			&i.Title,
			&i.Description,
			&i.IsActive,
			&i.IsReserved,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.UfGroupID,
			&i.Name_2,
			&i.Label,
			&i.FieldType,
			&i.IsRequired,
			&i.IsActive_2,
			&i.Weight,
			&i.HelpPre,
			&i.HelpPost,
			&i.Options,
			&i.ValidationRules,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUFGroupWithJoins = `-- name: GetUFGroupWithJoins :many
SELECT ufg.id, ufg.domain_id, ufg.name, ufg.title, ufg.description, ufg.is_active, ufg.is_reserved, ufg.created_at, ufg.updated_at, ufj.id, ufj.uf_group_id, ufj.entity_table, ufj.entity_id, ufj.weight, ufj.is_active, ufj.created_at, ufj.updated_at FROM uf_groups ufg
LEFT JOIN uf_joins ufj ON ufg.id = ufj.uf_group_id
WHERE ufg.id = $1
ORDER BY ufj.weight ASC
`

type GetUFGroupWithJoinsRow struct {
	ID          uuid.UUID      `json:"id"`
	DomainID    uuid.UUID      `json:"domain_id"`
	Name        string         `json:"name"`
	Title       string         `json:"title"`
	Description sql.NullString `json:"description"`
	IsActive    sql.NullBool   `json:"is_active"`
	IsReserved  sql.NullBool   `json:"is_reserved"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	UpdatedAt   sql.NullTime   `json:"updated_at"`
	ID_2        uuid.NullUUID  `json:"id_2"`
	UfGroupID   uuid.NullUUID  `json:"uf_group_id"`
	EntityTable sql.NullString `json:"entity_table"`
	EntityID    uuid.NullUUID  `json:"entity_id"`
	Weight      sql.NullInt32  `json:"weight"`
	IsActive_2  sql.NullBool   `json:"is_active_2"`
	CreatedAt_2 sql.NullTime   `json:"created_at_2"`
	UpdatedAt_2 sql.NullTime   `json:"updated_at_2"`
}

func (q *Queries) GetUFGroupWithJoins(ctx context.Context, id uuid.UUID) ([]GetUFGroupWithJoinsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetUFGroupWithJoins, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUFGroupWithJoinsRow{}
	for rows.Next() {
		var i GetUFGroupWithJoinsRow
		if err := rows.Scan(
			&i.ID,
			&i.DomainID,
			&i.Name,
			&i.Title,
			&i.Description,
			&i.IsActive,
			&i.IsReserved,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.UfGroupID,
			&i.EntityTable,
			&i.EntityID,
			&i.Weight,
			&i.IsActive_2,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUFGroupsByEntity = `-- name: GetUFGroupsByEntity :many
SELECT ufg.id, ufg.domain_id, ufg.name, ufg.title, ufg.description, ufg.is_active, ufg.is_reserved, ufg.created_at, ufg.updated_at FROM uf_groups ufg
INNER JOIN uf_joins ufj ON ufg.id = ufj.uf_group_id
WHERE ufj.entity_table = $1 AND ufj.entity_id = $2 AND ufg.is_active = TRUE
ORDER BY ufj.weight ASC, ufg.title ASC
`

type GetUFGroupsByEntityParams struct {
	EntityTable string        `json:"entity_table"`
	EntityID    uuid.NullUUID `json:"entity_id"`
}

func (q *Queries) GetUFGroupsByEntity(ctx context.Context, arg GetUFGroupsByEntityParams) ([]UfGroup, error) {
	rows, err := q.db.QueryContext(ctx, GetUFGroupsByEntity, arg.EntityTable, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UfGroup{}
	for rows.Next() {
		var i UfGroup
		if err := rows.Scan(
			&i.ID,
			&i.DomainID,
			&i.Name,
			&i.Title,
			&i.Description,
			&i.IsActive,
			&i.IsReserved,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListActiveUFGroupsByDomain = `-- name: ListActiveUFGroupsByDomain :many
SELECT id, domain_id, name, title, description, is_active, is_reserved, created_at, updated_at FROM uf_groups 
WHERE domain_id = $1 AND is_active = TRUE 
ORDER BY title ASC
`

func (q *Queries) ListActiveUFGroupsByDomain(ctx context.Context, domainID uuid.UUID) ([]UfGroup, error) {
	rows, err := q.db.QueryContext(ctx, ListActiveUFGroupsByDomain, domainID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UfGroup{}
	for rows.Next() {
		var i UfGroup
		if err := rows.Scan(
			&i.ID,
			&i.DomainID,
			&i.Name,
			&i.Title,
			&i.Description,
			&i.IsActive,
			&i.IsReserved,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListAllUFGroups = `-- name: ListAllUFGroups :many
SELECT ufg.id, ufg.domain_id, ufg.name, ufg.title, ufg.description, ufg.is_active, ufg.is_reserved, ufg.created_at, ufg.updated_at, d.name as domain_name FROM uf_groups ufg
INNER JOIN domains d ON ufg.domain_id = d.id
ORDER BY d.name ASC, ufg.title ASC
`

type ListAllUFGroupsRow struct {
	ID          uuid.UUID      `json:"id"`
	DomainID    uuid.UUID      `json:"domain_id"`
	Name        string         `json:"name"`
	Title       string         `json:"title"`
	Description sql.NullString `json:"description"`
	IsActive    sql.NullBool   `json:"is_active"`
	IsReserved  sql.NullBool   `json:"is_reserved"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	UpdatedAt   sql.NullTime   `json:"updated_at"`
	DomainName  string         `json:"domain_name"`
}

func (q *Queries) ListAllUFGroups(ctx context.Context) ([]ListAllUFGroupsRow, error) {
	rows, err := q.db.QueryContext(ctx, ListAllUFGroups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllUFGroupsRow{}
	for rows.Next() {
		var i ListAllUFGroupsRow
		if err := rows.Scan(
			&i.ID,
			&i.DomainID,
			&i.Name,
			&i.Title,
			&i.Description,
			&i.IsActive,
			&i.IsReserved,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DomainName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListReservedUFGroupsByDomain = `-- name: ListReservedUFGroupsByDomain :many
SELECT id, domain_id, name, title, description, is_active, is_reserved, created_at, updated_at FROM uf_groups 
WHERE domain_id = $1 AND is_reserved = TRUE 
ORDER BY title ASC
`

func (q *Queries) ListReservedUFGroupsByDomain(ctx context.Context, domainID uuid.UUID) ([]UfGroup, error) {
	rows, err := q.db.QueryContext(ctx, ListReservedUFGroupsByDomain, domainID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UfGroup{}
	for rows.Next() {
		var i UfGroup
		if err := rows.Scan(
			&i.ID,
			&i.DomainID,
			&i.Name,
			&i.Title,
			&i.Description,
			&i.IsActive,
			&i.IsReserved,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListUFGroupsByDomain = `-- name: ListUFGroupsByDomain :many
SELECT id, domain_id, name, title, description, is_active, is_reserved, created_at, updated_at FROM uf_groups 
WHERE domain_id = $1 
ORDER BY title ASC
`

func (q *Queries) ListUFGroupsByDomain(ctx context.Context, domainID uuid.UUID) ([]UfGroup, error) {
	rows, err := q.db.QueryContext(ctx, ListUFGroupsByDomain, domainID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UfGroup{}
	for rows.Next() {
		var i UfGroup
		if err := rows.Scan(
			&i.ID,
			&i.DomainID,
			&i.Name,
			&i.Title,
			&i.Description,
			&i.IsActive,
			&i.IsReserved,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchUFGroups = `-- name: SearchUFGroups :many
SELECT ufg.id, ufg.domain_id, ufg.name, ufg.title, ufg.description, ufg.is_active, ufg.is_reserved, ufg.created_at, ufg.updated_at, d.name as domain_name FROM uf_groups ufg
INNER JOIN domains d ON ufg.domain_id = d.id
WHERE ufg.name ILIKE $1 OR ufg.title ILIKE $1 OR ufg.description ILIKE $1
ORDER BY d.name ASC, ufg.title ASC
LIMIT $2 OFFSET $3
`

type SearchUFGroupsParams struct {
	Name   string `json:"name"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type SearchUFGroupsRow struct {
	ID          uuid.UUID      `json:"id"`
	DomainID    uuid.UUID      `json:"domain_id"`
	Name        string         `json:"name"`
	Title       string         `json:"title"`
	Description sql.NullString `json:"description"`
	IsActive    sql.NullBool   `json:"is_active"`
	IsReserved  sql.NullBool   `json:"is_reserved"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	UpdatedAt   sql.NullTime   `json:"updated_at"`
	DomainName  string         `json:"domain_name"`
}

func (q *Queries) SearchUFGroups(ctx context.Context, arg SearchUFGroupsParams) ([]SearchUFGroupsRow, error) {
	rows, err := q.db.QueryContext(ctx, SearchUFGroups, arg.Name, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchUFGroupsRow{}
	for rows.Next() {
		var i SearchUFGroupsRow
		if err := rows.Scan(
			&i.ID,
			&i.DomainID,
			&i.Name,
			&i.Title,
			&i.Description,
			&i.IsActive,
			&i.IsReserved,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DomainName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateUFGroup = `-- name: UpdateUFGroup :one
UPDATE uf_groups 
SET 
    name = $3,
    title = $4,
    description = $5,
    is_active = $6,
    is_reserved = $7,
    updated_at = NOW()
WHERE id = $1 AND domain_id = $2 
RETURNING id, domain_id, name, title, description, is_active, is_reserved, created_at, updated_at
`

type UpdateUFGroupParams struct {
	ID          uuid.UUID      `json:"id"`
	DomainID    uuid.UUID      `json:"domain_id"`
	Name        string         `json:"name"`
	Title       string         `json:"title"`
	Description sql.NullString `json:"description"`
	IsActive    sql.NullBool   `json:"is_active"`
	IsReserved  sql.NullBool   `json:"is_reserved"`
}

func (q *Queries) UpdateUFGroup(ctx context.Context, arg UpdateUFGroupParams) (UfGroup, error) {
	row := q.db.QueryRowContext(ctx, UpdateUFGroup,
		arg.ID,
		arg.DomainID,
		arg.Name,
		arg.Title,
		arg.Description,
		arg.IsActive,
		arg.IsReserved,
	)
	var i UfGroup
	err := row.Scan(
		&i.ID,
		&i.DomainID,
		&i.Name,
		&i.Title,
		&i.Description,
		&i.IsActive,
		&i.IsReserved,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateUFGroupStatus = `-- name: UpdateUFGroupStatus :one
UPDATE uf_groups 
SET 
    is_active = $3,
    updated_at = NOW()
WHERE id = $1 AND domain_id = $2 
RETURNING id, domain_id, name, title, description, is_active, is_reserved, created_at, updated_at
`

type UpdateUFGroupStatusParams struct {
	ID       uuid.UUID    `json:"id"`
	DomainID uuid.UUID    `json:"domain_id"`
	IsActive sql.NullBool `json:"is_active"`
}

func (q *Queries) UpdateUFGroupStatus(ctx context.Context, arg UpdateUFGroupStatusParams) (UfGroup, error) {
	row := q.db.QueryRowContext(ctx, UpdateUFGroupStatus, arg.ID, arg.DomainID, arg.IsActive)
	var i UfGroup
	err := row.Scan(
		&i.ID,
		&i.DomainID,
		&i.Name,
		&i.Title,
		&i.Description,
		&i.IsActive,
		&i.IsReserved,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
