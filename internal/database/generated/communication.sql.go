// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: communication.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const CountContactsByOptOutStatus = `-- name: CountContactsByOptOutStatus :one
SELECT 
    COUNT(CASE WHEN email_opt_out = true THEN 1 END) as email_opt_out_count,
    COUNT(CASE WHEN sms_opt_out = true THEN 1 END) as sms_opt_out_count,
    COUNT(CASE WHEN mail_opt_out = true THEN 1 END) as mail_opt_out_count,
    COUNT(CASE WHEN phone_opt_out = true THEN 1 END) as phone_opt_out_count
FROM communication_preferences
`

type CountContactsByOptOutStatusRow struct {
	EmailOptOutCount int64 `json:"email_opt_out_count"`
	SmsOptOutCount   int64 `json:"sms_opt_out_count"`
	MailOptOutCount  int64 `json:"mail_opt_out_count"`
	PhoneOptOutCount int64 `json:"phone_opt_out_count"`
}

func (q *Queries) CountContactsByOptOutStatus(ctx context.Context) (CountContactsByOptOutStatusRow, error) {
	row := q.db.QueryRowContext(ctx, CountContactsByOptOutStatus)
	var i CountContactsByOptOutStatusRow
	err := row.Scan(
		&i.EmailOptOutCount,
		&i.SmsOptOutCount,
		&i.MailOptOutCount,
		&i.PhoneOptOutCount,
	)
	return i, err
}

const CreateCommunicationPreferences = `-- name: CreateCommunicationPreferences :one
INSERT INTO communication_preferences (
    contact_id, email_opt_out, sms_opt_out, mail_opt_out, phone_opt_out,
    do_not_email, do_not_sms, do_not_mail, do_not_phone, do_not_trade
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) RETURNING id, contact_id, email_opt_out, sms_opt_out, mail_opt_out, phone_opt_out, do_not_email, do_not_sms, do_not_mail, do_not_phone, do_not_trade, created_at, updated_at
`

type CreateCommunicationPreferencesParams struct {
	ContactID   uuid.UUID    `json:"contact_id"`
	EmailOptOut sql.NullBool `json:"email_opt_out"`
	SmsOptOut   sql.NullBool `json:"sms_opt_out"`
	MailOptOut  sql.NullBool `json:"mail_opt_out"`
	PhoneOptOut sql.NullBool `json:"phone_opt_out"`
	DoNotEmail  sql.NullBool `json:"do_not_email"`
	DoNotSms    sql.NullBool `json:"do_not_sms"`
	DoNotMail   sql.NullBool `json:"do_not_mail"`
	DoNotPhone  sql.NullBool `json:"do_not_phone"`
	DoNotTrade  sql.NullBool `json:"do_not_trade"`
}

// Communication Preferences CRUD operations
func (q *Queries) CreateCommunicationPreferences(ctx context.Context, arg CreateCommunicationPreferencesParams) (CommunicationPreference, error) {
	row := q.db.QueryRowContext(ctx, CreateCommunicationPreferences,
		arg.ContactID,
		arg.EmailOptOut,
		arg.SmsOptOut,
		arg.MailOptOut,
		arg.PhoneOptOut,
		arg.DoNotEmail,
		arg.DoNotSms,
		arg.DoNotMail,
		arg.DoNotPhone,
		arg.DoNotTrade,
	)
	var i CommunicationPreference
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.EmailOptOut,
		&i.SmsOptOut,
		&i.MailOptOut,
		&i.PhoneOptOut,
		&i.DoNotEmail,
		&i.DoNotSms,
		&i.DoNotMail,
		&i.DoNotPhone,
		&i.DoNotTrade,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const CreateMailing = `-- name: CreateMailing :one
INSERT INTO mailings (
    name, subject, body_text, body_html, template_id, mailing_list_id,
    status, scheduled_date, created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, name, subject, body_text, body_html, template_id, mailing_list_id, status, scheduled_date, start_date, end_date, total_recipients, total_sent, total_opened, total_clicked, total_bounced, total_unsubscribed, created_by, created_at, updated_at
`

type CreateMailingParams struct {
	Name          string         `json:"name"`
	Subject       sql.NullString `json:"subject"`
	BodyText      sql.NullString `json:"body_text"`
	BodyHtml      sql.NullString `json:"body_html"`
	TemplateID    uuid.NullUUID  `json:"template_id"`
	MailingListID uuid.NullUUID  `json:"mailing_list_id"`
	Status        sql.NullString `json:"status"`
	ScheduledDate sql.NullTime   `json:"scheduled_date"`
	CreatedBy     uuid.NullUUID  `json:"created_by"`
}

// Mailings CRUD operations
func (q *Queries) CreateMailing(ctx context.Context, arg CreateMailingParams) (Mailing, error) {
	row := q.db.QueryRowContext(ctx, CreateMailing,
		arg.Name,
		arg.Subject,
		arg.BodyText,
		arg.BodyHtml,
		arg.TemplateID,
		arg.MailingListID,
		arg.Status,
		arg.ScheduledDate,
		arg.CreatedBy,
	)
	var i Mailing
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Subject,
		&i.BodyText,
		&i.BodyHtml,
		&i.TemplateID,
		&i.MailingListID,
		&i.Status,
		&i.ScheduledDate,
		&i.StartDate,
		&i.EndDate,
		&i.TotalRecipients,
		&i.TotalSent,
		&i.TotalOpened,
		&i.TotalClicked,
		&i.TotalBounced,
		&i.TotalUnsubscribed,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const CreateMailingList = `-- name: CreateMailingList :one
INSERT INTO mailing_lists (
    name, title, description, is_public, is_hidden, is_active
) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, name, title, description, is_public, is_hidden, is_active, created_at, updated_at
`

type CreateMailingListParams struct {
	Name        string         `json:"name"`
	Title       string         `json:"title"`
	Description sql.NullString `json:"description"`
	IsPublic    sql.NullBool   `json:"is_public"`
	IsHidden    sql.NullBool   `json:"is_hidden"`
	IsActive    sql.NullBool   `json:"is_active"`
}

// Mailing Lists CRUD operations
func (q *Queries) CreateMailingList(ctx context.Context, arg CreateMailingListParams) (MailingList, error) {
	row := q.db.QueryRowContext(ctx, CreateMailingList,
		arg.Name,
		arg.Title,
		arg.Description,
		arg.IsPublic,
		arg.IsHidden,
		arg.IsActive,
	)
	var i MailingList
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Title,
		&i.Description,
		&i.IsPublic,
		&i.IsHidden,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const CreateMailingListSubscription = `-- name: CreateMailingListSubscription :one
INSERT INTO mailing_list_subscriptions (
    mailing_list_id, contact_id, status, source, is_active
) VALUES ($1, $2, $3, $4, $5) RETURNING id, mailing_list_id, contact_id, status, source, is_active, created_at, updated_at
`

type CreateMailingListSubscriptionParams struct {
	MailingListID uuid.UUID      `json:"mailing_list_id"`
	ContactID     uuid.UUID      `json:"contact_id"`
	Status        sql.NullString `json:"status"`
	Source        sql.NullString `json:"source"`
	IsActive      sql.NullBool   `json:"is_active"`
}

// Mailing List Subscriptions CRUD operations
func (q *Queries) CreateMailingListSubscription(ctx context.Context, arg CreateMailingListSubscriptionParams) (MailingListSubscription, error) {
	row := q.db.QueryRowContext(ctx, CreateMailingListSubscription,
		arg.MailingListID,
		arg.ContactID,
		arg.Status,
		arg.Source,
		arg.IsActive,
	)
	var i MailingListSubscription
	err := row.Scan(
		&i.ID,
		&i.MailingListID,
		&i.ContactID,
		&i.Status,
		&i.Source,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const CreateMailingOpen = `-- name: CreateMailingOpen :one
INSERT INTO mailing_opens (
    recipient_id, contact_id, ip_address, user_agent
) VALUES ($1, $2, $3, $4) RETURNING id, recipient_id, contact_id, ip_address, user_agent, opened_at
`

type CreateMailingOpenParams struct {
	RecipientID uuid.UUID      `json:"recipient_id"`
	ContactID   uuid.UUID      `json:"contact_id"`
	IpAddress   pqtype.Inet    `json:"ip_address"`
	UserAgent   sql.NullString `json:"user_agent"`
}

func (q *Queries) CreateMailingOpen(ctx context.Context, arg CreateMailingOpenParams) (MailingOpen, error) {
	row := q.db.QueryRowContext(ctx, CreateMailingOpen,
		arg.RecipientID,
		arg.ContactID,
		arg.IpAddress,
		arg.UserAgent,
	)
	var i MailingOpen
	err := row.Scan(
		&i.ID,
		&i.RecipientID,
		&i.ContactID,
		&i.IpAddress,
		&i.UserAgent,
		&i.OpenedAt,
	)
	return i, err
}

const CreateMailingRecipient = `-- name: CreateMailingRecipient :one
INSERT INTO mailing_recipients (
    mailing_id, contact_id, email, status
) VALUES ($1, $2, $3, $4) RETURNING id, mailing_id, contact_id, email, status, sent_date, delivered_date, opened_date, clicked_date, bounce_reason, created_at, updated_at
`

type CreateMailingRecipientParams struct {
	MailingID uuid.UUID      `json:"mailing_id"`
	ContactID uuid.UUID      `json:"contact_id"`
	Email     string         `json:"email"`
	Status    sql.NullString `json:"status"`
}

// Mailing Recipients CRUD operations
func (q *Queries) CreateMailingRecipient(ctx context.Context, arg CreateMailingRecipientParams) (MailingRecipient, error) {
	row := q.db.QueryRowContext(ctx, CreateMailingRecipient,
		arg.MailingID,
		arg.ContactID,
		arg.Email,
		arg.Status,
	)
	var i MailingRecipient
	err := row.Scan(
		&i.ID,
		&i.MailingID,
		&i.ContactID,
		&i.Email,
		&i.Status,
		&i.SentDate,
		&i.DeliveredDate,
		&i.OpenedDate,
		&i.ClickedDate,
		&i.BounceReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const CreateMessageTemplate = `-- name: CreateMessageTemplate :one

INSERT INTO message_templates (
    name, title, subject, body_text, body_html, template_type, 
    is_active, is_default, workflow_name
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, name, title, subject, body_text, body_html, template_type, is_active, is_default, workflow_name, created_at, updated_at
`

type CreateMessageTemplateParams struct {
	Name         string         `json:"name"`
	Title        string         `json:"title"`
	Subject      sql.NullString `json:"subject"`
	BodyText     sql.NullString `json:"body_text"`
	BodyHtml     sql.NullString `json:"body_html"`
	TemplateType string         `json:"template_type"`
	IsActive     sql.NullBool   `json:"is_active"`
	IsDefault    sql.NullBool   `json:"is_default"`
	WorkflowName sql.NullString `json:"workflow_name"`
}

// Communication System Queries
// Provides CRUD operations and specialized queries for message templates, mailings, and tracking
// Message Templates CRUD operations
func (q *Queries) CreateMessageTemplate(ctx context.Context, arg CreateMessageTemplateParams) (MessageTemplate, error) {
	row := q.db.QueryRowContext(ctx, CreateMessageTemplate,
		arg.Name,
		arg.Title,
		arg.Subject,
		arg.BodyText,
		arg.BodyHtml,
		arg.TemplateType,
		arg.IsActive,
		arg.IsDefault,
		arg.WorkflowName,
	)
	var i MessageTemplate
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Title,
		&i.Subject,
		&i.BodyText,
		&i.BodyHtml,
		&i.TemplateType,
		&i.IsActive,
		&i.IsDefault,
		&i.WorkflowName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const CreateSmsMessage = `-- name: CreateSmsMessage :one
INSERT INTO sms_messages (
    contact_id, phone_number, message, direction, status, provider
) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, contact_id, phone_number, message, direction, status, provider, provider_message_id, sent_at, delivered_at, created_at, updated_at
`

type CreateSmsMessageParams struct {
	ContactID   uuid.UUID      `json:"contact_id"`
	PhoneNumber string         `json:"phone_number"`
	Message     string         `json:"message"`
	Direction   sql.NullString `json:"direction"`
	Status      sql.NullString `json:"status"`
	Provider    sql.NullString `json:"provider"`
}

// SMS Messages CRUD operations
func (q *Queries) CreateSmsMessage(ctx context.Context, arg CreateSmsMessageParams) (SmsMessage, error) {
	row := q.db.QueryRowContext(ctx, CreateSmsMessage,
		arg.ContactID,
		arg.PhoneNumber,
		arg.Message,
		arg.Direction,
		arg.Status,
		arg.Provider,
	)
	var i SmsMessage
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.PhoneNumber,
		&i.Message,
		&i.Direction,
		&i.Status,
		&i.Provider,
		&i.ProviderMessageID,
		&i.SentAt,
		&i.DeliveredAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const CreateTrackableUrl = `-- name: CreateTrackableUrl :one
INSERT INTO mailing_trackable_urls (
    mailing_id, url, original_url
) VALUES ($1, $2, $3) RETURNING id, mailing_id, url, original_url, click_count, unique_clicks, created_at
`

type CreateTrackableUrlParams struct {
	MailingID   uuid.UUID `json:"mailing_id"`
	Url         string    `json:"url"`
	OriginalUrl string    `json:"original_url"`
}

// Mailing Tracking CRUD operations
func (q *Queries) CreateTrackableUrl(ctx context.Context, arg CreateTrackableUrlParams) (MailingTrackableUrl, error) {
	row := q.db.QueryRowContext(ctx, CreateTrackableUrl, arg.MailingID, arg.Url, arg.OriginalUrl)
	var i MailingTrackableUrl
	err := row.Scan(
		&i.ID,
		&i.MailingID,
		&i.Url,
		&i.OriginalUrl,
		&i.ClickCount,
		&i.UniqueClicks,
		&i.CreatedAt,
	)
	return i, err
}

const CreateUrlClick = `-- name: CreateUrlClick :one
INSERT INTO mailing_url_clicks (
    trackable_url_id, recipient_id, contact_id, ip_address, user_agent
) VALUES ($1, $2, $3, $4, $5) RETURNING id, trackable_url_id, recipient_id, contact_id, ip_address, user_agent, clicked_at
`

type CreateUrlClickParams struct {
	TrackableUrlID uuid.UUID      `json:"trackable_url_id"`
	RecipientID    uuid.UUID      `json:"recipient_id"`
	ContactID      uuid.UUID      `json:"contact_id"`
	IpAddress      pqtype.Inet    `json:"ip_address"`
	UserAgent      sql.NullString `json:"user_agent"`
}

func (q *Queries) CreateUrlClick(ctx context.Context, arg CreateUrlClickParams) (MailingUrlClick, error) {
	row := q.db.QueryRowContext(ctx, CreateUrlClick,
		arg.TrackableUrlID,
		arg.RecipientID,
		arg.ContactID,
		arg.IpAddress,
		arg.UserAgent,
	)
	var i MailingUrlClick
	err := row.Scan(
		&i.ID,
		&i.TrackableUrlID,
		&i.RecipientID,
		&i.ContactID,
		&i.IpAddress,
		&i.UserAgent,
		&i.ClickedAt,
	)
	return i, err
}

const DeleteCommunicationPreferences = `-- name: DeleteCommunicationPreferences :exec
DELETE FROM communication_preferences WHERE contact_id = $1
`

func (q *Queries) DeleteCommunicationPreferences(ctx context.Context, contactID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteCommunicationPreferences, contactID)
	return err
}

const DeleteMailing = `-- name: DeleteMailing :exec
DELETE FROM mailings WHERE id = $1
`

func (q *Queries) DeleteMailing(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteMailing, id)
	return err
}

const DeleteMailingList = `-- name: DeleteMailingList :exec
DELETE FROM mailing_lists WHERE id = $1
`

func (q *Queries) DeleteMailingList(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteMailingList, id)
	return err
}

const DeleteMailingListSubscription = `-- name: DeleteMailingListSubscription :exec
DELETE FROM mailing_list_subscriptions WHERE id = $1
`

func (q *Queries) DeleteMailingListSubscription(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteMailingListSubscription, id)
	return err
}

const DeleteMailingRecipient = `-- name: DeleteMailingRecipient :exec
DELETE FROM mailing_recipients WHERE id = $1
`

func (q *Queries) DeleteMailingRecipient(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteMailingRecipient, id)
	return err
}

const DeleteMessageTemplate = `-- name: DeleteMessageTemplate :exec
DELETE FROM message_templates WHERE id = $1
`

func (q *Queries) DeleteMessageTemplate(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteMessageTemplate, id)
	return err
}

const DeleteSmsMessage = `-- name: DeleteSmsMessage :exec
DELETE FROM sms_messages WHERE id = $1
`

func (q *Queries) DeleteSmsMessage(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteSmsMessage, id)
	return err
}

const GetCommunicationPreferences = `-- name: GetCommunicationPreferences :one
SELECT id, contact_id, email_opt_out, sms_opt_out, mail_opt_out, phone_opt_out, do_not_email, do_not_sms, do_not_mail, do_not_phone, do_not_trade, created_at, updated_at FROM communication_preferences WHERE contact_id = $1
`

func (q *Queries) GetCommunicationPreferences(ctx context.Context, contactID uuid.UUID) (CommunicationPreference, error) {
	row := q.db.QueryRowContext(ctx, GetCommunicationPreferences, contactID)
	var i CommunicationPreference
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.EmailOptOut,
		&i.SmsOptOut,
		&i.MailOptOut,
		&i.PhoneOptOut,
		&i.DoNotEmail,
		&i.DoNotSms,
		&i.DoNotMail,
		&i.DoNotPhone,
		&i.DoNotTrade,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetContactCommunicationHistory = `-- name: GetContactCommunicationHistory :many
SELECT 
    'Email' as type,
    m.name as campaign_name,
    mr.status,
    mr.sent_date,
    mr.opened_date,
    mr.clicked_date
FROM mailing_recipients mr
INNER JOIN mailings m ON mr.mailing_id = m.id
WHERE mr.contact_id = $1 AND mr.status IN ('Sent', 'Delivered', 'Opened', 'Clicked')
UNION ALL
SELECT 
    'SMS' as type,
    sm.message as campaign_name,
    sm.status,
    sm.sent_at as sent_date,
    NULL as opened_date,
    NULL as clicked_date
FROM sms_messages sm
WHERE sm.contact_id = $1
ORDER BY sent_date DESC
LIMIT $2
`

type GetContactCommunicationHistoryParams struct {
	ContactID uuid.UUID `json:"contact_id"`
	Limit     int32     `json:"limit"`
}

type GetContactCommunicationHistoryRow struct {
	Type         string         `json:"type"`
	CampaignName string         `json:"campaign_name"`
	Status       sql.NullString `json:"status"`
	SentDate     sql.NullTime   `json:"sent_date"`
	OpenedDate   sql.NullTime   `json:"opened_date"`
	ClickedDate  sql.NullTime   `json:"clicked_date"`
}

func (q *Queries) GetContactCommunicationHistory(ctx context.Context, arg GetContactCommunicationHistoryParams) ([]GetContactCommunicationHistoryRow, error) {
	rows, err := q.db.QueryContext(ctx, GetContactCommunicationHistory, arg.ContactID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetContactCommunicationHistoryRow{}
	for rows.Next() {
		var i GetContactCommunicationHistoryRow
		if err := rows.Scan(
			&i.Type,
			&i.CampaignName,
			&i.Status,
			&i.SentDate,
			&i.OpenedDate,
			&i.ClickedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetMailing = `-- name: GetMailing :one
SELECT id, name, subject, body_text, body_html, template_id, mailing_list_id, status, scheduled_date, start_date, end_date, total_recipients, total_sent, total_opened, total_clicked, total_bounced, total_unsubscribed, created_by, created_at, updated_at FROM mailings WHERE id = $1
`

func (q *Queries) GetMailing(ctx context.Context, id uuid.UUID) (Mailing, error) {
	row := q.db.QueryRowContext(ctx, GetMailing, id)
	var i Mailing
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Subject,
		&i.BodyText,
		&i.BodyHtml,
		&i.TemplateID,
		&i.MailingListID,
		&i.Status,
		&i.ScheduledDate,
		&i.StartDate,
		&i.EndDate,
		&i.TotalRecipients,
		&i.TotalSent,
		&i.TotalOpened,
		&i.TotalClicked,
		&i.TotalBounced,
		&i.TotalUnsubscribed,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetMailingList = `-- name: GetMailingList :one
SELECT id, name, title, description, is_public, is_hidden, is_active, created_at, updated_at FROM mailing_lists WHERE id = $1
`

func (q *Queries) GetMailingList(ctx context.Context, id uuid.UUID) (MailingList, error) {
	row := q.db.QueryRowContext(ctx, GetMailingList, id)
	var i MailingList
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Title,
		&i.Description,
		&i.IsPublic,
		&i.IsHidden,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetMailingListByName = `-- name: GetMailingListByName :one
SELECT id, name, title, description, is_public, is_hidden, is_active, created_at, updated_at FROM mailing_lists WHERE name = $1
`

func (q *Queries) GetMailingListByName(ctx context.Context, name string) (MailingList, error) {
	row := q.db.QueryRowContext(ctx, GetMailingListByName, name)
	var i MailingList
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Title,
		&i.Description,
		&i.IsPublic,
		&i.IsHidden,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetMailingListSubscription = `-- name: GetMailingListSubscription :one
SELECT id, mailing_list_id, contact_id, status, source, is_active, created_at, updated_at FROM mailing_list_subscriptions WHERE id = $1
`

func (q *Queries) GetMailingListSubscription(ctx context.Context, id uuid.UUID) (MailingListSubscription, error) {
	row := q.db.QueryRowContext(ctx, GetMailingListSubscription, id)
	var i MailingListSubscription
	err := row.Scan(
		&i.ID,
		&i.MailingListID,
		&i.ContactID,
		&i.Status,
		&i.Source,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetMailingPerformance = `-- name: GetMailingPerformance :many
SELECT 
    DATE(created_at) as date,
    COUNT(*) as sent,
    COUNT(CASE WHEN opened_date IS NOT NULL THEN 1 END) as opened,
    COUNT(CASE WHEN clicked_date IS NOT NULL THEN 1 END) as clicked
FROM mailing_recipients 
WHERE mailing_id = $1 AND status IN ('Sent', 'Delivered', 'Opened', 'Clicked')
GROUP BY DATE(created_at)
ORDER BY date
`

type GetMailingPerformanceRow struct {
	Date    time.Time `json:"date"`
	Sent    int64     `json:"sent"`
	Opened  int64     `json:"opened"`
	Clicked int64     `json:"clicked"`
}

func (q *Queries) GetMailingPerformance(ctx context.Context, mailingID uuid.UUID) ([]GetMailingPerformanceRow, error) {
	rows, err := q.db.QueryContext(ctx, GetMailingPerformance, mailingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMailingPerformanceRow{}
	for rows.Next() {
		var i GetMailingPerformanceRow
		if err := rows.Scan(
			&i.Date,
			&i.Sent,
			&i.Opened,
			&i.Clicked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetMailingRecipient = `-- name: GetMailingRecipient :one
SELECT id, mailing_id, contact_id, email, status, sent_date, delivered_date, opened_date, clicked_date, bounce_reason, created_at, updated_at FROM mailing_recipients WHERE id = $1
`

func (q *Queries) GetMailingRecipient(ctx context.Context, id uuid.UUID) (MailingRecipient, error) {
	row := q.db.QueryRowContext(ctx, GetMailingRecipient, id)
	var i MailingRecipient
	err := row.Scan(
		&i.ID,
		&i.MailingID,
		&i.ContactID,
		&i.Email,
		&i.Status,
		&i.SentDate,
		&i.DeliveredDate,
		&i.OpenedDate,
		&i.ClickedDate,
		&i.BounceReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetMailingStats = `-- name: GetMailingStats :one
SELECT 
    COUNT(*) as total_recipients,
    COUNT(CASE WHEN status = 'Sent' THEN 1 END) as total_sent,
    COUNT(CASE WHEN status = 'Delivered' THEN 1 END) as total_delivered,
    COUNT(CASE WHEN status = 'Opened' THEN 1 END) as total_opened,
    COUNT(CASE WHEN status = 'Clicked' THEN 1 END) as total_clicked,
    COUNT(CASE WHEN status = 'Bounced' THEN 1 END) as total_bounced,
    COUNT(CASE WHEN status = 'Unsubscribed' THEN 1 END) as total_unsubscribed
FROM mailing_recipients 
WHERE mailing_id = $1
`

type GetMailingStatsRow struct {
	TotalRecipients   int64 `json:"total_recipients"`
	TotalSent         int64 `json:"total_sent"`
	TotalDelivered    int64 `json:"total_delivered"`
	TotalOpened       int64 `json:"total_opened"`
	TotalClicked      int64 `json:"total_clicked"`
	TotalBounced      int64 `json:"total_bounced"`
	TotalUnsubscribed int64 `json:"total_unsubscribed"`
}

// Specialized queries for communication system
func (q *Queries) GetMailingStats(ctx context.Context, mailingID uuid.UUID) (GetMailingStatsRow, error) {
	row := q.db.QueryRowContext(ctx, GetMailingStats, mailingID)
	var i GetMailingStatsRow
	err := row.Scan(
		&i.TotalRecipients,
		&i.TotalSent,
		&i.TotalDelivered,
		&i.TotalOpened,
		&i.TotalClicked,
		&i.TotalBounced,
		&i.TotalUnsubscribed,
	)
	return i, err
}

const GetMessageTemplate = `-- name: GetMessageTemplate :one
SELECT id, name, title, subject, body_text, body_html, template_type, is_active, is_default, workflow_name, created_at, updated_at FROM message_templates WHERE id = $1
`

func (q *Queries) GetMessageTemplate(ctx context.Context, id uuid.UUID) (MessageTemplate, error) {
	row := q.db.QueryRowContext(ctx, GetMessageTemplate, id)
	var i MessageTemplate
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Title,
		&i.Subject,
		&i.BodyText,
		&i.BodyHtml,
		&i.TemplateType,
		&i.IsActive,
		&i.IsDefault,
		&i.WorkflowName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetMessageTemplateByName = `-- name: GetMessageTemplateByName :one
SELECT id, name, title, subject, body_text, body_html, template_type, is_active, is_default, workflow_name, created_at, updated_at FROM message_templates WHERE name = $1
`

func (q *Queries) GetMessageTemplateByName(ctx context.Context, name string) (MessageTemplate, error) {
	row := q.db.QueryRowContext(ctx, GetMessageTemplateByName, name)
	var i MessageTemplate
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Title,
		&i.Subject,
		&i.BodyText,
		&i.BodyHtml,
		&i.TemplateType,
		&i.IsActive,
		&i.IsDefault,
		&i.WorkflowName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetOptOutContacts = `-- name: GetOptOutContacts :many
SELECT 
    c.id, c.first_name, c.last_name, c.email,
    cp.email_opt_out, cp.sms_opt_out, cp.mail_opt_out, cp.phone_opt_out
FROM contacts c
INNER JOIN communication_preferences cp ON c.id = cp.contact_id
WHERE cp.email_opt_out = $1 OR cp.sms_opt_out = $2 OR cp.mail_opt_out = $3 OR cp.phone_opt_out = $4
ORDER BY c.last_name, c.first_name
LIMIT $5 OFFSET $6
`

type GetOptOutContactsParams struct {
	EmailOptOut sql.NullBool `json:"email_opt_out"`
	SmsOptOut   sql.NullBool `json:"sms_opt_out"`
	MailOptOut  sql.NullBool `json:"mail_opt_out"`
	PhoneOptOut sql.NullBool `json:"phone_opt_out"`
	Limit       int32        `json:"limit"`
	Offset      int32        `json:"offset"`
}

type GetOptOutContactsRow struct {
	ID          uuid.UUID      `json:"id"`
	FirstName   sql.NullString `json:"first_name"`
	LastName    sql.NullString `json:"last_name"`
	Email       sql.NullString `json:"email"`
	EmailOptOut sql.NullBool   `json:"email_opt_out"`
	SmsOptOut   sql.NullBool   `json:"sms_opt_out"`
	MailOptOut  sql.NullBool   `json:"mail_opt_out"`
	PhoneOptOut sql.NullBool   `json:"phone_opt_out"`
}

func (q *Queries) GetOptOutContacts(ctx context.Context, arg GetOptOutContactsParams) ([]GetOptOutContactsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetOptOutContacts,
		arg.EmailOptOut,
		arg.SmsOptOut,
		arg.MailOptOut,
		arg.PhoneOptOut,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOptOutContactsRow{}
	for rows.Next() {
		var i GetOptOutContactsRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.EmailOptOut,
			&i.SmsOptOut,
			&i.MailOptOut,
			&i.PhoneOptOut,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetRecipientByMailingAndContact = `-- name: GetRecipientByMailingAndContact :one
SELECT id, mailing_id, contact_id, email, status, sent_date, delivered_date, opened_date, clicked_date, bounce_reason, created_at, updated_at FROM mailing_recipients 
WHERE mailing_id = $1 AND contact_id = $2
`

type GetRecipientByMailingAndContactParams struct {
	MailingID uuid.UUID `json:"mailing_id"`
	ContactID uuid.UUID `json:"contact_id"`
}

func (q *Queries) GetRecipientByMailingAndContact(ctx context.Context, arg GetRecipientByMailingAndContactParams) (MailingRecipient, error) {
	row := q.db.QueryRowContext(ctx, GetRecipientByMailingAndContact, arg.MailingID, arg.ContactID)
	var i MailingRecipient
	err := row.Scan(
		&i.ID,
		&i.MailingID,
		&i.ContactID,
		&i.Email,
		&i.Status,
		&i.SentDate,
		&i.DeliveredDate,
		&i.OpenedDate,
		&i.ClickedDate,
		&i.BounceReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetSmsMessage = `-- name: GetSmsMessage :one
SELECT id, contact_id, phone_number, message, direction, status, provider, provider_message_id, sent_at, delivered_at, created_at, updated_at FROM sms_messages WHERE id = $1
`

func (q *Queries) GetSmsMessage(ctx context.Context, id uuid.UUID) (SmsMessage, error) {
	row := q.db.QueryRowContext(ctx, GetSmsMessage, id)
	var i SmsMessage
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.PhoneNumber,
		&i.Message,
		&i.Direction,
		&i.Status,
		&i.Provider,
		&i.ProviderMessageID,
		&i.SentAt,
		&i.DeliveredAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetSubscriptionByContactAndList = `-- name: GetSubscriptionByContactAndList :one
SELECT id, mailing_list_id, contact_id, status, source, is_active, created_at, updated_at FROM mailing_list_subscriptions 
WHERE mailing_list_id = $1 AND contact_id = $2
`

type GetSubscriptionByContactAndListParams struct {
	MailingListID uuid.UUID `json:"mailing_list_id"`
	ContactID     uuid.UUID `json:"contact_id"`
}

func (q *Queries) GetSubscriptionByContactAndList(ctx context.Context, arg GetSubscriptionByContactAndListParams) (MailingListSubscription, error) {
	row := q.db.QueryRowContext(ctx, GetSubscriptionByContactAndList, arg.MailingListID, arg.ContactID)
	var i MailingListSubscription
	err := row.Scan(
		&i.ID,
		&i.MailingListID,
		&i.ContactID,
		&i.Status,
		&i.Source,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetTopClickedUrls = `-- name: GetTopClickedUrls :many
SELECT 
    mtu.original_url,
    mtu.click_count,
    mtu.unique_clicks
FROM mailing_trackable_urls mtu
WHERE mtu.mailing_id = $1
ORDER BY mtu.click_count DESC
LIMIT $2
`

type GetTopClickedUrlsParams struct {
	MailingID uuid.UUID `json:"mailing_id"`
	Limit     int32     `json:"limit"`
}

type GetTopClickedUrlsRow struct {
	OriginalUrl  string        `json:"original_url"`
	ClickCount   sql.NullInt32 `json:"click_count"`
	UniqueClicks sql.NullInt32 `json:"unique_clicks"`
}

func (q *Queries) GetTopClickedUrls(ctx context.Context, arg GetTopClickedUrlsParams) ([]GetTopClickedUrlsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetTopClickedUrls, arg.MailingID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopClickedUrlsRow{}
	for rows.Next() {
		var i GetTopClickedUrlsRow
		if err := rows.Scan(&i.OriginalUrl, &i.ClickCount, &i.UniqueClicks); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetTrackableUrl = `-- name: GetTrackableUrl :one
SELECT id, mailing_id, url, original_url, click_count, unique_clicks, created_at FROM mailing_trackable_urls WHERE id = $1
`

func (q *Queries) GetTrackableUrl(ctx context.Context, id uuid.UUID) (MailingTrackableUrl, error) {
	row := q.db.QueryRowContext(ctx, GetTrackableUrl, id)
	var i MailingTrackableUrl
	err := row.Scan(
		&i.ID,
		&i.MailingID,
		&i.Url,
		&i.OriginalUrl,
		&i.ClickCount,
		&i.UniqueClicks,
		&i.CreatedAt,
	)
	return i, err
}

const ListMailingLists = `-- name: ListMailingLists :many
SELECT id, name, title, description, is_public, is_hidden, is_active, created_at, updated_at FROM mailing_lists 
WHERE is_active = $1 AND is_hidden = $2
ORDER BY title
`

type ListMailingListsParams struct {
	IsActive sql.NullBool `json:"is_active"`
	IsHidden sql.NullBool `json:"is_hidden"`
}

func (q *Queries) ListMailingLists(ctx context.Context, arg ListMailingListsParams) ([]MailingList, error) {
	rows, err := q.db.QueryContext(ctx, ListMailingLists, arg.IsActive, arg.IsHidden)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MailingList{}
	for rows.Next() {
		var i MailingList
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Title,
			&i.Description,
			&i.IsPublic,
			&i.IsHidden,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListMailings = `-- name: ListMailings :many
SELECT id, name, subject, body_text, body_html, template_id, mailing_list_id, status, scheduled_date, start_date, end_date, total_recipients, total_sent, total_opened, total_clicked, total_bounced, total_unsubscribed, created_by, created_at, updated_at FROM mailings 
WHERE status = $1
ORDER BY created_at DESC
`

func (q *Queries) ListMailings(ctx context.Context, status sql.NullString) ([]Mailing, error) {
	rows, err := q.db.QueryContext(ctx, ListMailings, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Mailing{}
	for rows.Next() {
		var i Mailing
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Subject,
			&i.BodyText,
			&i.BodyHtml,
			&i.TemplateID,
			&i.MailingListID,
			&i.Status,
			&i.ScheduledDate,
			&i.StartDate,
			&i.EndDate,
			&i.TotalRecipients,
			&i.TotalSent,
			&i.TotalOpened,
			&i.TotalClicked,
			&i.TotalBounced,
			&i.TotalUnsubscribed,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListMailingsByCreator = `-- name: ListMailingsByCreator :many
SELECT id, name, subject, body_text, body_html, template_id, mailing_list_id, status, scheduled_date, start_date, end_date, total_recipients, total_sent, total_opened, total_clicked, total_bounced, total_unsubscribed, created_by, created_at, updated_at FROM mailings 
WHERE created_by = $1
ORDER BY created_at DESC
`

func (q *Queries) ListMailingsByCreator(ctx context.Context, createdBy uuid.NullUUID) ([]Mailing, error) {
	rows, err := q.db.QueryContext(ctx, ListMailingsByCreator, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Mailing{}
	for rows.Next() {
		var i Mailing
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Subject,
			&i.BodyText,
			&i.BodyHtml,
			&i.TemplateID,
			&i.MailingListID,
			&i.Status,
			&i.ScheduledDate,
			&i.StartDate,
			&i.EndDate,
			&i.TotalRecipients,
			&i.TotalSent,
			&i.TotalOpened,
			&i.TotalClicked,
			&i.TotalBounced,
			&i.TotalUnsubscribed,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListMessageTemplates = `-- name: ListMessageTemplates :many
SELECT id, name, title, subject, body_text, body_html, template_type, is_active, is_default, workflow_name, created_at, updated_at FROM message_templates 
WHERE template_type = $1 AND is_active = $2
ORDER BY title
`

type ListMessageTemplatesParams struct {
	TemplateType string       `json:"template_type"`
	IsActive     sql.NullBool `json:"is_active"`
}

func (q *Queries) ListMessageTemplates(ctx context.Context, arg ListMessageTemplatesParams) ([]MessageTemplate, error) {
	rows, err := q.db.QueryContext(ctx, ListMessageTemplates, arg.TemplateType, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MessageTemplate{}
	for rows.Next() {
		var i MessageTemplate
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Title,
			&i.Subject,
			&i.BodyText,
			&i.BodyHtml,
			&i.TemplateType,
			&i.IsActive,
			&i.IsDefault,
			&i.WorkflowName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListMessageTemplatesByWorkflow = `-- name: ListMessageTemplatesByWorkflow :many
SELECT id, name, title, subject, body_text, body_html, template_type, is_active, is_default, workflow_name, created_at, updated_at FROM message_templates 
WHERE workflow_name = $1 AND is_active = $2
ORDER BY title
`

type ListMessageTemplatesByWorkflowParams struct {
	WorkflowName sql.NullString `json:"workflow_name"`
	IsActive     sql.NullBool   `json:"is_active"`
}

func (q *Queries) ListMessageTemplatesByWorkflow(ctx context.Context, arg ListMessageTemplatesByWorkflowParams) ([]MessageTemplate, error) {
	rows, err := q.db.QueryContext(ctx, ListMessageTemplatesByWorkflow, arg.WorkflowName, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MessageTemplate{}
	for rows.Next() {
		var i MessageTemplate
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Title,
			&i.Subject,
			&i.BodyText,
			&i.BodyHtml,
			&i.TemplateType,
			&i.IsActive,
			&i.IsDefault,
			&i.WorkflowName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListRecipientsByMailing = `-- name: ListRecipientsByMailing :many
SELECT mr.id, mr.mailing_id, mr.contact_id, mr.email, mr.status, mr.sent_date, mr.delivered_date, mr.opened_date, mr.clicked_date, mr.bounce_reason, mr.created_at, mr.updated_at, c.first_name, c.last_name, c.email as contact_email
FROM mailing_recipients mr
INNER JOIN contacts c ON mr.contact_id = c.id
WHERE mr.mailing_id = $1
ORDER BY c.last_name, c.first_name
`

type ListRecipientsByMailingRow struct {
	ID            uuid.UUID      `json:"id"`
	MailingID     uuid.UUID      `json:"mailing_id"`
	ContactID     uuid.UUID      `json:"contact_id"`
	Email         string         `json:"email"`
	Status        sql.NullString `json:"status"`
	SentDate      sql.NullTime   `json:"sent_date"`
	DeliveredDate sql.NullTime   `json:"delivered_date"`
	OpenedDate    sql.NullTime   `json:"opened_date"`
	ClickedDate   sql.NullTime   `json:"clicked_date"`
	BounceReason  sql.NullString `json:"bounce_reason"`
	CreatedAt     sql.NullTime   `json:"created_at"`
	UpdatedAt     sql.NullTime   `json:"updated_at"`
	FirstName     sql.NullString `json:"first_name"`
	LastName      sql.NullString `json:"last_name"`
	ContactEmail  sql.NullString `json:"contact_email"`
}

func (q *Queries) ListRecipientsByMailing(ctx context.Context, mailingID uuid.UUID) ([]ListRecipientsByMailingRow, error) {
	rows, err := q.db.QueryContext(ctx, ListRecipientsByMailing, mailingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRecipientsByMailingRow{}
	for rows.Next() {
		var i ListRecipientsByMailingRow
		if err := rows.Scan(
			&i.ID,
			&i.MailingID,
			&i.ContactID,
			&i.Email,
			&i.Status,
			&i.SentDate,
			&i.DeliveredDate,
			&i.OpenedDate,
			&i.ClickedDate,
			&i.BounceReason,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstName,
			&i.LastName,
			&i.ContactEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListSmsMessagesByContact = `-- name: ListSmsMessagesByContact :many
SELECT id, contact_id, phone_number, message, direction, status, provider, provider_message_id, sent_at, delivered_at, created_at, updated_at FROM sms_messages 
WHERE contact_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListSmsMessagesByContact(ctx context.Context, contactID uuid.UUID) ([]SmsMessage, error) {
	rows, err := q.db.QueryContext(ctx, ListSmsMessagesByContact, contactID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SmsMessage{}
	for rows.Next() {
		var i SmsMessage
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.PhoneNumber,
			&i.Message,
			&i.Direction,
			&i.Status,
			&i.Provider,
			&i.ProviderMessageID,
			&i.SentAt,
			&i.DeliveredAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListSubscriptionsByContact = `-- name: ListSubscriptionsByContact :many
SELECT mls.id, mls.mailing_list_id, mls.contact_id, mls.status, mls.source, mls.is_active, mls.created_at, mls.updated_at, ml.name as list_name, ml.title as list_title
FROM mailing_list_subscriptions mls
INNER JOIN mailing_lists ml ON mls.mailing_list_id = ml.id
WHERE mls.contact_id = $1 AND mls.is_active = $2
ORDER BY ml.title
`

type ListSubscriptionsByContactParams struct {
	ContactID uuid.UUID    `json:"contact_id"`
	IsActive  sql.NullBool `json:"is_active"`
}

type ListSubscriptionsByContactRow struct {
	ID            uuid.UUID      `json:"id"`
	MailingListID uuid.UUID      `json:"mailing_list_id"`
	ContactID     uuid.UUID      `json:"contact_id"`
	Status        sql.NullString `json:"status"`
	Source        sql.NullString `json:"source"`
	IsActive      sql.NullBool   `json:"is_active"`
	CreatedAt     sql.NullTime   `json:"created_at"`
	UpdatedAt     sql.NullTime   `json:"updated_at"`
	ListName      string         `json:"list_name"`
	ListTitle     string         `json:"list_title"`
}

func (q *Queries) ListSubscriptionsByContact(ctx context.Context, arg ListSubscriptionsByContactParams) ([]ListSubscriptionsByContactRow, error) {
	rows, err := q.db.QueryContext(ctx, ListSubscriptionsByContact, arg.ContactID, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSubscriptionsByContactRow{}
	for rows.Next() {
		var i ListSubscriptionsByContactRow
		if err := rows.Scan(
			&i.ID,
			&i.MailingListID,
			&i.ContactID,
			&i.Status,
			&i.Source,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ListName,
			&i.ListTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListSubscriptionsByList = `-- name: ListSubscriptionsByList :many
SELECT mls.id, mls.mailing_list_id, mls.contact_id, mls.status, mls.source, mls.is_active, mls.created_at, mls.updated_at, c.first_name, c.last_name, c.email
FROM mailing_list_subscriptions mls
INNER JOIN contacts c ON mls.contact_id = c.id
WHERE mls.mailing_list_id = $1 AND mls.is_active = $2
ORDER BY c.last_name, c.first_name
`

type ListSubscriptionsByListParams struct {
	MailingListID uuid.UUID    `json:"mailing_list_id"`
	IsActive      sql.NullBool `json:"is_active"`
}

type ListSubscriptionsByListRow struct {
	ID            uuid.UUID      `json:"id"`
	MailingListID uuid.UUID      `json:"mailing_list_id"`
	ContactID     uuid.UUID      `json:"contact_id"`
	Status        sql.NullString `json:"status"`
	Source        sql.NullString `json:"source"`
	IsActive      sql.NullBool   `json:"is_active"`
	CreatedAt     sql.NullTime   `json:"created_at"`
	UpdatedAt     sql.NullTime   `json:"updated_at"`
	FirstName     sql.NullString `json:"first_name"`
	LastName      sql.NullString `json:"last_name"`
	Email         sql.NullString `json:"email"`
}

func (q *Queries) ListSubscriptionsByList(ctx context.Context, arg ListSubscriptionsByListParams) ([]ListSubscriptionsByListRow, error) {
	rows, err := q.db.QueryContext(ctx, ListSubscriptionsByList, arg.MailingListID, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSubscriptionsByListRow{}
	for rows.Next() {
		var i ListSubscriptionsByListRow
		if err := rows.Scan(
			&i.ID,
			&i.MailingListID,
			&i.ContactID,
			&i.Status,
			&i.Source,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListTrackableUrlsByMailing = `-- name: ListTrackableUrlsByMailing :many
SELECT id, mailing_id, url, original_url, click_count, unique_clicks, created_at FROM mailing_trackable_urls 
WHERE mailing_id = $1
ORDER BY created_at
`

func (q *Queries) ListTrackableUrlsByMailing(ctx context.Context, mailingID uuid.UUID) ([]MailingTrackableUrl, error) {
	rows, err := q.db.QueryContext(ctx, ListTrackableUrlsByMailing, mailingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MailingTrackableUrl{}
	for rows.Next() {
		var i MailingTrackableUrl
		if err := rows.Scan(
			&i.ID,
			&i.MailingID,
			&i.Url,
			&i.OriginalUrl,
			&i.ClickCount,
			&i.UniqueClicks,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateCommunicationPreferences = `-- name: UpdateCommunicationPreferences :one
UPDATE communication_preferences SET
    email_opt_out = $2,
    sms_opt_out = $3,
    mail_opt_out = $4,
    phone_opt_out = $5,
    do_not_email = $6,
    do_not_sms = $7,
    do_not_mail = $8,
    do_not_phone = $9,
    do_not_trade = $10,
    updated_at = NOW()
WHERE contact_id = $1 RETURNING id, contact_id, email_opt_out, sms_opt_out, mail_opt_out, phone_opt_out, do_not_email, do_not_sms, do_not_mail, do_not_phone, do_not_trade, created_at, updated_at
`

type UpdateCommunicationPreferencesParams struct {
	ContactID   uuid.UUID    `json:"contact_id"`
	EmailOptOut sql.NullBool `json:"email_opt_out"`
	SmsOptOut   sql.NullBool `json:"sms_opt_out"`
	MailOptOut  sql.NullBool `json:"mail_opt_out"`
	PhoneOptOut sql.NullBool `json:"phone_opt_out"`
	DoNotEmail  sql.NullBool `json:"do_not_email"`
	DoNotSms    sql.NullBool `json:"do_not_sms"`
	DoNotMail   sql.NullBool `json:"do_not_mail"`
	DoNotPhone  sql.NullBool `json:"do_not_phone"`
	DoNotTrade  sql.NullBool `json:"do_not_trade"`
}

func (q *Queries) UpdateCommunicationPreferences(ctx context.Context, arg UpdateCommunicationPreferencesParams) (CommunicationPreference, error) {
	row := q.db.QueryRowContext(ctx, UpdateCommunicationPreferences,
		arg.ContactID,
		arg.EmailOptOut,
		arg.SmsOptOut,
		arg.MailOptOut,
		arg.PhoneOptOut,
		arg.DoNotEmail,
		arg.DoNotSms,
		arg.DoNotMail,
		arg.DoNotPhone,
		arg.DoNotTrade,
	)
	var i CommunicationPreference
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.EmailOptOut,
		&i.SmsOptOut,
		&i.MailOptOut,
		&i.PhoneOptOut,
		&i.DoNotEmail,
		&i.DoNotSms,
		&i.DoNotMail,
		&i.DoNotPhone,
		&i.DoNotTrade,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateMailingList = `-- name: UpdateMailingList :one
UPDATE mailing_lists SET
    title = $2,
    description = $3,
    is_public = $4,
    is_hidden = $5,
    is_active = $6,
    updated_at = NOW()
WHERE id = $1 RETURNING id, name, title, description, is_public, is_hidden, is_active, created_at, updated_at
`

type UpdateMailingListParams struct {
	ID          uuid.UUID      `json:"id"`
	Title       string         `json:"title"`
	Description sql.NullString `json:"description"`
	IsPublic    sql.NullBool   `json:"is_public"`
	IsHidden    sql.NullBool   `json:"is_hidden"`
	IsActive    sql.NullBool   `json:"is_active"`
}

func (q *Queries) UpdateMailingList(ctx context.Context, arg UpdateMailingListParams) (MailingList, error) {
	row := q.db.QueryRowContext(ctx, UpdateMailingList,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.IsPublic,
		arg.IsHidden,
		arg.IsActive,
	)
	var i MailingList
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Title,
		&i.Description,
		&i.IsPublic,
		&i.IsHidden,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateMailingStats = `-- name: UpdateMailingStats :one
UPDATE mailings SET
    total_sent = $2,
    total_opened = $3,
    total_clicked = $4,
    total_bounced = $5,
    total_unsubscribed = $6,
    updated_at = NOW()
WHERE id = $1 RETURNING id, name, subject, body_text, body_html, template_id, mailing_list_id, status, scheduled_date, start_date, end_date, total_recipients, total_sent, total_opened, total_clicked, total_bounced, total_unsubscribed, created_by, created_at, updated_at
`

type UpdateMailingStatsParams struct {
	ID                uuid.UUID     `json:"id"`
	TotalSent         sql.NullInt32 `json:"total_sent"`
	TotalOpened       sql.NullInt32 `json:"total_opened"`
	TotalClicked      sql.NullInt32 `json:"total_clicked"`
	TotalBounced      sql.NullInt32 `json:"total_bounced"`
	TotalUnsubscribed sql.NullInt32 `json:"total_unsubscribed"`
}

func (q *Queries) UpdateMailingStats(ctx context.Context, arg UpdateMailingStatsParams) (Mailing, error) {
	row := q.db.QueryRowContext(ctx, UpdateMailingStats,
		arg.ID,
		arg.TotalSent,
		arg.TotalOpened,
		arg.TotalClicked,
		arg.TotalBounced,
		arg.TotalUnsubscribed,
	)
	var i Mailing
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Subject,
		&i.BodyText,
		&i.BodyHtml,
		&i.TemplateID,
		&i.MailingListID,
		&i.Status,
		&i.ScheduledDate,
		&i.StartDate,
		&i.EndDate,
		&i.TotalRecipients,
		&i.TotalSent,
		&i.TotalOpened,
		&i.TotalClicked,
		&i.TotalBounced,
		&i.TotalUnsubscribed,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateMailingStatus = `-- name: UpdateMailingStatus :one
UPDATE mailings SET
    status = $2,
    start_date = $3,
    end_date = $4,
    updated_at = NOW()
WHERE id = $1 RETURNING id, name, subject, body_text, body_html, template_id, mailing_list_id, status, scheduled_date, start_date, end_date, total_recipients, total_sent, total_opened, total_clicked, total_bounced, total_unsubscribed, created_by, created_at, updated_at
`

type UpdateMailingStatusParams struct {
	ID        uuid.UUID      `json:"id"`
	Status    sql.NullString `json:"status"`
	StartDate sql.NullTime   `json:"start_date"`
	EndDate   sql.NullTime   `json:"end_date"`
}

func (q *Queries) UpdateMailingStatus(ctx context.Context, arg UpdateMailingStatusParams) (Mailing, error) {
	row := q.db.QueryRowContext(ctx, UpdateMailingStatus,
		arg.ID,
		arg.Status,
		arg.StartDate,
		arg.EndDate,
	)
	var i Mailing
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Subject,
		&i.BodyText,
		&i.BodyHtml,
		&i.TemplateID,
		&i.MailingListID,
		&i.Status,
		&i.ScheduledDate,
		&i.StartDate,
		&i.EndDate,
		&i.TotalRecipients,
		&i.TotalSent,
		&i.TotalOpened,
		&i.TotalClicked,
		&i.TotalBounced,
		&i.TotalUnsubscribed,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateMessageTemplate = `-- name: UpdateMessageTemplate :one
UPDATE message_templates SET
    title = $2,
    subject = $3,
    body_text = $4,
    body_html = $5,
    template_type = $6,
    is_active = $7,
    is_default = $8,
    workflow_name = $9,
    updated_at = NOW()
WHERE id = $1 RETURNING id, name, title, subject, body_text, body_html, template_type, is_active, is_default, workflow_name, created_at, updated_at
`

type UpdateMessageTemplateParams struct {
	ID           uuid.UUID      `json:"id"`
	Title        string         `json:"title"`
	Subject      sql.NullString `json:"subject"`
	BodyText     sql.NullString `json:"body_text"`
	BodyHtml     sql.NullString `json:"body_html"`
	TemplateType string         `json:"template_type"`
	IsActive     sql.NullBool   `json:"is_active"`
	IsDefault    sql.NullBool   `json:"is_default"`
	WorkflowName sql.NullString `json:"workflow_name"`
}

func (q *Queries) UpdateMessageTemplate(ctx context.Context, arg UpdateMessageTemplateParams) (MessageTemplate, error) {
	row := q.db.QueryRowContext(ctx, UpdateMessageTemplate,
		arg.ID,
		arg.Title,
		arg.Subject,
		arg.BodyText,
		arg.BodyHtml,
		arg.TemplateType,
		arg.IsActive,
		arg.IsDefault,
		arg.WorkflowName,
	)
	var i MessageTemplate
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Title,
		&i.Subject,
		&i.BodyText,
		&i.BodyHtml,
		&i.TemplateType,
		&i.IsActive,
		&i.IsDefault,
		&i.WorkflowName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateRecipientStatus = `-- name: UpdateRecipientStatus :one
UPDATE mailing_recipients SET
    status = $3,
    sent_date = $4,
    delivered_date = $5,
    opened_date = $6,
    clicked_date = $7,
    bounce_reason = $8,
    updated_at = NOW()
WHERE mailing_id = $1 AND contact_id = $2 RETURNING id, mailing_id, contact_id, email, status, sent_date, delivered_date, opened_date, clicked_date, bounce_reason, created_at, updated_at
`

type UpdateRecipientStatusParams struct {
	MailingID     uuid.UUID      `json:"mailing_id"`
	ContactID     uuid.UUID      `json:"contact_id"`
	Status        sql.NullString `json:"status"`
	SentDate      sql.NullTime   `json:"sent_date"`
	DeliveredDate sql.NullTime   `json:"delivered_date"`
	OpenedDate    sql.NullTime   `json:"opened_date"`
	ClickedDate   sql.NullTime   `json:"clicked_date"`
	BounceReason  sql.NullString `json:"bounce_reason"`
}

func (q *Queries) UpdateRecipientStatus(ctx context.Context, arg UpdateRecipientStatusParams) (MailingRecipient, error) {
	row := q.db.QueryRowContext(ctx, UpdateRecipientStatus,
		arg.MailingID,
		arg.ContactID,
		arg.Status,
		arg.SentDate,
		arg.DeliveredDate,
		arg.OpenedDate,
		arg.ClickedDate,
		arg.BounceReason,
	)
	var i MailingRecipient
	err := row.Scan(
		&i.ID,
		&i.MailingID,
		&i.ContactID,
		&i.Email,
		&i.Status,
		&i.SentDate,
		&i.DeliveredDate,
		&i.OpenedDate,
		&i.ClickedDate,
		&i.BounceReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateSmsStatus = `-- name: UpdateSmsStatus :one
UPDATE sms_messages SET
    status = $2,
    sent_at = $3,
    delivered_at = $4,
    updated_at = NOW()
WHERE id = $1 RETURNING id, contact_id, phone_number, message, direction, status, provider, provider_message_id, sent_at, delivered_at, created_at, updated_at
`

type UpdateSmsStatusParams struct {
	ID          uuid.UUID      `json:"id"`
	Status      sql.NullString `json:"status"`
	SentAt      sql.NullTime   `json:"sent_at"`
	DeliveredAt sql.NullTime   `json:"delivered_at"`
}

func (q *Queries) UpdateSmsStatus(ctx context.Context, arg UpdateSmsStatusParams) (SmsMessage, error) {
	row := q.db.QueryRowContext(ctx, UpdateSmsStatus,
		arg.ID,
		arg.Status,
		arg.SentAt,
		arg.DeliveredAt,
	)
	var i SmsMessage
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.PhoneNumber,
		&i.Message,
		&i.Direction,
		&i.Status,
		&i.Provider,
		&i.ProviderMessageID,
		&i.SentAt,
		&i.DeliveredAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateSubscriptionStatus = `-- name: UpdateSubscriptionStatus :one
UPDATE mailing_list_subscriptions SET
    status = $3,
    updated_at = NOW()
WHERE mailing_list_id = $1 AND contact_id = $2 RETURNING id, mailing_list_id, contact_id, status, source, is_active, created_at, updated_at
`

type UpdateSubscriptionStatusParams struct {
	MailingListID uuid.UUID      `json:"mailing_list_id"`
	ContactID     uuid.UUID      `json:"contact_id"`
	Status        sql.NullString `json:"status"`
}

func (q *Queries) UpdateSubscriptionStatus(ctx context.Context, arg UpdateSubscriptionStatusParams) (MailingListSubscription, error) {
	row := q.db.QueryRowContext(ctx, UpdateSubscriptionStatus, arg.MailingListID, arg.ContactID, arg.Status)
	var i MailingListSubscription
	err := row.Scan(
		&i.ID,
		&i.MailingListID,
		&i.ContactID,
		&i.Status,
		&i.Source,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateUrlClickCount = `-- name: UpdateUrlClickCount :one
UPDATE mailing_trackable_urls SET
    click_count = $2,
    unique_clicks = $3
WHERE id = $1 RETURNING id, mailing_id, url, original_url, click_count, unique_clicks, created_at
`

type UpdateUrlClickCountParams struct {
	ID           uuid.UUID     `json:"id"`
	ClickCount   sql.NullInt32 `json:"click_count"`
	UniqueClicks sql.NullInt32 `json:"unique_clicks"`
}

func (q *Queries) UpdateUrlClickCount(ctx context.Context, arg UpdateUrlClickCountParams) (MailingTrackableUrl, error) {
	row := q.db.QueryRowContext(ctx, UpdateUrlClickCount, arg.ID, arg.ClickCount, arg.UniqueClicks)
	var i MailingTrackableUrl
	err := row.Scan(
		&i.ID,
		&i.MailingID,
		&i.Url,
		&i.OriginalUrl,
		&i.ClickCount,
		&i.UniqueClicks,
		&i.CreatedAt,
	)
	return i, err
}
