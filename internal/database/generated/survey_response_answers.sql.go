// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: survey_response_answers.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const CreateSurveyResponseAnswer = `-- name: CreateSurveyResponseAnswer :one
INSERT INTO survey_response_answers (
    survey_response_id, survey_question_id, answer_text, answer_numeric, answer_date, answer_boolean
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, survey_response_id, survey_question_id, answer_text, answer_numeric, answer_date, answer_boolean, created_at, updated_at
`

type CreateSurveyResponseAnswerParams struct {
	SurveyResponseID uuid.UUID      `json:"survey_response_id"`
	SurveyQuestionID uuid.UUID      `json:"survey_question_id"`
	AnswerText       sql.NullString `json:"answer_text"`
	AnswerNumeric    sql.NullString `json:"answer_numeric"`
	AnswerDate       sql.NullTime   `json:"answer_date"`
	AnswerBoolean    sql.NullBool   `json:"answer_boolean"`
}

func (q *Queries) CreateSurveyResponseAnswer(ctx context.Context, arg CreateSurveyResponseAnswerParams) (SurveyResponseAnswer, error) {
	row := q.db.QueryRowContext(ctx, CreateSurveyResponseAnswer,
		arg.SurveyResponseID,
		arg.SurveyQuestionID,
		arg.AnswerText,
		arg.AnswerNumeric,
		arg.AnswerDate,
		arg.AnswerBoolean,
	)
	var i SurveyResponseAnswer
	err := row.Scan(
		&i.ID,
		&i.SurveyResponseID,
		&i.SurveyQuestionID,
		&i.AnswerText,
		&i.AnswerNumeric,
		&i.AnswerDate,
		&i.AnswerBoolean,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const DeleteSurveyResponseAnswer = `-- name: DeleteSurveyResponseAnswer :exec
DELETE FROM survey_response_answers WHERE id = $1
`

func (q *Queries) DeleteSurveyResponseAnswer(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteSurveyResponseAnswer, id)
	return err
}

const DeleteSurveyResponseAnswersByResponse = `-- name: DeleteSurveyResponseAnswersByResponse :exec
DELETE FROM survey_response_answers WHERE survey_response_id = $1
`

func (q *Queries) DeleteSurveyResponseAnswersByResponse(ctx context.Context, surveyResponseID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteSurveyResponseAnswersByResponse, surveyResponseID)
	return err
}

const GetSurveyAnalytics = `-- name: GetSurveyAnalytics :many
SELECT 
    sq.question_text,
    sq.question_type,
    sq.question_options,
    COUNT(sra.id) as response_count,
    STRING_AGG(DISTINCT sra.answer_text, '; ') as text_answers,
    AVG(sra.answer_numeric) as avg_numeric,
    MIN(sra.answer_numeric) as min_numeric,
    MAX(sra.answer_numeric) as max_numeric
FROM survey_questions sq
LEFT JOIN survey_response_answers sra ON sq.id = sra.survey_question_id
LEFT JOIN survey_responses sr ON sra.survey_response_id = sr.id
WHERE sq.survey_id = $1 AND sq.is_active = TRUE AND sr.status = 'Completed'
GROUP BY sq.id, sq.question_text, sq.question_type, sq.question_options, sq.weight
ORDER BY sq.weight, sq.id
`

type GetSurveyAnalyticsRow struct {
	QuestionText    string         `json:"question_text"`
	QuestionType    string         `json:"question_type"`
	QuestionOptions sql.NullString `json:"question_options"`
	ResponseCount   int64          `json:"response_count"`
	TextAnswers     []byte         `json:"text_answers"`
	AvgNumeric      float64        `json:"avg_numeric"`
	MinNumeric      interface{}    `json:"min_numeric"`
	MaxNumeric      interface{}    `json:"max_numeric"`
}

func (q *Queries) GetSurveyAnalytics(ctx context.Context, surveyID uuid.UUID) ([]GetSurveyAnalyticsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetSurveyAnalytics, surveyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSurveyAnalyticsRow{}
	for rows.Next() {
		var i GetSurveyAnalyticsRow
		if err := rows.Scan(
			&i.QuestionText,
			&i.QuestionType,
			&i.QuestionOptions,
			&i.ResponseCount,
			&i.TextAnswers,
			&i.AvgNumeric,
			&i.MinNumeric,
			&i.MaxNumeric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSurveyResponseAnswer = `-- name: GetSurveyResponseAnswer :one
SELECT id, survey_response_id, survey_question_id, answer_text, answer_numeric, answer_date, answer_boolean, created_at, updated_at FROM survey_response_answers WHERE id = $1
`

func (q *Queries) GetSurveyResponseAnswer(ctx context.Context, id uuid.UUID) (SurveyResponseAnswer, error) {
	row := q.db.QueryRowContext(ctx, GetSurveyResponseAnswer, id)
	var i SurveyResponseAnswer
	err := row.Scan(
		&i.ID,
		&i.SurveyResponseID,
		&i.SurveyQuestionID,
		&i.AnswerText,
		&i.AnswerNumeric,
		&i.AnswerDate,
		&i.AnswerBoolean,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetSurveyResponseAnswerCount = `-- name: GetSurveyResponseAnswerCount :one
SELECT COUNT(*) FROM survey_response_answers WHERE survey_response_id = $1
`

func (q *Queries) GetSurveyResponseAnswerCount(ctx context.Context, surveyResponseID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, GetSurveyResponseAnswerCount, surveyResponseID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const GetSurveyResponseAnswerStats = `-- name: GetSurveyResponseAnswerStats :many
SELECT 
    sq.question_type,
    COUNT(sra.id) as answer_count
FROM survey_response_answers sra
JOIN survey_questions sq ON sra.survey_question_id = sq.id
WHERE sra.survey_response_id = $1
GROUP BY sq.question_type
ORDER BY sq.question_type
`

type GetSurveyResponseAnswerStatsRow struct {
	QuestionType string `json:"question_type"`
	AnswerCount  int64  `json:"answer_count"`
}

func (q *Queries) GetSurveyResponseAnswerStats(ctx context.Context, surveyResponseID uuid.UUID) ([]GetSurveyResponseAnswerStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetSurveyResponseAnswerStats, surveyResponseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSurveyResponseAnswerStatsRow{}
	for rows.Next() {
		var i GetSurveyResponseAnswerStatsRow
		if err := rows.Scan(&i.QuestionType, &i.AnswerCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSurveyResponseAnswersByQuestion = `-- name: GetSurveyResponseAnswersByQuestion :many
SELECT id, survey_response_id, survey_question_id, answer_text, answer_numeric, answer_date, answer_boolean, created_at, updated_at FROM survey_response_answers 
WHERE survey_question_id = $1 
ORDER BY id
`

func (q *Queries) GetSurveyResponseAnswersByQuestion(ctx context.Context, surveyQuestionID uuid.UUID) ([]SurveyResponseAnswer, error) {
	rows, err := q.db.QueryContext(ctx, GetSurveyResponseAnswersByQuestion, surveyQuestionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SurveyResponseAnswer{}
	for rows.Next() {
		var i SurveyResponseAnswer
		if err := rows.Scan(
			&i.ID,
			&i.SurveyResponseID,
			&i.SurveyQuestionID,
			&i.AnswerText,
			&i.AnswerNumeric,
			&i.AnswerDate,
			&i.AnswerBoolean,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSurveyResponseAnswersByResponse = `-- name: GetSurveyResponseAnswersByResponse :many
SELECT id, survey_response_id, survey_question_id, answer_text, answer_numeric, answer_date, answer_boolean, created_at, updated_at FROM survey_response_answers 
WHERE survey_response_id = $1 
ORDER BY id
`

func (q *Queries) GetSurveyResponseAnswersByResponse(ctx context.Context, surveyResponseID uuid.UUID) ([]SurveyResponseAnswer, error) {
	rows, err := q.db.QueryContext(ctx, GetSurveyResponseAnswersByResponse, surveyResponseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SurveyResponseAnswer{}
	for rows.Next() {
		var i SurveyResponseAnswer
		if err := rows.Scan(
			&i.ID,
			&i.SurveyResponseID,
			&i.SurveyQuestionID,
			&i.AnswerText,
			&i.AnswerNumeric,
			&i.AnswerDate,
			&i.AnswerBoolean,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSurveyResponseAnswersWithDetails = `-- name: GetSurveyResponseAnswersWithDetails :many
SELECT 
    sra.id, sra.survey_response_id, sra.survey_question_id, sra.answer_text, sra.answer_numeric, sra.answer_date, sra.answer_boolean, sra.created_at, sra.updated_at,
    sq.question_text,
    sq.question_type,
    sq.question_options,
    sq.is_required
FROM survey_response_answers sra
JOIN survey_questions sq ON sra.survey_question_id = sq.id
WHERE sra.survey_response_id = $1 
ORDER BY sq.weight, sq.id
`

type GetSurveyResponseAnswersWithDetailsRow struct {
	ID               uuid.UUID      `json:"id"`
	SurveyResponseID uuid.UUID      `json:"survey_response_id"`
	SurveyQuestionID uuid.UUID      `json:"survey_question_id"`
	AnswerText       sql.NullString `json:"answer_text"`
	AnswerNumeric    sql.NullString `json:"answer_numeric"`
	AnswerDate       sql.NullTime   `json:"answer_date"`
	AnswerBoolean    sql.NullBool   `json:"answer_boolean"`
	CreatedAt        sql.NullTime   `json:"created_at"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
	QuestionText     string         `json:"question_text"`
	QuestionType     string         `json:"question_type"`
	QuestionOptions  sql.NullString `json:"question_options"`
	IsRequired       sql.NullBool   `json:"is_required"`
}

func (q *Queries) GetSurveyResponseAnswersWithDetails(ctx context.Context, surveyResponseID uuid.UUID) ([]GetSurveyResponseAnswersWithDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetSurveyResponseAnswersWithDetails, surveyResponseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSurveyResponseAnswersWithDetailsRow{}
	for rows.Next() {
		var i GetSurveyResponseAnswersWithDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.SurveyResponseID,
			&i.SurveyQuestionID,
			&i.AnswerText,
			&i.AnswerNumeric,
			&i.AnswerDate,
			&i.AnswerBoolean,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.QuestionText,
			&i.QuestionType,
			&i.QuestionOptions,
			&i.IsRequired,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSurveyResponseSummary = `-- name: GetSurveyResponseSummary :many
SELECT 
    sr.id as response_id,
    sr.response_date,
    sr.status,
    COUNT(sra.id) as answered_questions,
    COUNT(sq.id) as total_questions,
    ROUND(
        (COUNT(sra.id)::DECIMAL / NULLIF(COUNT(sq.id), 0)::DECIMAL) * 100, 2
    ) as completion_percentage
FROM survey_responses sr
LEFT JOIN survey_response_answers sra ON sr.id = sra.survey_response_id
LEFT JOIN survey_questions sq ON sr.survey_id = sq.survey_id AND sq.is_active = TRUE
WHERE sr.survey_id = $1
GROUP BY sr.id, sr.response_date, sr.status
ORDER BY sr.response_date DESC
`

type GetSurveyResponseSummaryRow struct {
	ResponseID           uuid.UUID      `json:"response_id"`
	ResponseDate         sql.NullTime   `json:"response_date"`
	Status               sql.NullString `json:"status"`
	AnsweredQuestions    int64          `json:"answered_questions"`
	TotalQuestions       int64          `json:"total_questions"`
	CompletionPercentage string         `json:"completion_percentage"`
}

func (q *Queries) GetSurveyResponseSummary(ctx context.Context, surveyID uuid.UUID) ([]GetSurveyResponseSummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, GetSurveyResponseSummary, surveyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSurveyResponseSummaryRow{}
	for rows.Next() {
		var i GetSurveyResponseSummaryRow
		if err := rows.Scan(
			&i.ResponseID,
			&i.ResponseDate,
			&i.Status,
			&i.AnsweredQuestions,
			&i.TotalQuestions,
			&i.CompletionPercentage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListSurveyResponseAnswers = `-- name: ListSurveyResponseAnswers :many
SELECT id, survey_response_id, survey_question_id, answer_text, answer_numeric, answer_date, answer_boolean, created_at, updated_at FROM survey_response_answers 
ORDER BY id
`

func (q *Queries) ListSurveyResponseAnswers(ctx context.Context) ([]SurveyResponseAnswer, error) {
	rows, err := q.db.QueryContext(ctx, ListSurveyResponseAnswers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SurveyResponseAnswer{}
	for rows.Next() {
		var i SurveyResponseAnswer
		if err := rows.Scan(
			&i.ID,
			&i.SurveyResponseID,
			&i.SurveyQuestionID,
			&i.AnswerText,
			&i.AnswerNumeric,
			&i.AnswerDate,
			&i.AnswerBoolean,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListSurveyResponseAnswersByQuestionType = `-- name: ListSurveyResponseAnswersByQuestionType :many
SELECT sra.id, sra.survey_response_id, sra.survey_question_id, sra.answer_text, sra.answer_numeric, sra.answer_date, sra.answer_boolean, sra.created_at, sra.updated_at FROM survey_response_answers sra
JOIN survey_questions sq ON sra.survey_question_id = sq.id
WHERE sq.question_type = $1 
ORDER BY sra.id
`

func (q *Queries) ListSurveyResponseAnswersByQuestionType(ctx context.Context, questionType string) ([]SurveyResponseAnswer, error) {
	rows, err := q.db.QueryContext(ctx, ListSurveyResponseAnswersByQuestionType, questionType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SurveyResponseAnswer{}
	for rows.Next() {
		var i SurveyResponseAnswer
		if err := rows.Scan(
			&i.ID,
			&i.SurveyResponseID,
			&i.SurveyQuestionID,
			&i.AnswerText,
			&i.AnswerNumeric,
			&i.AnswerDate,
			&i.AnswerBoolean,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchSurveyResponseAnswers = `-- name: SearchSurveyResponseAnswers :many
SELECT sra.id, sra.survey_response_id, sra.survey_question_id, sra.answer_text, sra.answer_numeric, sra.answer_date, sra.answer_boolean, sra.created_at, sra.updated_at FROM survey_response_answers sra
JOIN survey_questions sq ON sra.survey_question_id = sq.id
WHERE sq.question_text ILIKE $1 
ORDER BY sra.id
`

func (q *Queries) SearchSurveyResponseAnswers(ctx context.Context, questionText string) ([]SurveyResponseAnswer, error) {
	rows, err := q.db.QueryContext(ctx, SearchSurveyResponseAnswers, questionText)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SurveyResponseAnswer{}
	for rows.Next() {
		var i SurveyResponseAnswer
		if err := rows.Scan(
			&i.ID,
			&i.SurveyResponseID,
			&i.SurveyQuestionID,
			&i.AnswerText,
			&i.AnswerNumeric,
			&i.AnswerDate,
			&i.AnswerBoolean,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateSurveyResponseAnswer = `-- name: UpdateSurveyResponseAnswer :one
UPDATE survey_response_answers SET
    survey_response_id = $2, survey_question_id = $3, answer_text = $4,
    answer_numeric = $5, answer_date = $6, answer_boolean = $7, updated_at = NOW()
WHERE id = $1 RETURNING id, survey_response_id, survey_question_id, answer_text, answer_numeric, answer_date, answer_boolean, created_at, updated_at
`

type UpdateSurveyResponseAnswerParams struct {
	ID               uuid.UUID      `json:"id"`
	SurveyResponseID uuid.UUID      `json:"survey_response_id"`
	SurveyQuestionID uuid.UUID      `json:"survey_question_id"`
	AnswerText       sql.NullString `json:"answer_text"`
	AnswerNumeric    sql.NullString `json:"answer_numeric"`
	AnswerDate       sql.NullTime   `json:"answer_date"`
	AnswerBoolean    sql.NullBool   `json:"answer_boolean"`
}

func (q *Queries) UpdateSurveyResponseAnswer(ctx context.Context, arg UpdateSurveyResponseAnswerParams) (SurveyResponseAnswer, error) {
	row := q.db.QueryRowContext(ctx, UpdateSurveyResponseAnswer,
		arg.ID,
		arg.SurveyResponseID,
		arg.SurveyQuestionID,
		arg.AnswerText,
		arg.AnswerNumeric,
		arg.AnswerDate,
		arg.AnswerBoolean,
	)
	var i SurveyResponseAnswer
	err := row.Scan(
		&i.ID,
		&i.SurveyResponseID,
		&i.SurveyQuestionID,
		&i.AnswerText,
		&i.AnswerNumeric,
		&i.AnswerDate,
		&i.AnswerBoolean,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
