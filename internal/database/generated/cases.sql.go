// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: cases.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const CloseCase = `-- name: CloseCase :exec
UPDATE cases SET 
    status_id = (SELECT cs.id FROM case_status cs WHERE cs.grouping = 'Closed' AND cs.name = 'Closed' LIMIT 1),
    end_date = $2, modified_date = NOW(), updated_at = NOW() 
WHERE cases.id = $1
`

type CloseCaseParams struct {
	ID      uuid.UUID    `json:"id"`
	EndDate sql.NullTime `json:"end_date"`
}

func (q *Queries) CloseCase(ctx context.Context, arg CloseCaseParams) error {
	_, err := q.db.ExecContext(ctx, CloseCase, arg.ID, arg.EndDate)
	return err
}

const CreateCase = `-- name: CreateCase :one
INSERT INTO cases (
    case_type_id, subject, status_id, start_date, end_date, details, is_deleted
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, case_type_id, subject, status_id, start_date, end_date, details, is_deleted, created_date, modified_date, created_at, updated_at
`

type CreateCaseParams struct {
	CaseTypeID uuid.UUID      `json:"case_type_id"`
	Subject    string         `json:"subject"`
	StatusID   uuid.UUID      `json:"status_id"`
	StartDate  time.Time      `json:"start_date"`
	EndDate    sql.NullTime   `json:"end_date"`
	Details    sql.NullString `json:"details"`
	IsDeleted  sql.NullBool   `json:"is_deleted"`
}

func (q *Queries) CreateCase(ctx context.Context, arg CreateCaseParams) (Case, error) {
	row := q.db.QueryRowContext(ctx, CreateCase,
		arg.CaseTypeID,
		arg.Subject,
		arg.StatusID,
		arg.StartDate,
		arg.EndDate,
		arg.Details,
		arg.IsDeleted,
	)
	var i Case
	err := row.Scan(
		&i.ID,
		&i.CaseTypeID,
		&i.Subject,
		&i.StatusID,
		&i.StartDate,
		&i.EndDate,
		&i.Details,
		&i.IsDeleted,
		&i.CreatedDate,
		&i.ModifiedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const DeleteCase = `-- name: DeleteCase :exec
UPDATE cases SET is_deleted = TRUE, modified_date = NOW(), updated_at = NOW() WHERE id = $1
`

func (q *Queries) DeleteCase(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteCase, id)
	return err
}

const GetCase = `-- name: GetCase :one
SELECT id, case_type_id, subject, status_id, start_date, end_date, details, is_deleted, created_date, modified_date, created_at, updated_at FROM cases WHERE id = $1 AND is_deleted = FALSE
`

func (q *Queries) GetCase(ctx context.Context, id uuid.UUID) (Case, error) {
	row := q.db.QueryRowContext(ctx, GetCase, id)
	var i Case
	err := row.Scan(
		&i.ID,
		&i.CaseTypeID,
		&i.Subject,
		&i.StatusID,
		&i.StartDate,
		&i.EndDate,
		&i.Details,
		&i.IsDeleted,
		&i.CreatedDate,
		&i.ModifiedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetCaseCount = `-- name: GetCaseCount :one
SELECT COUNT(*) FROM cases WHERE is_deleted = FALSE
`

func (q *Queries) GetCaseCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, GetCaseCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const GetCaseStats = `-- name: GetCaseStats :many
SELECT 
    ct.name as case_type,
    cs.grouping as status_grouping,
    cs.name as status,
    COUNT(c.id) as case_count
FROM case_types ct
CROSS JOIN case_status cs
LEFT JOIN cases c ON ct.id = c.case_type_id AND cs.id = c.status_id AND c.is_deleted = FALSE
WHERE ct.is_active = $1 AND cs.is_active = $1
GROUP BY ct.name, cs.grouping, cs.name, ct.weight, cs.weight
ORDER BY ct.weight, ct.name, cs.weight, cs.name
`

type GetCaseStatsRow struct {
	CaseType       string         `json:"case_type"`
	StatusGrouping sql.NullString `json:"status_grouping"`
	Status         string         `json:"status"`
	CaseCount      int64          `json:"case_count"`
}

func (q *Queries) GetCaseStats(ctx context.Context, isActive sql.NullBool) ([]GetCaseStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetCaseStats, isActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCaseStatsRow{}
	for rows.Next() {
		var i GetCaseStatsRow
		if err := rows.Scan(
			&i.CaseType,
			&i.StatusGrouping,
			&i.Status,
			&i.CaseCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetCaseWithDetails = `-- name: GetCaseWithDetails :one
SELECT 
    c.id, c.case_type_id, c.subject, c.status_id, c.start_date, c.end_date, c.details, c.is_deleted, c.created_date, c.modified_date, c.created_at, c.updated_at,
    ct.name as case_type_name,
    ct.title as case_type_title,
    cs.name as status_name,
    cs.label as status_label,
    cs.grouping as status_grouping,
    cs.color as status_color
FROM cases c
JOIN case_types ct ON c.case_type_id = ct.id
JOIN case_status cs ON c.status_id = cs.id
WHERE c.id = $1 AND c.is_deleted = FALSE
`

type GetCaseWithDetailsRow struct {
	ID             uuid.UUID      `json:"id"`
	CaseTypeID     uuid.UUID      `json:"case_type_id"`
	Subject        string         `json:"subject"`
	StatusID       uuid.UUID      `json:"status_id"`
	StartDate      time.Time      `json:"start_date"`
	EndDate        sql.NullTime   `json:"end_date"`
	Details        sql.NullString `json:"details"`
	IsDeleted      sql.NullBool   `json:"is_deleted"`
	CreatedDate    sql.NullTime   `json:"created_date"`
	ModifiedDate   sql.NullTime   `json:"modified_date"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	UpdatedAt      sql.NullTime   `json:"updated_at"`
	CaseTypeName   string         `json:"case_type_name"`
	CaseTypeTitle  string         `json:"case_type_title"`
	StatusName     string         `json:"status_name"`
	StatusLabel    string         `json:"status_label"`
	StatusGrouping sql.NullString `json:"status_grouping"`
	StatusColor    sql.NullString `json:"status_color"`
}

func (q *Queries) GetCaseWithDetails(ctx context.Context, id uuid.UUID) (GetCaseWithDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, GetCaseWithDetails, id)
	var i GetCaseWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.CaseTypeID,
		&i.Subject,
		&i.StatusID,
		&i.StartDate,
		&i.EndDate,
		&i.Details,
		&i.IsDeleted,
		&i.CreatedDate,
		&i.ModifiedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CaseTypeName,
		&i.CaseTypeTitle,
		&i.StatusName,
		&i.StatusLabel,
		&i.StatusGrouping,
		&i.StatusColor,
	)
	return i, err
}

const HardDeleteCase = `-- name: HardDeleteCase :exec
DELETE FROM cases WHERE id = $1
`

func (q *Queries) HardDeleteCase(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, HardDeleteCase, id)
	return err
}

const ListCases = `-- name: ListCases :many
SELECT id, case_type_id, subject, status_id, start_date, end_date, details, is_deleted, created_date, modified_date, created_at, updated_at FROM cases 
WHERE is_deleted = FALSE 
ORDER BY start_date DESC
`

func (q *Queries) ListCases(ctx context.Context) ([]Case, error) {
	rows, err := q.db.QueryContext(ctx, ListCases)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Case{}
	for rows.Next() {
		var i Case
		if err := rows.Scan(
			&i.ID,
			&i.CaseTypeID,
			&i.Subject,
			&i.StatusID,
			&i.StartDate,
			&i.EndDate,
			&i.Details,
			&i.IsDeleted,
			&i.CreatedDate,
			&i.ModifiedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListCasesByContact = `-- name: ListCasesByContact :many
SELECT c.id, c.case_type_id, c.subject, c.status_id, c.start_date, c.end_date, c.details, c.is_deleted, c.created_date, c.modified_date, c.created_at, c.updated_at FROM cases c
JOIN case_contacts cc ON c.id = cc.case_id
WHERE cc.contact_id = $1 AND c.is_deleted = FALSE 
ORDER BY c.start_date DESC
`

func (q *Queries) ListCasesByContact(ctx context.Context, contactID uuid.UUID) ([]Case, error) {
	rows, err := q.db.QueryContext(ctx, ListCasesByContact, contactID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Case{}
	for rows.Next() {
		var i Case
		if err := rows.Scan(
			&i.ID,
			&i.CaseTypeID,
			&i.Subject,
			&i.StatusID,
			&i.StartDate,
			&i.EndDate,
			&i.Details,
			&i.IsDeleted,
			&i.CreatedDate,
			&i.ModifiedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListCasesByContactRole = `-- name: ListCasesByContactRole :many
SELECT c.id, c.case_type_id, c.subject, c.status_id, c.start_date, c.end_date, c.details, c.is_deleted, c.created_date, c.modified_date, c.created_at, c.updated_at FROM cases c
JOIN case_contacts cc ON c.id = cc.case_id
WHERE cc.contact_id = $1 AND cc.role = $2 AND c.is_deleted = FALSE 
ORDER BY c.start_date DESC
`

type ListCasesByContactRoleParams struct {
	ContactID uuid.UUID `json:"contact_id"`
	Role      string    `json:"role"`
}

func (q *Queries) ListCasesByContactRole(ctx context.Context, arg ListCasesByContactRoleParams) ([]Case, error) {
	rows, err := q.db.QueryContext(ctx, ListCasesByContactRole, arg.ContactID, arg.Role)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Case{}
	for rows.Next() {
		var i Case
		if err := rows.Scan(
			&i.ID,
			&i.CaseTypeID,
			&i.Subject,
			&i.StatusID,
			&i.StartDate,
			&i.EndDate,
			&i.Details,
			&i.IsDeleted,
			&i.CreatedDate,
			&i.ModifiedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListCasesByDateRange = `-- name: ListCasesByDateRange :many
SELECT id, case_type_id, subject, status_id, start_date, end_date, details, is_deleted, created_date, modified_date, created_at, updated_at FROM cases 
WHERE start_date >= $1 AND start_date <= $2 AND is_deleted = FALSE 
ORDER BY start_date DESC
`

type ListCasesByDateRangeParams struct {
	StartDate   time.Time `json:"start_date"`
	StartDate_2 time.Time `json:"start_date_2"`
}

func (q *Queries) ListCasesByDateRange(ctx context.Context, arg ListCasesByDateRangeParams) ([]Case, error) {
	rows, err := q.db.QueryContext(ctx, ListCasesByDateRange, arg.StartDate, arg.StartDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Case{}
	for rows.Next() {
		var i Case
		if err := rows.Scan(
			&i.ID,
			&i.CaseTypeID,
			&i.Subject,
			&i.StatusID,
			&i.StartDate,
			&i.EndDate,
			&i.Details,
			&i.IsDeleted,
			&i.CreatedDate,
			&i.ModifiedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListCasesByStatus = `-- name: ListCasesByStatus :many
SELECT id, case_type_id, subject, status_id, start_date, end_date, details, is_deleted, created_date, modified_date, created_at, updated_at FROM cases 
WHERE status_id = $1 AND is_deleted = FALSE 
ORDER BY start_date DESC
`

func (q *Queries) ListCasesByStatus(ctx context.Context, statusID uuid.UUID) ([]Case, error) {
	rows, err := q.db.QueryContext(ctx, ListCasesByStatus, statusID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Case{}
	for rows.Next() {
		var i Case
		if err := rows.Scan(
			&i.ID,
			&i.CaseTypeID,
			&i.Subject,
			&i.StatusID,
			&i.StartDate,
			&i.EndDate,
			&i.Details,
			&i.IsDeleted,
			&i.CreatedDate,
			&i.ModifiedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListCasesByStatusGrouping = `-- name: ListCasesByStatusGrouping :many
SELECT c.id, c.case_type_id, c.subject, c.status_id, c.start_date, c.end_date, c.details, c.is_deleted, c.created_date, c.modified_date, c.created_at, c.updated_at FROM cases c
JOIN case_status cs ON c.status_id = cs.id
WHERE cs.grouping = $1 AND c.is_deleted = FALSE 
ORDER BY c.start_date DESC
`

func (q *Queries) ListCasesByStatusGrouping(ctx context.Context, grouping sql.NullString) ([]Case, error) {
	rows, err := q.db.QueryContext(ctx, ListCasesByStatusGrouping, grouping)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Case{}
	for rows.Next() {
		var i Case
		if err := rows.Scan(
			&i.ID,
			&i.CaseTypeID,
			&i.Subject,
			&i.StatusID,
			&i.StartDate,
			&i.EndDate,
			&i.Details,
			&i.IsDeleted,
			&i.CreatedDate,
			&i.ModifiedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListCasesByType = `-- name: ListCasesByType :many
SELECT id, case_type_id, subject, status_id, start_date, end_date, details, is_deleted, created_date, modified_date, created_at, updated_at FROM cases 
WHERE case_type_id = $1 AND is_deleted = FALSE 
ORDER BY start_date DESC
`

func (q *Queries) ListCasesByType(ctx context.Context, caseTypeID uuid.UUID) ([]Case, error) {
	rows, err := q.db.QueryContext(ctx, ListCasesByType, caseTypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Case{}
	for rows.Next() {
		var i Case
		if err := rows.Scan(
			&i.ID,
			&i.CaseTypeID,
			&i.Subject,
			&i.StatusID,
			&i.StartDate,
			&i.EndDate,
			&i.Details,
			&i.IsDeleted,
			&i.CreatedDate,
			&i.ModifiedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListClosedCases = `-- name: ListClosedCases :many
SELECT c.id, c.case_type_id, c.subject, c.status_id, c.start_date, c.end_date, c.details, c.is_deleted, c.created_date, c.modified_date, c.created_at, c.updated_at FROM cases c
JOIN case_status cs ON c.status_id = cs.id
WHERE cs.grouping = 'Closed' AND c.is_deleted = FALSE 
ORDER BY c.start_date DESC
`

func (q *Queries) ListClosedCases(ctx context.Context) ([]Case, error) {
	rows, err := q.db.QueryContext(ctx, ListClosedCases)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Case{}
	for rows.Next() {
		var i Case
		if err := rows.Scan(
			&i.ID,
			&i.CaseTypeID,
			&i.Subject,
			&i.StatusID,
			&i.StartDate,
			&i.EndDate,
			&i.Details,
			&i.IsDeleted,
			&i.CreatedDate,
			&i.ModifiedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListOpenCases = `-- name: ListOpenCases :many
SELECT c.id, c.case_type_id, c.subject, c.status_id, c.start_date, c.end_date, c.details, c.is_deleted, c.created_date, c.modified_date, c.created_at, c.updated_at FROM cases c
JOIN case_status cs ON c.status_id = cs.id
WHERE cs.grouping = 'Open' AND c.is_deleted = FALSE 
ORDER BY c.start_date DESC
`

func (q *Queries) ListOpenCases(ctx context.Context) ([]Case, error) {
	rows, err := q.db.QueryContext(ctx, ListOpenCases)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Case{}
	for rows.Next() {
		var i Case
		if err := rows.Scan(
			&i.ID,
			&i.CaseTypeID,
			&i.Subject,
			&i.StatusID,
			&i.StartDate,
			&i.EndDate,
			&i.Details,
			&i.IsDeleted,
			&i.CreatedDate,
			&i.ModifiedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchCases = `-- name: SearchCases :many
SELECT c.id, c.case_type_id, c.subject, c.status_id, c.start_date, c.end_date, c.details, c.is_deleted, c.created_date, c.modified_date, c.created_at, c.updated_at FROM cases c
JOIN case_types ct ON c.case_type_id = ct.id
WHERE (c.subject ILIKE $1 OR c.details ILIKE $1 OR ct.name ILIKE $1) 
AND c.is_deleted = FALSE 
ORDER BY c.start_date DESC
`

func (q *Queries) SearchCases(ctx context.Context, subject string) ([]Case, error) {
	rows, err := q.db.QueryContext(ctx, SearchCases, subject)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Case{}
	for rows.Next() {
		var i Case
		if err := rows.Scan(
			&i.ID,
			&i.CaseTypeID,
			&i.Subject,
			&i.StatusID,
			&i.StartDate,
			&i.EndDate,
			&i.Details,
			&i.IsDeleted,
			&i.CreatedDate,
			&i.ModifiedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateCase = `-- name: UpdateCase :one
UPDATE cases SET
    case_type_id = $2, subject = $3, status_id = $4, start_date = $5,
    end_date = $6, details = $7, is_deleted = $8, modified_date = NOW(),
    updated_at = NOW()
WHERE id = $1 RETURNING id, case_type_id, subject, status_id, start_date, end_date, details, is_deleted, created_date, modified_date, created_at, updated_at
`

type UpdateCaseParams struct {
	ID         uuid.UUID      `json:"id"`
	CaseTypeID uuid.UUID      `json:"case_type_id"`
	Subject    string         `json:"subject"`
	StatusID   uuid.UUID      `json:"status_id"`
	StartDate  time.Time      `json:"start_date"`
	EndDate    sql.NullTime   `json:"end_date"`
	Details    sql.NullString `json:"details"`
	IsDeleted  sql.NullBool   `json:"is_deleted"`
}

func (q *Queries) UpdateCase(ctx context.Context, arg UpdateCaseParams) (Case, error) {
	row := q.db.QueryRowContext(ctx, UpdateCase,
		arg.ID,
		arg.CaseTypeID,
		arg.Subject,
		arg.StatusID,
		arg.StartDate,
		arg.EndDate,
		arg.Details,
		arg.IsDeleted,
	)
	var i Case
	err := row.Scan(
		&i.ID,
		&i.CaseTypeID,
		&i.Subject,
		&i.StatusID,
		&i.StartDate,
		&i.EndDate,
		&i.Details,
		&i.IsDeleted,
		&i.CreatedDate,
		&i.ModifiedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateCaseStatusById = `-- name: UpdateCaseStatusById :exec
UPDATE cases SET status_id = $2, modified_date = NOW(), updated_at = NOW() WHERE id = $1
`

type UpdateCaseStatusByIdParams struct {
	ID       uuid.UUID `json:"id"`
	StatusID uuid.UUID `json:"status_id"`
}

func (q *Queries) UpdateCaseStatusById(ctx context.Context, arg UpdateCaseStatusByIdParams) error {
	_, err := q.db.ExecContext(ctx, UpdateCaseStatusById, arg.ID, arg.StatusID)
	return err
}
