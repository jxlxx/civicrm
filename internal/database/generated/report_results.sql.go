// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: report_results.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const CreateReportResult = `-- name: CreateReportResult :one
INSERT INTO report_results (
    report_instance_id, execution_date, result_data, row_count, execution_time_ms, status, error_message
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, report_instance_id, execution_date, result_data, row_count, execution_time_ms, status, error_message, created_at
`

type CreateReportResultParams struct {
	ReportInstanceID uuid.UUID             `json:"report_instance_id"`
	ExecutionDate    sql.NullTime          `json:"execution_date"`
	ResultData       pqtype.NullRawMessage `json:"result_data"`
	RowCount         sql.NullInt32         `json:"row_count"`
	ExecutionTimeMs  sql.NullInt32         `json:"execution_time_ms"`
	Status           sql.NullString        `json:"status"`
	ErrorMessage     sql.NullString        `json:"error_message"`
}

func (q *Queries) CreateReportResult(ctx context.Context, arg CreateReportResultParams) (ReportResult, error) {
	row := q.db.QueryRowContext(ctx, CreateReportResult,
		arg.ReportInstanceID,
		arg.ExecutionDate,
		arg.ResultData,
		arg.RowCount,
		arg.ExecutionTimeMs,
		arg.Status,
		arg.ErrorMessage,
	)
	var i ReportResult
	err := row.Scan(
		&i.ID,
		&i.ReportInstanceID,
		&i.ExecutionDate,
		&i.ResultData,
		&i.RowCount,
		&i.ExecutionTimeMs,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
	)
	return i, err
}

const DeleteReportResult = `-- name: DeleteReportResult :exec
DELETE FROM report_results WHERE id = $1
`

func (q *Queries) DeleteReportResult(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteReportResult, id)
	return err
}

const DeleteReportResultsByInstance = `-- name: DeleteReportResultsByInstance :exec
DELETE FROM report_results WHERE report_instance_id = $1
`

func (q *Queries) DeleteReportResultsByInstance(ctx context.Context, reportInstanceID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteReportResultsByInstance, reportInstanceID)
	return err
}

const GetLatestReportResult = `-- name: GetLatestReportResult :one
SELECT id, report_instance_id, execution_date, result_data, row_count, execution_time_ms, status, error_message, created_at FROM report_results 
WHERE report_instance_id = $1 
ORDER BY execution_date DESC LIMIT 1
`

func (q *Queries) GetLatestReportResult(ctx context.Context, reportInstanceID uuid.UUID) (ReportResult, error) {
	row := q.db.QueryRowContext(ctx, GetLatestReportResult, reportInstanceID)
	var i ReportResult
	err := row.Scan(
		&i.ID,
		&i.ReportInstanceID,
		&i.ExecutionDate,
		&i.ResultData,
		&i.RowCount,
		&i.ExecutionTimeMs,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
	)
	return i, err
}

const GetReportPerformanceStats = `-- name: GetReportPerformanceStats :many
SELECT 
    ri.name as instance_name,
    COUNT(rr.id) as execution_count,
    AVG(rr.execution_time_ms) as avg_execution_time,
    AVG(rr.row_count) as avg_row_count,
    COUNT(CASE WHEN rr.status = 'Completed' THEN 1 END) as success_count,
    COUNT(CASE WHEN rr.status = 'Failed' THEN 1 END) as failure_count
FROM report_results rr
JOIN report_instances ri ON rr.report_instance_id = ri.id
WHERE rr.execution_date >= $1
GROUP BY ri.id, ri.name
ORDER BY execution_count DESC
`

type GetReportPerformanceStatsRow struct {
	InstanceName     string  `json:"instance_name"`
	ExecutionCount   int64   `json:"execution_count"`
	AvgExecutionTime float64 `json:"avg_execution_time"`
	AvgRowCount      float64 `json:"avg_row_count"`
	SuccessCount     int64   `json:"success_count"`
	FailureCount     int64   `json:"failure_count"`
}

func (q *Queries) GetReportPerformanceStats(ctx context.Context, executionDate sql.NullTime) ([]GetReportPerformanceStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetReportPerformanceStats, executionDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetReportPerformanceStatsRow{}
	for rows.Next() {
		var i GetReportPerformanceStatsRow
		if err := rows.Scan(
			&i.InstanceName,
			&i.ExecutionCount,
			&i.AvgExecutionTime,
			&i.AvgRowCount,
			&i.SuccessCount,
			&i.FailureCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetReportResult = `-- name: GetReportResult :one
SELECT id, report_instance_id, execution_date, result_data, row_count, execution_time_ms, status, error_message, created_at FROM report_results WHERE id = $1
`

func (q *Queries) GetReportResult(ctx context.Context, id uuid.UUID) (ReportResult, error) {
	row := q.db.QueryRowContext(ctx, GetReportResult, id)
	var i ReportResult
	err := row.Scan(
		&i.ID,
		&i.ReportInstanceID,
		&i.ExecutionDate,
		&i.ResultData,
		&i.RowCount,
		&i.ExecutionTimeMs,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
	)
	return i, err
}

const GetReportResultStats = `-- name: GetReportResultStats :many
SELECT 
    rr.status,
    COUNT(rr.id) as result_count,
    AVG(rr.execution_time_ms) as avg_execution_time,
    AVG(rr.row_count) as avg_row_count
FROM report_results rr
WHERE rr.report_instance_id = $1
GROUP BY rr.status
ORDER BY rr.status
`

type GetReportResultStatsRow struct {
	Status           sql.NullString `json:"status"`
	ResultCount      int64          `json:"result_count"`
	AvgExecutionTime float64        `json:"avg_execution_time"`
	AvgRowCount      float64        `json:"avg_row_count"`
}

func (q *Queries) GetReportResultStats(ctx context.Context, reportInstanceID uuid.UUID) ([]GetReportResultStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetReportResultStats, reportInstanceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetReportResultStatsRow{}
	for rows.Next() {
		var i GetReportResultStatsRow
		if err := rows.Scan(
			&i.Status,
			&i.ResultCount,
			&i.AvgExecutionTime,
			&i.AvgRowCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetReportResultsByDateRange = `-- name: GetReportResultsByDateRange :many
SELECT id, report_instance_id, execution_date, result_data, row_count, execution_time_ms, status, error_message, created_at FROM report_results 
WHERE report_instance_id = $1 AND execution_date >= $2 AND execution_date <= $3 
ORDER BY execution_date DESC
`

type GetReportResultsByDateRangeParams struct {
	ReportInstanceID uuid.UUID    `json:"report_instance_id"`
	ExecutionDate    sql.NullTime `json:"execution_date"`
	ExecutionDate_2  sql.NullTime `json:"execution_date_2"`
}

func (q *Queries) GetReportResultsByDateRange(ctx context.Context, arg GetReportResultsByDateRangeParams) ([]ReportResult, error) {
	rows, err := q.db.QueryContext(ctx, GetReportResultsByDateRange, arg.ReportInstanceID, arg.ExecutionDate, arg.ExecutionDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReportResult{}
	for rows.Next() {
		var i ReportResult
		if err := rows.Scan(
			&i.ID,
			&i.ReportInstanceID,
			&i.ExecutionDate,
			&i.ResultData,
			&i.RowCount,
			&i.ExecutionTimeMs,
			&i.Status,
			&i.ErrorMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetReportResultsByInstance = `-- name: GetReportResultsByInstance :many
SELECT id, report_instance_id, execution_date, result_data, row_count, execution_time_ms, status, error_message, created_at FROM report_results 
WHERE report_instance_id = $1 
ORDER BY execution_date DESC
`

func (q *Queries) GetReportResultsByInstance(ctx context.Context, reportInstanceID uuid.UUID) ([]ReportResult, error) {
	rows, err := q.db.QueryContext(ctx, GetReportResultsByInstance, reportInstanceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReportResult{}
	for rows.Next() {
		var i ReportResult
		if err := rows.Scan(
			&i.ID,
			&i.ReportInstanceID,
			&i.ExecutionDate,
			&i.ResultData,
			&i.RowCount,
			&i.ExecutionTimeMs,
			&i.Status,
			&i.ErrorMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetReportResultsByStatus = `-- name: GetReportResultsByStatus :many
SELECT id, report_instance_id, execution_date, result_data, row_count, execution_time_ms, status, error_message, created_at FROM report_results 
WHERE report_instance_id = $1 AND status = $2 
ORDER BY execution_date DESC
`

type GetReportResultsByStatusParams struct {
	ReportInstanceID uuid.UUID      `json:"report_instance_id"`
	Status           sql.NullString `json:"status"`
}

func (q *Queries) GetReportResultsByStatus(ctx context.Context, arg GetReportResultsByStatusParams) ([]ReportResult, error) {
	rows, err := q.db.QueryContext(ctx, GetReportResultsByStatus, arg.ReportInstanceID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReportResult{}
	for rows.Next() {
		var i ReportResult
		if err := rows.Scan(
			&i.ID,
			&i.ReportInstanceID,
			&i.ExecutionDate,
			&i.ResultData,
			&i.RowCount,
			&i.ExecutionTimeMs,
			&i.Status,
			&i.ErrorMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListFailedReportResults = `-- name: ListFailedReportResults :many
SELECT id, report_instance_id, execution_date, result_data, row_count, execution_time_ms, status, error_message, created_at FROM report_results 
WHERE status = 'Failed' 
ORDER BY execution_date DESC
`

func (q *Queries) ListFailedReportResults(ctx context.Context) ([]ReportResult, error) {
	rows, err := q.db.QueryContext(ctx, ListFailedReportResults)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReportResult{}
	for rows.Next() {
		var i ReportResult
		if err := rows.Scan(
			&i.ID,
			&i.ReportInstanceID,
			&i.ExecutionDate,
			&i.ResultData,
			&i.RowCount,
			&i.ExecutionTimeMs,
			&i.Status,
			&i.ErrorMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListReportResults = `-- name: ListReportResults :many
SELECT id, report_instance_id, execution_date, result_data, row_count, execution_time_ms, status, error_message, created_at FROM report_results 
ORDER BY execution_date DESC
`

func (q *Queries) ListReportResults(ctx context.Context) ([]ReportResult, error) {
	rows, err := q.db.QueryContext(ctx, ListReportResults)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReportResult{}
	for rows.Next() {
		var i ReportResult
		if err := rows.Scan(
			&i.ID,
			&i.ReportInstanceID,
			&i.ExecutionDate,
			&i.ResultData,
			&i.RowCount,
			&i.ExecutionTimeMs,
			&i.Status,
			&i.ErrorMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListReportResultsByDateRange = `-- name: ListReportResultsByDateRange :many
SELECT id, report_instance_id, execution_date, result_data, row_count, execution_time_ms, status, error_message, created_at FROM report_results 
WHERE execution_date >= $1 AND execution_date <= $2 
ORDER BY execution_date DESC
`

type ListReportResultsByDateRangeParams struct {
	ExecutionDate   sql.NullTime `json:"execution_date"`
	ExecutionDate_2 sql.NullTime `json:"execution_date_2"`
}

func (q *Queries) ListReportResultsByDateRange(ctx context.Context, arg ListReportResultsByDateRangeParams) ([]ReportResult, error) {
	rows, err := q.db.QueryContext(ctx, ListReportResultsByDateRange, arg.ExecutionDate, arg.ExecutionDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReportResult{}
	for rows.Next() {
		var i ReportResult
		if err := rows.Scan(
			&i.ID,
			&i.ReportInstanceID,
			&i.ExecutionDate,
			&i.ResultData,
			&i.RowCount,
			&i.ExecutionTimeMs,
			&i.Status,
			&i.ErrorMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const MarkReportResultCompleted = `-- name: MarkReportResultCompleted :exec
UPDATE report_results SET status = 'Completed' WHERE id = $1
`

func (q *Queries) MarkReportResultCompleted(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, MarkReportResultCompleted, id)
	return err
}

const MarkReportResultFailed = `-- name: MarkReportResultFailed :exec
UPDATE report_results SET status = 'Failed', error_message = $2 WHERE id = $1
`

type MarkReportResultFailedParams struct {
	ID           uuid.UUID      `json:"id"`
	ErrorMessage sql.NullString `json:"error_message"`
}

func (q *Queries) MarkReportResultFailed(ctx context.Context, arg MarkReportResultFailedParams) error {
	_, err := q.db.ExecContext(ctx, MarkReportResultFailed, arg.ID, arg.ErrorMessage)
	return err
}

const SearchReportResults = `-- name: SearchReportResults :many
SELECT rr.id, rr.report_instance_id, rr.execution_date, rr.result_data, rr.row_count, rr.execution_time_ms, rr.status, rr.error_message, rr.created_at FROM report_results rr
JOIN report_instances ri ON rr.report_instance_id = ri.id
WHERE ri.name ILIKE $1 
ORDER BY rr.execution_date DESC
`

func (q *Queries) SearchReportResults(ctx context.Context, name string) ([]ReportResult, error) {
	rows, err := q.db.QueryContext(ctx, SearchReportResults, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReportResult{}
	for rows.Next() {
		var i ReportResult
		if err := rows.Scan(
			&i.ID,
			&i.ReportInstanceID,
			&i.ExecutionDate,
			&i.ResultData,
			&i.RowCount,
			&i.ExecutionTimeMs,
			&i.Status,
			&i.ErrorMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateReportResult = `-- name: UpdateReportResult :one
UPDATE report_results SET
    report_instance_id = $2, execution_date = $3, result_data = $4,
    row_count = $5, execution_time_ms = $6, status = $7, error_message = $8
WHERE id = $1 RETURNING id, report_instance_id, execution_date, result_data, row_count, execution_time_ms, status, error_message, created_at
`

type UpdateReportResultParams struct {
	ID               uuid.UUID             `json:"id"`
	ReportInstanceID uuid.UUID             `json:"report_instance_id"`
	ExecutionDate    sql.NullTime          `json:"execution_date"`
	ResultData       pqtype.NullRawMessage `json:"result_data"`
	RowCount         sql.NullInt32         `json:"row_count"`
	ExecutionTimeMs  sql.NullInt32         `json:"execution_time_ms"`
	Status           sql.NullString        `json:"status"`
	ErrorMessage     sql.NullString        `json:"error_message"`
}

func (q *Queries) UpdateReportResult(ctx context.Context, arg UpdateReportResultParams) (ReportResult, error) {
	row := q.db.QueryRowContext(ctx, UpdateReportResult,
		arg.ID,
		arg.ReportInstanceID,
		arg.ExecutionDate,
		arg.ResultData,
		arg.RowCount,
		arg.ExecutionTimeMs,
		arg.Status,
		arg.ErrorMessage,
	)
	var i ReportResult
	err := row.Scan(
		&i.ID,
		&i.ReportInstanceID,
		&i.ExecutionDate,
		&i.ResultData,
		&i.RowCount,
		&i.ExecutionTimeMs,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
	)
	return i, err
}

const UpdateReportResultStatus = `-- name: UpdateReportResultStatus :exec
UPDATE report_results SET status = $2 WHERE id = $1
`

type UpdateReportResultStatusParams struct {
	ID     uuid.UUID      `json:"id"`
	Status sql.NullString `json:"status"`
}

func (q *Queries) UpdateReportResultStatus(ctx context.Context, arg UpdateReportResultStatusParams) error {
	_, err := q.db.ExecContext(ctx, UpdateReportResultStatus, arg.ID, arg.Status)
	return err
}
