// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: report_subscriptions.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const ActivateReportSubscription = `-- name: ActivateReportSubscription :exec
UPDATE report_subscriptions SET is_active = TRUE, updated_at = NOW() WHERE id = $1
`

func (q *Queries) ActivateReportSubscription(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, ActivateReportSubscription, id)
	return err
}

const CreateReportSubscription = `-- name: CreateReportSubscription :one
INSERT INTO report_subscriptions (
    report_instance_id, contact_id, delivery_method, delivery_config, is_active
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, report_instance_id, contact_id, delivery_method, delivery_config, is_active, created_at, updated_at
`

type CreateReportSubscriptionParams struct {
	ReportInstanceID uuid.UUID             `json:"report_instance_id"`
	ContactID        uuid.UUID             `json:"contact_id"`
	DeliveryMethod   string                `json:"delivery_method"`
	DeliveryConfig   pqtype.NullRawMessage `json:"delivery_config"`
	IsActive         sql.NullBool          `json:"is_active"`
}

func (q *Queries) CreateReportSubscription(ctx context.Context, arg CreateReportSubscriptionParams) (ReportSubscription, error) {
	row := q.db.QueryRowContext(ctx, CreateReportSubscription,
		arg.ReportInstanceID,
		arg.ContactID,
		arg.DeliveryMethod,
		arg.DeliveryConfig,
		arg.IsActive,
	)
	var i ReportSubscription
	err := row.Scan(
		&i.ID,
		&i.ReportInstanceID,
		&i.ContactID,
		&i.DeliveryMethod,
		&i.DeliveryConfig,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const DeactivateReportSubscription = `-- name: DeactivateReportSubscription :exec
UPDATE report_subscriptions SET is_active = FALSE, updated_at = NOW() WHERE id = $1
`

func (q *Queries) DeactivateReportSubscription(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeactivateReportSubscription, id)
	return err
}

const DeleteReportSubscription = `-- name: DeleteReportSubscription :exec
DELETE FROM report_subscriptions WHERE id = $1
`

func (q *Queries) DeleteReportSubscription(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteReportSubscription, id)
	return err
}

const GetActiveReportSubscriptions = `-- name: GetActiveReportSubscriptions :many
SELECT id, report_instance_id, contact_id, delivery_method, delivery_config, is_active, created_at, updated_at FROM report_subscriptions 
WHERE is_active = TRUE 
ORDER BY id
`

func (q *Queries) GetActiveReportSubscriptions(ctx context.Context) ([]ReportSubscription, error) {
	rows, err := q.db.QueryContext(ctx, GetActiveReportSubscriptions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReportSubscription{}
	for rows.Next() {
		var i ReportSubscription
		if err := rows.Scan(
			&i.ID,
			&i.ReportInstanceID,
			&i.ContactID,
			&i.DeliveryMethod,
			&i.DeliveryConfig,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetReportSubscription = `-- name: GetReportSubscription :one
SELECT id, report_instance_id, contact_id, delivery_method, delivery_config, is_active, created_at, updated_at FROM report_subscriptions WHERE id = $1
`

func (q *Queries) GetReportSubscription(ctx context.Context, id uuid.UUID) (ReportSubscription, error) {
	row := q.db.QueryRowContext(ctx, GetReportSubscription, id)
	var i ReportSubscription
	err := row.Scan(
		&i.ID,
		&i.ReportInstanceID,
		&i.ContactID,
		&i.DeliveryMethod,
		&i.DeliveryConfig,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetReportSubscriptionByInstanceAndContact = `-- name: GetReportSubscriptionByInstanceAndContact :one
SELECT id, report_instance_id, contact_id, delivery_method, delivery_config, is_active, created_at, updated_at FROM report_subscriptions 
WHERE report_instance_id = $1 AND contact_id = $2 
ORDER BY id LIMIT 1
`

type GetReportSubscriptionByInstanceAndContactParams struct {
	ReportInstanceID uuid.UUID `json:"report_instance_id"`
	ContactID        uuid.UUID `json:"contact_id"`
}

func (q *Queries) GetReportSubscriptionByInstanceAndContact(ctx context.Context, arg GetReportSubscriptionByInstanceAndContactParams) (ReportSubscription, error) {
	row := q.db.QueryRowContext(ctx, GetReportSubscriptionByInstanceAndContact, arg.ReportInstanceID, arg.ContactID)
	var i ReportSubscription
	err := row.Scan(
		&i.ID,
		&i.ReportInstanceID,
		&i.ContactID,
		&i.DeliveryMethod,
		&i.DeliveryConfig,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetReportSubscriptionStats = `-- name: GetReportSubscriptionStats :many
SELECT 
    rs.delivery_method,
    COUNT(rs.id) as subscription_count
FROM report_subscriptions rs
WHERE rs.is_active = $1
GROUP BY rs.delivery_method
ORDER BY rs.delivery_method
`

type GetReportSubscriptionStatsRow struct {
	DeliveryMethod    string `json:"delivery_method"`
	SubscriptionCount int64  `json:"subscription_count"`
}

func (q *Queries) GetReportSubscriptionStats(ctx context.Context, isActive sql.NullBool) ([]GetReportSubscriptionStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetReportSubscriptionStats, isActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetReportSubscriptionStatsRow{}
	for rows.Next() {
		var i GetReportSubscriptionStatsRow
		if err := rows.Scan(&i.DeliveryMethod, &i.SubscriptionCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetReportSubscriptionSummary = `-- name: GetReportSubscriptionSummary :many
SELECT 
    ri.name as report_name,
    rt.report_type,
    rs.delivery_method,
    c.first_name || ' ' || c.last_name as contact_name,
    rs.created_at
FROM report_subscriptions rs
JOIN report_instances ri ON rs.report_instance_id = ri.id
JOIN report_templates rt ON ri.report_template_id = rt.id
JOIN contacts c ON rs.contact_id = c.id
WHERE rs.is_active = $1
ORDER BY rs.created_at DESC
`

type GetReportSubscriptionSummaryRow struct {
	ReportName     string       `json:"report_name"`
	ReportType     string       `json:"report_type"`
	DeliveryMethod string       `json:"delivery_method"`
	ContactName    interface{}  `json:"contact_name"`
	CreatedAt      sql.NullTime `json:"created_at"`
}

func (q *Queries) GetReportSubscriptionSummary(ctx context.Context, isActive sql.NullBool) ([]GetReportSubscriptionSummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, GetReportSubscriptionSummary, isActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetReportSubscriptionSummaryRow{}
	for rows.Next() {
		var i GetReportSubscriptionSummaryRow
		if err := rows.Scan(
			&i.ReportName,
			&i.ReportType,
			&i.DeliveryMethod,
			&i.ContactName,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetReportSubscriptionsByContact = `-- name: GetReportSubscriptionsByContact :many
SELECT id, report_instance_id, contact_id, delivery_method, delivery_config, is_active, created_at, updated_at FROM report_subscriptions 
WHERE contact_id = $1 AND is_active = $2 
ORDER BY id
`

type GetReportSubscriptionsByContactParams struct {
	ContactID uuid.UUID    `json:"contact_id"`
	IsActive  sql.NullBool `json:"is_active"`
}

func (q *Queries) GetReportSubscriptionsByContact(ctx context.Context, arg GetReportSubscriptionsByContactParams) ([]ReportSubscription, error) {
	rows, err := q.db.QueryContext(ctx, GetReportSubscriptionsByContact, arg.ContactID, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReportSubscription{}
	for rows.Next() {
		var i ReportSubscription
		if err := rows.Scan(
			&i.ID,
			&i.ReportInstanceID,
			&i.ContactID,
			&i.DeliveryMethod,
			&i.DeliveryConfig,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetReportSubscriptionsByDeliveryMethod = `-- name: GetReportSubscriptionsByDeliveryMethod :many
SELECT id, report_instance_id, contact_id, delivery_method, delivery_config, is_active, created_at, updated_at FROM report_subscriptions 
WHERE delivery_method = $1 AND is_active = $2 
ORDER BY id
`

type GetReportSubscriptionsByDeliveryMethodParams struct {
	DeliveryMethod string       `json:"delivery_method"`
	IsActive       sql.NullBool `json:"is_active"`
}

func (q *Queries) GetReportSubscriptionsByDeliveryMethod(ctx context.Context, arg GetReportSubscriptionsByDeliveryMethodParams) ([]ReportSubscription, error) {
	rows, err := q.db.QueryContext(ctx, GetReportSubscriptionsByDeliveryMethod, arg.DeliveryMethod, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReportSubscription{}
	for rows.Next() {
		var i ReportSubscription
		if err := rows.Scan(
			&i.ID,
			&i.ReportInstanceID,
			&i.ContactID,
			&i.DeliveryMethod,
			&i.DeliveryConfig,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetReportSubscriptionsByInstance = `-- name: GetReportSubscriptionsByInstance :many
SELECT id, report_instance_id, contact_id, delivery_method, delivery_config, is_active, created_at, updated_at FROM report_subscriptions 
WHERE report_instance_id = $1 AND is_active = $2 
ORDER BY id
`

type GetReportSubscriptionsByInstanceParams struct {
	ReportInstanceID uuid.UUID    `json:"report_instance_id"`
	IsActive         sql.NullBool `json:"is_active"`
}

func (q *Queries) GetReportSubscriptionsByInstance(ctx context.Context, arg GetReportSubscriptionsByInstanceParams) ([]ReportSubscription, error) {
	rows, err := q.db.QueryContext(ctx, GetReportSubscriptionsByInstance, arg.ReportInstanceID, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReportSubscription{}
	for rows.Next() {
		var i ReportSubscription
		if err := rows.Scan(
			&i.ID,
			&i.ReportInstanceID,
			&i.ContactID,
			&i.DeliveryMethod,
			&i.DeliveryConfig,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListReportSubscriptions = `-- name: ListReportSubscriptions :many
SELECT id, report_instance_id, contact_id, delivery_method, delivery_config, is_active, created_at, updated_at FROM report_subscriptions 
ORDER BY id
`

func (q *Queries) ListReportSubscriptions(ctx context.Context) ([]ReportSubscription, error) {
	rows, err := q.db.QueryContext(ctx, ListReportSubscriptions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReportSubscription{}
	for rows.Next() {
		var i ReportSubscription
		if err := rows.Scan(
			&i.ID,
			&i.ReportInstanceID,
			&i.ContactID,
			&i.DeliveryMethod,
			&i.DeliveryConfig,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListReportSubscriptionsByDateRange = `-- name: ListReportSubscriptionsByDateRange :many
SELECT id, report_instance_id, contact_id, delivery_method, delivery_config, is_active, created_at, updated_at FROM report_subscriptions 
WHERE created_at >= $1 AND created_at <= $2 
ORDER BY created_at DESC
`

type ListReportSubscriptionsByDateRangeParams struct {
	CreatedAt   sql.NullTime `json:"created_at"`
	CreatedAt_2 sql.NullTime `json:"created_at_2"`
}

func (q *Queries) ListReportSubscriptionsByDateRange(ctx context.Context, arg ListReportSubscriptionsByDateRangeParams) ([]ReportSubscription, error) {
	rows, err := q.db.QueryContext(ctx, ListReportSubscriptionsByDateRange, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReportSubscription{}
	for rows.Next() {
		var i ReportSubscription
		if err := rows.Scan(
			&i.ID,
			&i.ReportInstanceID,
			&i.ContactID,
			&i.DeliveryMethod,
			&i.DeliveryConfig,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchReportSubscriptions = `-- name: SearchReportSubscriptions :many
SELECT rs.id, rs.report_instance_id, rs.contact_id, rs.delivery_method, rs.delivery_config, rs.is_active, rs.created_at, rs.updated_at FROM report_subscriptions rs
JOIN contacts c ON rs.contact_id = c.id
WHERE (c.first_name ILIKE $1 OR c.last_name ILIKE $1 OR c.organization_name ILIKE $1) AND rs.is_active = $2
ORDER BY rs.id
`

type SearchReportSubscriptionsParams struct {
	FirstName sql.NullString `json:"first_name"`
	IsActive  sql.NullBool   `json:"is_active"`
}

func (q *Queries) SearchReportSubscriptions(ctx context.Context, arg SearchReportSubscriptionsParams) ([]ReportSubscription, error) {
	rows, err := q.db.QueryContext(ctx, SearchReportSubscriptions, arg.FirstName, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReportSubscription{}
	for rows.Next() {
		var i ReportSubscription
		if err := rows.Scan(
			&i.ID,
			&i.ReportInstanceID,
			&i.ContactID,
			&i.DeliveryMethod,
			&i.DeliveryConfig,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateReportSubscription = `-- name: UpdateReportSubscription :one
UPDATE report_subscriptions SET
    report_instance_id = $2, contact_id = $3, delivery_method = $4,
    delivery_config = $5, is_active = $6, updated_at = NOW()
WHERE id = $1 RETURNING id, report_instance_id, contact_id, delivery_method, delivery_config, is_active, created_at, updated_at
`

type UpdateReportSubscriptionParams struct {
	ID               uuid.UUID             `json:"id"`
	ReportInstanceID uuid.UUID             `json:"report_instance_id"`
	ContactID        uuid.UUID             `json:"contact_id"`
	DeliveryMethod   string                `json:"delivery_method"`
	DeliveryConfig   pqtype.NullRawMessage `json:"delivery_config"`
	IsActive         sql.NullBool          `json:"is_active"`
}

func (q *Queries) UpdateReportSubscription(ctx context.Context, arg UpdateReportSubscriptionParams) (ReportSubscription, error) {
	row := q.db.QueryRowContext(ctx, UpdateReportSubscription,
		arg.ID,
		arg.ReportInstanceID,
		arg.ContactID,
		arg.DeliveryMethod,
		arg.DeliveryConfig,
		arg.IsActive,
	)
	var i ReportSubscription
	err := row.Scan(
		&i.ID,
		&i.ReportInstanceID,
		&i.ContactID,
		&i.DeliveryMethod,
		&i.DeliveryConfig,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateReportSubscriptionDeliveryConfig = `-- name: UpdateReportSubscriptionDeliveryConfig :exec
UPDATE report_subscriptions SET delivery_config = $2, updated_at = NOW() WHERE id = $1
`

type UpdateReportSubscriptionDeliveryConfigParams struct {
	ID             uuid.UUID             `json:"id"`
	DeliveryConfig pqtype.NullRawMessage `json:"delivery_config"`
}

func (q *Queries) UpdateReportSubscriptionDeliveryConfig(ctx context.Context, arg UpdateReportSubscriptionDeliveryConfigParams) error {
	_, err := q.db.ExecContext(ctx, UpdateReportSubscriptionDeliveryConfig, arg.ID, arg.DeliveryConfig)
	return err
}

const UpdateReportSubscriptionDeliveryMethod = `-- name: UpdateReportSubscriptionDeliveryMethod :exec
UPDATE report_subscriptions SET delivery_method = $2, updated_at = NOW() WHERE id = $1
`

type UpdateReportSubscriptionDeliveryMethodParams struct {
	ID             uuid.UUID `json:"id"`
	DeliveryMethod string    `json:"delivery_method"`
}

func (q *Queries) UpdateReportSubscriptionDeliveryMethod(ctx context.Context, arg UpdateReportSubscriptionDeliveryMethodParams) error {
	_, err := q.db.ExecContext(ctx, UpdateReportSubscriptionDeliveryMethod, arg.ID, arg.DeliveryMethod)
	return err
}
